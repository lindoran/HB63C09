                      ;       Extended Basic for 6809
                      ;       =======================
                      ; FOR HB63C09 USE, WITH 16K ROM (SPACE FOR SD IO BELOW, AND MON09 FROM JQ'S SBC ROM )
                      ;
                      ;       MODIFICATIONS FOR HB63C09M:
                      ;       ==========================
                      ;       - v1.2
                      ;       - CHANGED UART ADDRESS TO $A000 (AS IT IS BACK THERE)
                      ;       - CHANGED BIN START TO $C000 
                      ;       - ADDED SUPPORT TO THE SCRIPTING TOOLCHAIN TO USE AS LANGUAGE MODULE FOR
                      ;         JQ's MON09 IMPLIMENTATION https://6809sbc.wordpress.com/
                      ;       - NEAR AS I CAN TELL, JQ's ROM IS BUGGED WITH STRING HANDLEING HOWEVER GREGS'S
                      ;         ISN'T. THIS MAY BE DUE TO THE AGE OF THE CODE AND HOW ASM6809 HANDLES CERTAIN
                      ;         DIRECTIVES, AS WELL AS PERAMITERS.  THIS IS WHY I SWITCHED TO THIS ASSEMBLER FOR
                      ;         THIS MODULE.
                      ;       - I ADDED THE QUALITY OF LIFE UPDATES FROM THE JQ ROM BUT LEFT THE OLD RAM DETECTION
                      ;         UTILITY, AS IT WILL ENCOUNTER THE IO RANGE AND STOP ON MY BUILD, JUST LIKE ON
                      ;         GRANT SEARLE / JEFF TRANTER'S DESIGNS. ALSO WHEN COMPILED AS A MODULE IT WILL
                      ;         RESPOND TO 'BYE' TO RETURN TO THE MONITOR. (LIFTED FROM THE JQ SOURCE)
                      ;       - REMOVED ACIA INIT - THE AVR HANDLES INIT OF THE USART, THE PROTOCOL IS
                      ;         THE SAME AS THE ORIGINAL 68B50 ACIA (REGISTER LOCATION) AND MIMICS ENOUGH OF
                      ;         THE CHIP FOR THIS TO WORK.    
                      ;       - BELOW IS THE LEAD IN FROM GREG'S SOURCE (DigiCoolThings) From his repo: 
                      ;         https://github.com/DigicoolThings/MECB
                      
                      ;Based on Grant Searle's published AS9 compatible Assembler source code.
                      ;       Refer: http://searle.x10host.com/6809/Simple6809.html
                      ;
                      ;       I've reformatted and modified, to enable assembly with the asm6809 Assembler.
                      ;       Including:
                      ;       - Added semi-colon end-of-line comment seperators.
                      ;       - Added braces to expressions for correct expression evaluation operator order. 
                      ;       - Added SETDP directive for correct addressing mode for Zero Page references.
                      ;
                      ;       For MECB 6809 CPU Card use, with 48K RAM, 16K ROM and I/O page at $C0xx
                      ;       - Changed UART EQUate for $C008 ACIA location.
                      ;       - Changed RTS_LOW EQUate for 8 bits + 2 Stop, RTS Low, Disable Interrupts ($11).
                      ;
                      ;       Greg@DigicoolThings.com         Oct 2023
                      ;
                      ;  
                      ;
                      ;       z80dad@gmail.com        MAR, 2024
                      
0000                            SETDP $00              ; Tell asm6809 Assembler Direct Page is det for Zero Page.
                      
0001                  MON09     SET  1            ; SET TO '1' TO INCLUDE AS PART OF MON09
C000                  ROMSTART  EQU  $C000        ; START OF ROM
                      
                       IF MON09                   ; USE WITH MON09
0000                      INCLUDE "../../mon09/V37/mon09v37_API.inc"
                      ; MON09 ROM ENTRY POINTS FOR USER PROGRAMS
E44C                  MON09_CHKCHR    EQU     $E44C
E46D                  MON09_DISASS    EQU     $E46D
E476                  MON09_DISREG    EQU     $E476
E467                  MON09_DLOAD     EQU     $E467
FDC4                  MON09_FIRQADR   EQU     $FDC4
E446                  MON09_GETADR    EQU     $E446
E443                  MON09_GETBYT    EQU     $E443
E43A                  MON09_GETCHR    EQU     $E43A
E43D                  MON09_GETECH    EQU     $E43D
E440                  MON09_GETNIB    EQU     $E440
E449                  MON09_GETRNG    EQU     $E449
E45B                  MON09_HEXOUT    EQU     $E45B
E458                  MON09_HOUT      EQU     $E458
FDD0                  MON09_ILOPADR   EQU     $FDD0
FDC8                  MON09_IRQADR    EQU     $FDC8
E455                  MON09_LFCR      EQU     $E455
E46A                  MON09_LOAD      EQU     $E46A
E479                  MON09_MONITOR   EQU     $E479
FDCC                  MON09_NMIADR    EQU     $FDCC
E44F                  MON09_PUTCHR    EQU     $E44F
E47C                  MON09_RESET     EQU     $E47C
E452                  MON09_SPACE     EQU     $E452
E473                  MON09_STEPDI    EQU     $E473
E470                  MON09_STEP      EQU     $E470
FDBC                  MON09_SWI2ADR   EQU     $FDBC
FDC0                  MON09_SWI3ADR   EQU     $FDC0
FDB8                  MON09_SWIADR    EQU     $FDB8
E45E                  MON09_WRDOUT    EQU     $E45E
E461                  MON09_WRLIN     EQU     $E461
E464                  MON09_WRMSG     EQU     $E464
                       ENDIF
                      
A000                  UART      EQU  $A000            ; MC6850 ACIA (UART) base address (Originally $A000)
A001                  RECEV     EQU  UART+1          
A001                  TRANS     EQU  UART+1          
A000                  USTAT     EQU  UART            
A000                  UCTRL     EQU  UART            
                                                     
0008                  BS        EQU  8             ;BACKSPACE 
000D                  CR        EQU  $D            ;ENTER KEY 
001B                  ESC       EQU  $1B           ;ESCAPE CODE 
0020                  SPACE     EQU  $20           ;SPACE (BLANK) 
003A                  STKBUF    EQU  58            ;STACK BUFFER ROOM 
00FA                  LBUFMX    EQU  250           ;MAX NUMBER OF CHARS IN A BASIC LINE 
00FA                  MAXLIN    EQU  $FA           ;MAXIMUM MS BYTE OF LINE NUMBER 
                      * PSEUDO OPS                      
0021                  SKP1      EQU  $21           ;OP CODE OF BRN ' SKIP ONE BYTE
008C                  SKP2      EQU  $8C           ;OP CODE OF CMPX # - SKIP TWO BYTES 
0086                  SKP1LD    EQU  $86           ;OP CODE OF LDA # - SKIP THE NEXT BYTE 
                      *                            ;AND LOAD THE VALUE OF THAT BYTE INTO ACCA ' THIS
                      *                            ;IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE 
                      
                      ; THIS BIT IS FOR INIT OF THE 6850 - IT IS NOT NEEDED ON THE HB63C09
                      
                      ;RTS_LOW   EQU  $11     ; Originally $95 (8 bits + 1 Stop, RTS Low, Enabled Interrupts)
                                              ; Use $11 for 8 bits + 2 Stop, RTS Low, Disable Interrupts
                                              ; Or $15 for 8 bits + 1 Stop, RTS Low, Disable Interrupts
                      
0000                            ORG  0               
                      
0000                  ENDFLG    RMB  1             ;STOP/END FLAG: POSITIVE=STOP, NEG=END 
0001                  CHARAC    RMB  1             ;TERMINATOR FLAG 1 
0002                  ENDCHR    RMB  1             ;TERMINATOR FLAG 2 
0003                  TMPLOC    RMB  1             ;SCRATCH VARIABLE 
0004                  IFCTR     RMB  1             ;IF COUNTER - HOW MANY IF STATEMENTS IN A LINE 
0005                  DIMFLG    RMB  1             ;*DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING 
0006                  VALTYP    RMB  1             ;*DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING 
0007                  GARBFL    RMB  1             ;*TV STRING SPACE HOUSEKEEPING FLAG 
0008                  ARYDIS    RMB  1             ;DISABLE ARRAY SEARCH: 00=ALLOW SEARCH 
0009                  INPFLG    RMB  1             ;*TV INPUT FLAG: READ=0, INPUT<>0 
000A                  RELFLG    RMB  1             ;*TV RELATIONAL OPERATOR FLAG 
000B                  TEMPPT    RMB  2             ;*PV TEMPORARY STRING STACK POINTER 
000D                  LASTPT    RMB  2             ;*PV ADDR OF LAST USED STRING STACK ADDRESS 
000F                  TEMPTR    RMB  2             ;TEMPORARY POINTER 
0011                  TMPTR1    RMB  2             ;TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH) 
0013                  FPA2      RMB  4             ;FLOATING POINT ACCUMULATOR #2 MANTISSA 
0017                  BOTSTK    RMB  2             ;BOTTOM OF STACK AT LAST CHECK 
0019                  TXTTAB    RMB  2             ;*PV BEGINNING OF BASIC PROGRAM 
001B                  VARTAB    RMB  2             ;*PV START OF VARIABLES 
001D                  ARYTAB    RMB  2             ;*PV START OF ARRAYS 
001F                  ARYEND    RMB  2             ;*PV END OF ARRAYS (+1) 
0021                  FRETOP    RMB  2             ;*PV START OF STRING STORAGE (TOP OF FREE RAM) 
0023                  STRTAB    RMB  2             ;*PV START OF STRING VARIABLES 
0025                  FRESPC    RMB  2             ;UTILITY STRING POINTER 
0027                  MEMSIZ    RMB  2             ;*PV TOP OF STRING SPACE 
0029                  OLDTXT    RMB  2             ;SAVED LINE NUMBER DURING A "STOP" 
002B                  BINVAL    RMB  2             ;BINARY VALUE OF A CONVERTED LINE NUMBER 
002D                  OLDPTR    RMB  2             ;SAVED INPUT PTR DURING A "STOP" 
002F                  TINPTR    RMB  2             ;TEMPORARY INPUT POINTER STORAGE 
0031                  DATTXT    RMB  2             ;*PV 'DATA' STATEMENT LINE NUMBER POINTER 
0033                  DATPTR    RMB  2             ;*PV 'DATA' STATEMENT ADDRESS POINTER 
0035                  DATTMP    RMB  2             ;DATA POINTER FOR 'INPUT' & 'READ' 
0037                  VARNAM    RMB  2             ;*TV TEMP STORAGE FOR A VARIABLE NAME 
0039                  VARPTR    RMB  2             ;*TV POINTER TO A VARIABLE DESCRIPTOR 
003B                  VARDES    RMB  2             ;TEMP POINTER TO A VARIABLE DESCRIPTOR 
003D                  RELPTR    RMB  2             ;POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE 
003F                  TRELFL    RMB  1             ;TEMPORARY RELATIONAL OPERATOR FLAG BYTE 
                      * FLOATING POINT ACCUMULATORS;#3,4 & 5 ARE MOSTLY                      
                      * USED AS SCRATCH PAD VARIABLES.                      
                      ** FLOATING POINT ACCUMULATOR;#3 :PACKED: ($40-$44)                      
0040                  V40       RMB  1               
0041                  V41       RMB  1               
0042                  V42       RMB  1               
0043                  V43       RMB  1               
0044                  V44       RMB  1               
                      ** FLOATING POINT ACCUMULATOR;#4 :PACKED: ($45-$49)                      
0045                  V45       RMB  1               
0046                  V46       RMB  1               
0047                  V47       RMB  1               
0048                  V48       RMB  2               
                      ** FLOATING POINT ACCUMULATOR;#5 :PACKED: ($4A'$4E)
004A                  V4A       RMB  1               
004B                  V4B       RMB  2               
004D                  V4D       RMB  2               
                      ** FLOATING POINT ACCUMULATOR;#0                      
004F                  FP0EXP    RMB  1             ;*PV FLOATING POINT ACCUMULATOR #0 EXPONENT 
0050                  FPA0      RMB  4             ;*PV FLOATING POINT ACCUMULATOR #0 MANTISSA 
0054                  FP0SGN    RMB  1             ;*PV FLOATING POINT ACCUMULATOR #0 SIGN 
0055                  COEFCT    RMB  1             ;POLYNOMIAL COEFFICIENT COUNTER 
0056                  STRDES    RMB  5             ;TEMPORARY STRING DESCRIPTOR 
005B                  FPCARY    RMB  1             ;FLOATING POINT CARRY BYTE 
                      ** FLOATING POINT ACCUMULATOR;#1                      
005C                  FP1EXP    RMB  1             ;*PV FLOATING POINT ACCUMULATOR #1 EXPONENT 
005D                  FPA1      RMB  4             ;*PV FLOATING POINT ACCUMULATOR #1 MANTISSA 
0061                  FP1SGN    RMB  1             ;*PV FLOATING POINT ACCUMULATOR #1 SIGN 
0062                  RESSGN    RMB  1             ;SIGN OF RESULT OF FLOATING POINT OPERATION 
0063                  FPSBYT    RMB  1             ;FLOATING POINT SUB BYTE (FIFTH BYTE) 
0064                  COEFPT    RMB  2             ;POLYNOMIAL COEFFICIENT POINTER 
0066                  LSTTXT    RMB  2             ;CURRENT LINE POINTER DURING LIST 
0068                  CURLIN    RMB  2             ;*PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT 
006A                  DEVCFW    RMB  1             ;*TV TAB FIELD WIDTH 
006B                  DEVLCF    RMB  1             ;*TV TAB ZONE 
006C                  DEVPOS    RMB  1             ;*TV PRINT POSITION 
006D                  DEVWID    RMB  1             ;*TV PRINT WIDTH 
006E                  RSTFLG    RMB  1             ;*PV WARM START FLAG: $55=WARM, OTHER=COLD 
006F                  RSTVEC    RMB  2             ;*PV WARM START VECTOR - JUMP ADDRESS FOR WARM START 
0071                  TOPRAM    RMB  2             ;*PV TOP OF RAM 
0073                  IKEYIM    RMB  1             ;*TV INKEY$ RAM IMAGE 
0074                  ZERO      RMB  2             ;*PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO 
                      * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM                      
0076                  LPTCFW    RMB  1             ;16 
0077                  LPTLCF    RMB  1             ;112 
0078                  LPTWID    RMB  1             ;132 
0079                  LPTPOS    RMB  1             ;0 
007A                  EXECJP    RMB  2             ;LB4AA 
                                                     
                      * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM                      
                      * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE                      
                      * INTERPRETED IS STORED AT CHARAD.                      
007C  0C84            GETNCH    INC  <CHARAD+1     ;*PV INCREMENT LS BYTE OF INPUT POINTER 
007E  2602                      BNE  GETCCH        ;*PV BRANCH IF NOT ZERO (NO CARRY) 
0080  0C83                      INC  <CHARAD       ;*PV INCREMENT MS BYTE OF INPUT POINTER 
0082  B6              GETCCH    FCB  $B6           ;*PV OP CODE OF LDA EXTENDED 
0083                  CHARAD    RMB  2             ;*PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT 
                      *         *    CHARACTER WHICH THE BASIC INTERPRETER IS  
                      *         *    PROCESSING      
0085  7EC1BD                    JMP  BROMHK        ;JUMP BACK INTO THE BASIC ROM
                                                     
0088                  VAB       RMB  1             ;= LOW ORDER FOUR BYTES OF THE PRODUCT 
0089                  VAC       RMB  1             ;= OF A FLOATING POINT MULTIPLICATION 
008A                  VAD       RMB  1             ;= THESE BYTES ARE USE AS RANDOM DATA 
008B                  VAE       RMB  1             ;= BY THE RND STATEMENT 
                                                     
                      * EXTENDED BASIC VARIABLES                      
008C                  TRCFLG    RMB  1             ;*PV TRACE FLAG 0=OFF ELSE=ON 
008D                  USRADR    RMB  2             ;*PV ADDRESS OF THE START OF USR VECTORS 
                                                     
                      * EXTENDED BASIC SCRATCH PAD VARIABLES                      
008F                  VCF       RMB  2               
0091                  VD1       RMB  2               
0093                  VD3       RMB  2               
0095                  VD5       RMB  2               
0097                  VD7       RMB  1               
0098                  VD8       RMB  1               
0099                  VD9       RMB  1               
009A                  VDA       RMB  1               
009B                  SW3VEC    RMB  3               
009E                  SW2VEC    RMB  3               
00A1                  SWIVEC    RMB  3               
00A4                  NMIVEC    RMB  3               
00A7                  IRQVEC    RMB  3               
00AA                  FRQVEC    RMB  3               
00AD                  USRJMP    RMB  3             ;JUMP ADDRESS FOR BASIC'S USR FUNCTION 
00B0                  RVSEED    RMB  1             ;* FLOATING POINT RANDOM NUMBER SEED EXPONENT 
00B1                            RMB  4             ;* MANTISSA: INITIALLY SET TO $804FC75259 
                                                     
                      **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)                      
00B5                  USR0      RMB  2             ;USR 0 VECTOR 
00B7                            RMB  2             ;USR 1 
00B9                            RMB  2             ;USR 2 
00BB                            RMB  2             ;USR 3 
00BD                            RMB  2             ;USR 4 
00BF                            RMB  2             ;USR 5 
00C1                            RMB  2             ;USR 6 
00C3                            RMB  2             ;USR 7 
00C5                            RMB  2             ;USR 8 
00C7                            RMB  2             ;USR 9 
                                                     
00C9                  STRSTK    RMB  8*5           ;STRING DESCRIPTOR STACK 
00F1                  LINHDR    RMB  2             ;LINE INPUT BUFFER HEADER 
00F3                  LINBUF    RMB  LBUFMX+1      ;BASIC LINE INPUT BUFFER 
01EE                  STRBUF    RMB  41            ;STRING BUFFER 
                                                     
0217                  PROGST    RMB  1             ;START OF PROGRAM SPACE 
                      *         INTERRUPT VECTORS                 
FFF2                            ORG  $FFF2           
FFF2                  SWI3      RMB  2               
FFF4                  SWI2      RMB  2               
FFF6                  FIRQ      RMB  2               
FFF8                  IRQ       RMB  2               
FFFA                  SWI       RMB  2               
FFFC                  NMI       RMB  2               
FFFE                  RESETV    RMB  2               
                                                     
                      
C000                            ORG  ROMSTART
                       IF MON09
C000                  MON09_ENTRY
C000  7EC049                    JMP  RESVEC
                       ENDIF
                                                     
                      * CONSOLE IN                      
C003  8D03            LA171     BSR  KEYIN         ;GET A CHARACTER FROM CONSOLE IN 
C005  27FC                      BEQ  LA171         ;LOOP IF NO KEY DOWN 
C007  39                        RTS                  
                                                     
                      *                              
                      * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY                      
                      * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.                      
                      *                              
                      *                              
C008                  LA1C1                          
C008  B6A000          KEYIN     LDA  USTAT           
C00B  8501                      BITA #1              
C00D  2706                      BEQ  NOCHAR          
C00F  B6A001                    LDA  RECEV           
C012  847F                      ANDA #$7F            
C014  39                        RTS                  
C015  4F              NOCHAR    CLRA                 
C016  39                        RTS                  
                                                     
                                                     
                                                     
                      * CONSOLE OUT                      
C017  8D24            PUTCHR    BSR  WAITACIA        
C019  3402                      PSHS A               
C01B  810D                      CMPA #CR           ;IS IT CARRIAGE RETURN? 
C01D  270B                      BEQ  NEWLINE       ;YES 
C01F  B7A001                    STA  TRANS           
C022  0C79                      INC  LPTPOS        ;INCREMENT CHARACTER COUNTER 
C024  9679                      LDA  LPTPOS        ;CHECK FOR END OF LINE PRINTER LINE 
C026  9178                      CMPA LPTWID        ;AT END OF LINE PRINTER LINE? 
C028  2510                      BLO  PUTEND        ;NO 
C02A  0F79            NEWLINE   CLR  LPTPOS        ;RESET CHARACTER COUNTER 
C02C  8D0F                      BSR  WAITACIA        
C02E  860D                      LDA  #13             
C030  B7A001                    STA  TRANS           
C033  8D08                      BSR  WAITACIA        
C035  860A                      LDA  #10           ;DO LINEFEED AFTER CR 
C037  B7A001                    STA  TRANS           
C03A  3502            PUTEND    PULS A               
C03C  39                        RTS                  
                                                     
C03D  3402            WAITACIA  PSHS A               
C03F  B6A000          WRWAIT    LDA  USTAT           
C042  8502                      BITA #2              
C044  27F9                      BEQ  WRWAIT          
C046  3502                      PULS A               
C048  39                        RTS                  
                                                     
                      *                              
C049                  RESVEC                         
C049  10CE01EE        LA00E     LDS  #LINBUF+LBUFMX+1 ;SET STACK TO TOP OF LINE INPUT BUFFER 
C04D  966E                      LDA  RSTFLG        ;GET WARM START FLAG 
C04F  8155                      CMPA #$55          ;IS IT A WARM START? 
C051  260A                      BNE  BACDST        ;NO - D0 A COLD START 
C053  9E6F                      LDX  RSTVEC        ;WARM START VECTOR 
C055  A684                      LDA  ,X            ;GET FIRST BYTE OF WARM START ADDR 
C057  8112                      CMPA #$12          ;IS IT NOP? 
C059  2602                      BNE  BACDST        ;NO - DO A COLD START 
C05B  6E84                      JMP  ,X            ;YES, G0 THERE 
                                                     
                      * COLD START ENTRY                      
                                                     
C05D  8E0218          BACDST    LDX  #PROGST+1     ;POINT X TO CLEAR 1ST 1K OF RAM 
C060  6F83            LA077     CLR  ,--X          ;MOVE POINTER DOWN TWO-CLEAR BYTE 
C062  3001                      LEAX 1,X           ;ADVANCE POINTER ONE 
C064  26FA                      BNE  LA077         ;KEEP GOING IF NOT AT BOTTOM OF PAGE 0 
C066  8E0217                    LDX  #PROGST       ;SET TO START OF PROGRAM SPACE 
C069  6F80                      CLR  ,X+           ;CLEAR 1ST BYTE OF BASIC PROGRAM 
C06B  9F19                      STX  TXTTAB        ;BEGINNING OF BASIC PROGRAM 
C06D  A602            LA084     LDA  2,X           ;LOOK FOR END OF MEMORY 
C06F  43                        COMA               ;* COMPLEMENT IT AND PUT IT BACK 
C070  A702                      STA  2,X           ;* INTO SYSTEM MEMORY 
C072  A102                      CMPA 2,X           ;IS IT RAM? 
C074  2606                      BNE  LA093         ;BRANCH IF NOT (ROM, BAD RAM OR NO RAM) 
C076  3001                      LEAX 1,X           ;MOVE POINTER UP ONE 
C078  6301                      COM  1,X           ;RE-COMPLEMENT TO RESTORE BYTE 
C07A  20F1                      BRA  LA084         ;KEEP LOOKING FOR END OF RAM 
C07C  9F71            LA093     STX  TOPRAM        ;SAVE ABSOLUTE TOP OF RAM 
C07E  9F27                      STX  MEMSIZ        ;SAVE TOP OF STRING SPACE 
C080  9F23                      STX  STRTAB        ;SAVE START OF STRING VARIABLES 
C082  3089FF38                  LEAX -200,X        ;CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES 
C086  9F21                      STX  FRETOP        ;SAVE START OF STRING SPACE 
C088  1F14                      TFR  X,S           ;PUT STACK THERE 
C08A  8EC0CC                    LDX  #LA10D        ;POINT X TO ROM SOURCE DATA 
C08D  CE0076                    LDU  #LPTCFW       ;POINT U TO RAM DESTINATION 
C090  C612                      LDB  #18           ;MOVE 18 BYTES 
C092  BDC1AC                    JSR  LA59A         ;MOVE 18 BYTES FROM ROM TO RAM 
C095  CE00A7                    LDU  #IRQVEC       ;POINT U TO NEXT RAM DESTINATION 
C098  C604                      LDB  #4            ;MOVE 4 MORE BYTES 
C09A  BDC1AC                    JSR  LA59A         ;MOVE 4 BYTES FROM ROM TO RAM 
C09D  8639                      LDA  #$39            
C09F  97F0                      STA  LINHDR-1      ;PUT RTS IN LINHDR-1 
C0A1  BDC4BA                    JSR  LAD19         ;G0 DO A 'NEW'
                      * EXTENDED BASIC INITIALISATION                      
C0A4  8E00B5                    LDX  #USR0         ;INITIALIZE ADDRESS OF START OF 
C0A7  9F8D                      STX  USRADR        ;USR JUMP TABLE 
                      * INITIALIZE THE USR CALLS TO;'FC ERROR'
C0A9  CECBD1                    LDU  #LB44A        ;ADDRESS OF 'FC ERROR' ROUTINE
C0AC  C60A                      LDB  #10           ;10 USR CALLS IN EX BASIC 
C0AE  EF81            L8031     STU  ,X++          ;STORE 'FC' ERROR AT USR ADDRESSES
C0B0  5A                        DECB               ;FINISHED ALL 10? 
C0B1  26FB                      BNE  L8031         ;NO 
                      
                      ;; THIS BIT NOT REQURED FOR HB63C09 
                      ;;* INITIALISE ACIA
                      ;;          LDA  #RTS_LOW      ;DIV16 CLOCK -> 7372800 / 4 / 16 = 115200
                      ;;          STA  UCTRL
                      
C0B3  8EC101                    LDX  #LA147-1      ;POINT X TO COLOR BASIC COPYRIGHT MESSAGE 
C0B6  BDD0E8                    JSR  LB99C         ;PRINT 'COLOR BASIC'
C0B9  8EC0C4                    LDX  #BAWMST       ;WARM START ADDRESS 
C0BC  9F6F                      STX  RSTVEC        ;SAVE IT 
C0BE  8655                      LDA  #$55          ;WARM START FLAG 
C0C0  976E                      STA  RSTFLG        ;SAVE IT 
C0C2  2004                      BRA  LA0F3         ;GO TO BASIC'S MAIN LOOP
C0C4  12              BAWMST    NOP                ;NOP REQ'D FOR WARM START
C0C5  BDC4D4                    JSR  LAD33         ;DO PART OF A NEW 
C0C8  7EC422          LA0F3     JMP  LAC73         ;GO TO MAIN LOOP OF BASIC 
                      *                              
                      * FIRQ SERVICE ROUTINE                      
C0CB                  BFRQSV                         
C0CB  3B                        RTI                  
                      *                              
                      * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE                      
C0CC  10              LA10D     FCB  16            ;TAB FIELD WIDTH 
C0CD  40                        FCB  64            ;LAST TAB ZONE 
C0CE  50                        FCB  80            ;PRINTER WIDTH 
C0CF  00                        FCB  0             ;LINE PRINTER POSITION 
C0D0  CBD1                      FDB  LB44A         ;ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
                      * LINE INPUT ROUTINE                      
C0D2  0C84                      INC  CHARAD+1        
C0D4  2602                      BNE  LA123           
C0D6  0C83                      INC  CHARAD          
C0D8  B60000          LA123     LDA  >0000           
C0DB  7EC1BD                    JMP  BROMHK          
                      *                              
                      * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1                      
C0DE  7EC1BC                    JMP  BIRQSV        ;IRQ SERVICE 
C0E1  7EC0CB                    JMP  BFRQSV        ;FIRQ SERVICE 
C0E4  7ECBD1                    JMP  LB44A         ;USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
C0E7  80                        FCB  $80           ;*RANDOM SEED 
C0E8  4FC7                      FDB  $4FC7         ;*RANDON SEED OF MANTISSA 
C0EA  5259                      FDB  $5259         ;*.811635157 
                      * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE                      
C0EC  32              COMVEC    FCB  50            ;50 BASIC COMMANDS 
C0ED  C21B                      FDB  LAA66         ;POINTS TO RESERVED WORDS 
C0EF  C32A                      FDB  LAB67         ;POINTS TO JUMP TABLE FOR COMMANDS 
C0F1  1D                        FCB  29            ;29 BASIC SECONDARY COMMANDS 
C0F2  C2BD                      FDB  LAB1A         ;POINTS TO SECONDARY FUNCTION RESERVED WORDS 
C0F4  C1CC                      FDB  LAA29         ;POINTS TO SECONDARY FUNCTION JUMP TABLE 
C0F6  0000                      FDB  0             ;NO MORE TABLES (RES WORDS=0) 
C0F8  0000                      FDB  0             ;NO MORE TABLES 
C0FA  0000                      FDB  0             ;NO MORE TABLES 
C0FC  0000                      FDB  0             ;NO MORE TABLES 
C0FE  0000                      FDB  0             ;NO MORE TABLES 
C100  0000                      FDB  0             ;NO MORE TABLES (SECONDARY FNS =0) 
                                                     
                      * COPYRIGHT MESSAGES                      
C102  3638303920455854454E444544204241534943 LA147     FCC  "6809 EXTENDED BASIC"
C115  0D                        FCB  CR              
C116  2843292031393832204259204D4943524F534F4654           FCC  "(C) 1982 BY MICROSOFT"
                      
C12B  0D0D            LA156     FCB  CR,CR           
C12D  00              LA165     FCB  $00             
                                                     
                                                     
C12E  3416            LA35F     PSHS X,B,A         ;SAVE REGISTERS 
C130  9E76                      LDX  LPTCFW        ;TAB FIELD WIDTH AND TAB ZONE 
C132  DC78                      LDD  LPTWID        ;PRINTER WIDTH AND POSITION 
C134  9F6A            LA37C     STX  DEVCFW        ;SAVE TAB FIELD WIDTH AND ZONE 
C136  D76C                      STB  DEVPOS        ;SAVE PRINT POSITION 
C138  976D                      STA  DEVWID        ;SAVE PRINT WIDTH 
C13A  3596                      PULS A,B,X,PC      ;RESTORE REGISTERS 
                                                     
                      * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC                      
                      * EXIT WITH BREAK KEY: CARRY = 1                      
                      * EXIT WITH ENTER KEY: CARRY = 0                      
C13C                  LA38D                          
C13C  0F73            LA390     CLR  IKEYIM        ;RESET BREAK CHECK KEY TEMP KEY STORAGE 
C13E  8E00F4                    LDX  #LINBUF+1     ;INPUT LINE BUFFER 
C141  C601                      LDB  #1            ;ACCB CHAR COUNTER: SET TO 1 TO ALLOW A 
                      *         BACKSPACE AS FIRST CHARACTER  
C143  BDC003          LA39A     JSR  LA171         ;GO GET A CHARACTER FROM CONSOLE IN 
C146  8108                      CMPA #BS           ;BACKSPACE 
C148  2607                      BNE  LA3B4         ;NO 
C14A  5A                        DECB               ;YES - DECREMENT CHAR COUNTER 
C14B  27EF                      BEQ  LA390         ;BRANCH IF BACK AT START OF LINE AGAIN 
C14D  301F                      LEAX -1,X          ;DECREMENT BUFFER POINTER 
C14F  2034                      BRA  LA3E8         ;ECHO CHAR TO SCREEN 
C151  8115            LA3B4     CMPA #$15          ;SHIFT RIGHT ARROW? 
C153  260A                      BNE  LA3C2         ;NO 
                      * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE                      
C155  5A              LA3B8     DECB               ;DEC CHAR CTR 
C156  27E4                      BEQ  LA390         ;GO BACK TO START IF CHAR CTR = 0 
C158  8608                      LDA  #BS           ;BACKSPACE? 
C15A  BDC017                    JSR  PUTCHR        ;SEND TO CONSOLE OUT (SCREEN) 
C15D  20F6                      BRA  LA3B8         ;KEEP GOING 
C15F  8103            LA3C2     CMPA #3            ;BREAK KEY? 
C161  1A01                      ORCC #1            ;SET CARRY FLAG 
C163  2705                      BEQ  LA3CD         ;BRANCH IF BREAK KEY DOWN 
C165  810D            LA3C8     CMPA #CR           ;ENTER KEY? 
C167  260D                      BNE  LA3D9         ;NO 
C169  4F              LA3CC     CLRA               ;CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY 
C16A  3401            LA3CD     PSHS CC            ;SAVE CARRY FLAG 
C16C  BDD0A8                    JSR  LB958         ;SEND CR TO SCREEN 
C16F  6F84                      CLR  ,X            ;MAKE LAST BYTE IN INPUT BUFFER = 0 
C171  8E00F3                    LDX  #LINBUF       ;RESET INPUT BUFFER POINTER 
C174  3581                      PULS CC,PC         ;RESTORE CARRY FLAG 
                                                     
                      * INSERT A CHARACTER INTO THE;BASIC LINE INPUT BUFFER                      
C176  8120            LA3D9     CMPA #$20          ;IS IT CONTROL CHAR? 
C178  25C9                      BLO  LA39A         ;BRANCH IF CONTROL CHARACTER 
C17A  817B                      CMPA #'z+1         ;* 
C17C  24C5                      BCC  LA39A         ;* IGNORE IF > LOWER CASE Z 
C17E  C1FA                      CMPB #LBUFMX       ;HAVE 250 OR MORE CHARACTERS BEEN ENTERED? 
C180  24C1                      BCC  LA39A         ;YES, IGNORE ANY MORE 
C182  A780                      STA  ,X+           ;PUT IT IN INPUT BUFFER 
C184  5C                        INCB               ;INCREMENT CHARACTER COUNTER 
C185  BDC017          LA3E8     JSR  PUTCHR        ;ECHO IT TO SCREEN 
C188  20B9                      BRA  LA39A         ;GO SET SOME MORE 
                                                     
                                                     
                      * EXEC                         
C18A  2705            EXEC      BEQ  LA545         ;BRANCH IF NO ARGUMENT 
C18C  BDCEC4                    JSR  LB73D         ;EVALUATE ARGUMENT - ARGUMENT RETURNED IN X 
C18F  9F7A                      STX  EXECJP        ;STORE X TO EXEC JUMP ADDRESS 
C191  6E9F007A        LA545     JMP  [EXECJP]      ;GO DO IT 
                                                     
                      * BREAK CHECK                      
C195  7EC5A3          LA549     JMP  LADEB         ;GO DO BREAK KEY CHECK 
                                                     
                      * INKEY$                       
C198  9673            INKEY     LDA  IKEYIM        ;WAS A KEY DOWN IN THE BREAK CHECK? 
C19A  2603                      BNE  LA56B         ;YES 
C19C  BDC008                    JSR  KEYIN         ;GO GET A KEY 
C19F  0F73            LA56B     CLR  IKEYIM        ;CLEAR INKEY RAM IMAGE 
C1A1  9753                      STA  FPA0+3        ;STORE THE KEY IN FPA0 
C1A3  10260C6F                  LBNE LB68F         ;CONVERT FPA0+3 TO A STRING 
C1A7  9756                      STA  STRDES        ;SET LENGTH OF STRING = 0 IF NO KEY DOWN 
C1A9  7ECE22                    JMP  LB69B         ;PUT A NULL STRING ONTO THE STRING STACK 
                                                     
                      * MOVE ACCB BYTES FROM (X) TO;(U)                      
C1AC  A680            LA59A     LDA  ,X+           ;GET BYTE FROM X 
C1AE  A7C0                      STA  ,U+           ;STORE IT AT U 
C1B0  5A                        DECB               ;MOVED ALL BYTES? 
C1B1  26F9                      BNE  LA59A         ;NO 
C1B3  39              LA5A1     RTS                  
                                                     
C1B4  39              LA5C4     RTS                  
                                                     
                      ** THIS ROUTINE WILL SCAN OFF;THE FILE NAME FROM A BASIC LINE                      
                      ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS                      
                      ** FOLLOWING THE END OF THE NAME                      
C1B5  9D82            LA5C7     JSR  GETCCH        ;GET CURRENT INPUT CHAR FROM BASIC LINE 
C1B7  27FB            LA5C9     BEQ  LA5C4         ;RETURN IF END OF LINE 
C1B9  7ECA03                    JMP  LB277         ;SYNTAX ERROR IF ANY MORE CHARACTERS 
                      * IRQ SERVICE                      
C1BC                  BIRQSV                         
C1BC  3B              LA9C5     RTI                   ;RETURN FROM INTERRUPT  
                                                     
                      * SET CARRY IF NUMERIC - RETURN WITH                      
                      * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END                      
                      * OF BASIC LINE OR SUB LINE                      
C1BD  813A            BROMHK    CMPA #'9+1         ;IS THIS CHARACTER >=(ASCII 9)+1? 
C1BF  240A                      BHS  LAA28         ;BRANCH IF > 9; Z SET IF = COLON 
C1C1  8120                      CMPA #SPACE        ;SPACE? 
C1C3  2602                      BNE  LAA24         ;NO - SET CARRY IF NUMERIC 
C1C5  0E7C                      JMP  GETNCH        ;IF SPACE, GET NECT CHAR (IGNORE SPACES) 
C1C7  8030            LAA24     SUBA #'0           ;* SET CARRY IF 
C1C9  80D0                      SUBA #-'0          ;* CHARACTER > ASCII 0 
C1CB  39              LAA28     RTS                  
                                                     
                      * DISPATCH TABLE FOR SECONDARY FUNCTIONS                      
                      * TOKENS ARE PRECEEDED BY $FF                      
                      * FIRST SET ALWAYS HAS ONE PARAMETER                      
C1CC                  FUNC_TAB                       
C1CC  D3C6            LAA29     FDB  SGN           ;SGN 
C1CE  D43A                      FDB  INT           ;INT 
C1D0  D3DF                      FDB  ABS           ;ABS 
C1D2  00AD                      FDB  USRJMP        ;USR 
0083                  TOK_USR   EQU  (*-FUNC_TAB)/2+$7F  
FF83                  TOK_FF_USR EQU  (*-FUNC_TAB)/2+$FF7F  
C1D4  D66B                      FDB  RND           ;RND 
C1D6  D6C0                      FDB  SIN           ;SIN 
C1D8  CED7                      FDB  PEEK          ;PEEK 
C1DA  CE08                      FDB  LEN           ;LEN 
C1DC  CC84                      FDB  STR           ;STR$ 
C1DE  CE9D                      FDB  VAL           ;VAL 
C1E0  CE27                      FDB  ASC           ;ASC 
C1E2  CE13                      FDB  CHR           ;CHR$ 
C1E4  D770                      FDB  ATN           ;ATN 
C1E6  D738                      FDB  COS           ;COS 
C1E8  D741                      FDB  TAN           ;TAN 
C1EA  D8B2                      FDB  EXP           ;EXP 
C1EC  D8E4                      FDB  FIX           ;FIX 
C1EE  D806                      FDB  LOG           ;LOG 
C1F0  DA6C                      FDB  POS           ;POS 
C1F2  D840                      FDB  SQR           ;SQR 
C1F4  DF3E                      FDB  HEXDOL        ;HEX$ 
                      * LEFT, RIGHT AND MID ARE TREATED SEPARATELY                      
C1F6  CE32                      FDB  LEFT          ;LEFT$ 
0095                  TOK_LEFT  EQU  (*-FUNC_TAB)/2+$7F  
C1F8  CE4F                      FDB  RIGHT         ;RIGHT$ 
C1FA  CE56                      FDB  MID           ;MID$ 
0097                  TOK_MID   EQU  (*-FUNC_TAB)/2+$7F  
                      * REMAINING FUNCTIONS                      
C1FC  C198                      FDB  INKEY         ;INKEY$ 
0098                  TOK_INKEY EQU  (*-FUNC_TAB)/2+$7F  
C1FE  CC75                      FDB  MEM           ;MEM 
C200  DA74                      FDB  VARPT         ;VARPTR 
C202  DB34                      FDB  INSTR         ;INSTR 
C204  DB04                      FDB  STRING        ;STRING$ 
001D                  NUM_SEC_FNS EQU  (*-FUNC_TAB)/2    
                                                     
                      * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC                      
                      * AND LOGICAL OPERATORS - THE;NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS                      
                      * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE                      
                      * EXPRESSION EVALUATION ROUTINE. THEY ARE:                      
                      * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A                      
                      * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.                      
                      * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES                      
                      *                              
C206  79              LAA51     FCB  $79             
C207  D111                      FDB  LB9C5         ;+ 
C209  79                        FCB  $79             
C20A  D108                      FDB  LB9BC         ;- 
C20C  7B                        FCB  $7B             
C20D  D218                      FDB  LBACC         ;* 
C20F  7B                        FCB  $7B             
C210  D2DD                      FDB  LBB91         ;/ 
C212  7F                        FCB  $7F             
C213  D849                      FDB  L8489         ;EXPONENTIATION 
C215  50                        FCB  $50             
C216  CA5C                      FDB  LB2D5         ;AND 
C218  46                        FCB  $46             
C219  CA5B                      FDB  LB2D4         ;OR 
                                                     
                      * THIS IS THE RESERVED WORD TABLE                      
                      * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS                      
C21B  464F            LAA66     FCC  "FO"          ;80 
C21D  D2                        FCB  $80+'R'         
C21E  47                        FCC  "G"           ;81 
C21F  CF                        FCB  $80+'O'         
0081                  TOK_GO    EQU  $81             
C220  5245                      FCC  "RE"          ;82 
C222  CD                        FCB  $80+'M'         
                      ;EXIT TO MONITOR WITH BYE (SUB'S LITTLE USED ' ' ' INSTEAD OF REM FOR REMARKS
                       IF MON09   ; IF USING WITH MON09
C223  4259                      FCC  "BY"
C225  C5                        FCB  'E'+$80       ;83
                       ELSE
                                FCB  ''+$80        ;83
                       ENDIF
C226  454C53                    FCC  "ELS"         ;84 
C229  C5                        FCB  $80+'E'         
C22A  49                        FCC  "I"           ;85 
C22B  C6                        FCB  $80+'F'         
C22C  444154                    FCC  "DAT"         ;86 
C22F  C1                        FCB  $80+'A'         
C230  5052494E                  FCC  "PRIN"        ;87 
C234  D4                        FCB  $80+'T'         
C235  4F                        FCC  "O"           ;88 
C236  CE                        FCB  $80+'N'         
C237  494E5055                  FCC  "INPU"        ;89 
C23B  D4                        FCB  $80+'T'         
C23C  454E                      FCC  "EN"          ;8A 
C23E  C4                        FCB  $80+'D'         
C23F  4E4558                    FCC  "NEX"         ;8B 
C242  D4                        FCB  $80+'T'         
C243  4449                      FCC  "DI"          ;8C 
C245  CD                        FCB  $80+'M'         
C246  524541                    FCC  "REA"         ;8D 
C249  C4                        FCB  $80+'D'         
C24A  5255                      FCC  "RU"          ;8E 
C24C  CE                        FCB  $80+'N'         
C24D  524553544F52              FCC  "RESTOR"      ;8F 
C253  C5                        FCB  $80+'E'         
C254  5245545552                FCC  "RETUR"       ;90 
C259  CE                        FCB  $80+'N'         
C25A  53544F                    FCC  "STO"         ;91 
C25D  D0                        FCB  $80+'P'         
C25E  504F4B                    FCC  "POK"         ;92 
C261  C5                        FCB  $80+'E'         
C262  434F4E                    FCC  "CON"         ;93 
C265  D4                        FCB  $80+'T'         
C266  4C4953                    FCC  "LIS"         ;94 
C269  D4                        FCB  $80+'T'         
C26A  434C4541                  FCC  "CLEA"        ;95 
C26E  D2                        FCB  $80+'R'         
C26F  4E45                      FCC  "NE"          ;96 
C271  D7                        FCB  $80+'W'         
C272  455845                    FCC  "EXE"         ;97 
C275  C3                        FCB  $80+'C'         
C276  54524F                    FCC  "TRO"         ;98 
C279  CE                        FCB  $80+'N'         
C27A  54524F46                  FCC  "TROF"        ;99 
C27E  C6                        FCB  $80+'F'         
C27F  4445                      FCC  "DE"          ;9A 
C281  CC                        FCB  $80+'L'         
C282  4445                      FCC  "DE"          ;9B 
C284  C6                        FCB  $80+'F'         
C285  4C494E                    FCC  "LIN"         ;9C 
C288  C5                        FCB  $80+'E'         
C289  52454E55                  FCC  "RENU"        ;9D 
C28D  CD                        FCB  $80+'M'         
C28E  454449                    FCC  "EDI"         ;9E 
C291  D4                        FCB  $80+'T'         
                      * END OF EXECUTABLE COMMANDS.;THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS                      
C292  544142                    FCC  "TAB"         ;9F 
C295  A8                        FCB  $80+'('         
009F                  TOK_TAB   EQU  $9F             
C296  54                        FCC  "T"           ;A0 
C297  CF                        FCB  $80+'O'         
00A0                  TOK_TO    EQU  $A0             
C298  5355                      FCC  "SU"          ;A1 
C29A  C2                        FCB  $80+'B'         
00A1                  TOK_SUB   EQU  $A1             
C29B  544845                    FCC  "THE"         ;A2 
C29E  CE                        FCB  $80+'N'         
00A2                  TOK_THEN  EQU  $A2             
C29F  4E4F                      FCC  "NO"          ;A3 
C2A1  D4                        FCB  $80+'T'         
00A3                  TOK_NOT   EQU  $A3             
C2A2  535445                    FCC  "STE"         ;A4 
C2A5  D0                        FCB  $80+'P'         
00A4                  TOK_STEP  EQU  $A4             
C2A6  4F46                      FCC  "OF"          ;A5 
C2A8  C6                        FCB  $80+'F'         
C2A9  AB                        FCB  '++$80        ;A6 
00A6                  TOK_PLUS  EQU  $A6             
C2AA  AD                        FCB  '-+$80        ;A7 
00A7                  TOK_MINUS EQU  $A7             
C2AB  AA                        FCB  '*+$80        ;A8 
C2AC  AF                        FCB  '/+$80        ;A9 
C2AD  DE                        FCB  '^+$80        ;AA 
C2AE  414E                      FCC  "AN"          ;AB 
C2B0  C4                        FCB  $80+'D'         
C2B1  4F                        FCC  "O"           ;AC 
C2B2  D2                        FCB  $80+'R'         
C2B3  BE                        FCB  '>+$80        ;AD 
00AD                  TOK_GREATER EQU  $AD             
C2B4  BD                        FCB  '=+$80        ;AE 
00AE                  TOK_EQUALS EQU  $AE             
C2B5  BC                        FCB  '<+$80        ;AF 
C2B6  46                        FCC  "F"           ;B0 
C2B7  CE                        FCB  $80+'N'         
00B0                  TOK_FN    EQU  $B0             
C2B8  5553494E                  FCC  "USIN"        ;B1 
C2BC  C7                        FCB  $80+'G'         
00B1                  TOK_USING EQU  $B1             
                      *                              
                                                     
                      * FIRST SET ALWAYS HAS ONE PARAMETER                      
C2BD  5347            LAB1A     FCC  "SG"          ;80 
C2BF  CE                        FCB  $80+'N'         
C2C0  494E                      FCC  "IN"          ;81 
C2C2  D4                        FCB  $80+'T'         
C2C3  4142                      FCC  "AB"          ;82 
C2C5  D3                        FCB  $80+'S'         
C2C6  5553                      FCC  "US"          ;83 
C2C8  D2                        FCB  $80+'R'         
C2C9  524E                      FCC  "RN"          ;84 
C2CB  C4                        FCB  $80+'D'         
C2CC  5349                      FCC  "SI"          ;85 
C2CE  CE                        FCB  $80+'N'         
C2CF  504545                    FCC  "PEE"         ;86 
C2D2  CB                        FCB  $80+'K'         
C2D3  4C45                      FCC  "LE"          ;87 
C2D5  CE                        FCB  $80+'N'         
C2D6  535452                    FCC  "STR"         ;88 
C2D9  A4                        FCB  $80+'$'         
C2DA  5641                      FCC  "VA"          ;89 
C2DC  CC                        FCB  $80+'L'         
C2DD  4153                      FCC  "AS"          ;8A 
C2DF  C3                        FCB  $80+'C'         
C2E0  434852                    FCC  "CHR"         ;8B 
C2E3  A4                        FCB  $80+'$'         
C2E4  4154                      FCC  "AT"          ;8C 
C2E6  CE                        FCB  $80+'N'         
C2E7  434F                      FCC  "CO"          ;8D 
C2E9  D3                        FCB  $80+'S'         
C2EA  5441                      FCC  "TA"          ;8E 
C2EC  CE                        FCB  $80+'N'         
C2ED  4558                      FCC  "EX"          ;8F 
C2EF  D0                        FCB  $80+'P'         
C2F0  4649                      FCC  "FI"          ;90 
C2F2  D8                        FCB  $80+'X'         
C2F3  4C4F                      FCC  "LO"          ;91 
C2F5  C7                        FCB  $80+'G'         
C2F6  504F                      FCC  "PO"          ;92 
C2F8  D3                        FCB  $80+'S'         
C2F9  5351                      FCC  "SQ"          ;93 
C2FB  D2                        FCB  $80+'R'         
C2FC  484558                    FCC  "HEX"         ;94 
C2FF  A4                        FCB  $80+'$'         
                      * LEFT, RIGHT AND MID ARE TREATED SEPARATELY                      
C300  4C454654                  FCC  "LEFT"        ;95 
C304  A4                        FCB  $80+'$'         
C305  5249474854                FCC  "RIGHT"       ;96 
C30A  A4                        FCB  $80+'$'         
C30B  4D4944                    FCC  "MID"         ;97 
C30E  A4                        FCB  $80+'$'         
                      * REMAINING FUNCTIONS                      
C30F  494E4B4559                FCC  "INKEY"       ;98 
C314  A4                        FCB  $80+'$'         
C315  4D45                      FCC  "ME"          ;99 
C317  CD                        FCB  $80+'M'         
C318  5641525054                FCC  "VARPT"       ;9A 
C31D  D2                        FCB  $80+'R'         
C31E  494E5354                  FCC  "INST"        ;9B 
C322  D2                        FCB  $80+'R'         
C323  535452494E47              FCC  "STRING"      ;9C 
C329  A4                        FCB  $80+'$'         
                                                     
                      *                              
                      * DISPATCH TABLE FOR COMMANDS TOKEN #
C32A                  CMD_TAB                        
C32A  C4E8            LAB67     FDB  FOR           ;80   
C32C  C636                      FDB  GO            ;81   
C32E  C693                      FDB  REM           ;82   
0082                  TOK_REM   EQU  (*-CMD_TAB)/2+$7F  
                       IF MON09
0082                  TOK_SNGL_Q EQU TOK_REM
C330  C5BA                      FDB  BYE
                       ELSE
                                FDB  REM           ;83 (')
                      TOK_SNGL_Q EQU  (*-CMD_TAB)/2+$7F
                       ENDIF
C332  C693                      FDB  REM           ;84 (ELSE) 
0084                  TOK_ELSE  EQU  (*-CMD_TAB)/2+$7F  
C334  C6C4                      FDB  IF            ;85   
0085                  TOK_IF    EQU  (*-CMD_TAB)/2+$7F  
C336  C690                      FDB  DATA          ;86   
0086                  TOK_DATA  EQU  (*-CMD_TAB)/2+$7F  
C338  D06D                      FDB  PRINT         ;87   
0087                  TOK_PRINT EQU  (*-CMD_TAB)/2+$7F  
C33A  C6F2                      FDB  ON            ;88   
C33C  C79F                      FDB  INPUT         ;89   
0089                  TOK_INPUT EQU  (*-CMD_TAB)/2+$7F  
C33E  C5BD                      FDB  END           ;8A   
C340  C884                      FDB  NEXT          ;8B   
C342  CAD5                      FDB  DIM           ;8C   
C344  C7D9                      FDB  READ          ;8D   
C346  C62B                      FDB  RUN           ;8E   
C348  C59C                      FDB  RESTOR        ;8F 
C34A  C670                      FDB  RETURN        ;90   
C34C  C5C1                      FDB  STOP          ;91   
C34E  CEDE                      FDB  POKE          ;92   
C350  C5E6                      FDB  CONT          ;93 
C352  CEE5                      FDB  LIST          ;94   
C354  C5F7                      FDB  CLEAR         ;95   
C356  C4B8                      FDB  NEW           ;96   
C358  C18A                      FDB  EXEC          ;97 
C35A  DA67                      FDB  TRON          ;98 
C35C  DA68                      FDB  TROFF         ;99 
C35E  DCE3                      FDB  DEL           ;9A 
C360  DC27                      FDB  DEF           ;9B 
C362  E3D1                      FDB  LINE          ;9C 
C364  DD6D                      FDB  RENUM         ;9D 
C366  D8F3                      FDB  EDIT          ;9E 
009E                  TOK_HIGH_EXEC EQU  (*-CMD_TAB)/2+$7F  
                                                     
                      * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY                      
C368  4E46            LABAF     FCC  "NF"          ;0 NEXT WITHOUT FOR   
C36A  534E                      FCC  "SN"          ;1 SYNTAX ERROR   
C36C  5247                      FCC  "RG"          ;2 RETURN WITHOUT GOSUB   
C36E  4F44                      FCC  "OD"          ;3 OUT OF DATA   
C370  4643                      FCC  "FC"          ;4 ILLEGAL FUNCTION CALL   
C372  4F56                      FCC  "OV"          ;5 OVERFLOW   
C374  4F4D                      FCC  "OM"          ;6 OUT OF MEMORY   
C376  554C                      FCC  "UL"          ;7 UNDEFINED LINE NUMBER   
C378  4253                      FCC  "BS"          ;8 BAD SUBSCRIPT   
C37A  4444                      FCC  "DD"          ;9 REDIMENSIONED ARRAY   
C37C  2F30                      FCC  "/0"          ;10 DIVISION BY ZERO 
C37E  4944                      FCC  "ID"          ;11 ILLEGAL DIRECT STATEMENT 
C380  544D                      FCC  "TM"          ;12 TYPE MISMATCH 
C382  4F53                      FCC  "OS"          ;13 OUT OF STRING SPACE 
C384  4C53                      FCC  "LS"          ;14 STRING TOO LONG 
C386  5354                      FCC  "ST"          ;15 STRING FORMULA TOO COMPLEX 
C388  434E                      FCC  "CN"          ;16 CAN'T CONTINUE 
C38A  4644                      FCC  "FD"          ;17 BAD FILE DATA 
C38C  414F                      FCC  "AO"          ;18 FILE ALREADY OPEN 
C38E  444E                      FCC  "DN"          ;19 DEVICE NUMBER ERROR 
C390  494F                      FCC  "IO"          ;20 I/O ERROR 
C392  464D                      FCC  "FM"          ;21 BAD FILE MODE 
C394  4E4F                      FCC  "NO"          ;22 FILE NOT OPEN 
C396  4945                      FCC  "IE"          ;23 INPUT PAST END OF FILE 
C398  4453                      FCC  "DS"          ;24 DIRECT STATEMENT IN FILE 
                      * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC                      
C39A  5546            L890B     FCC  "UF"          ;25 UNDEFINED FUNCTION (FN) CALL 
C39C  4E45            L890D     FCC  "NE"          ;26 FILE NOT FOUND 
                                                     
C39E  204552524F52    LABE1     FCC  " ERROR"        
C3A4  00                        FCB  $00             
C3A5  20494E20        LABE8     FCC  " IN "          
C3A9  00                        FCB  $00             
C3AA  0D              LABED     FCB  CR              
C3AB  4F4B            LABEE     FCC  "OK"            
C3AD  0D00                      FCB  CR,$00          
C3AF  0D              LABF2     FCB  CR              
C3B0  425245414B                FCC  "BREAK"         
C3B5  00                        FCB  $00             
                                                     
                      * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
                      * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
                      * SOUGHT IS STORED IN VARDES.;EACH BLOCK OF FOR/NEXT DATA IS 18                      
                      * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES                      
                      * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA                      
                      * IS CONSIDERED 'GOSUB/RETURN'
C3B6  3064            LABF9     LEAX 4,S           ;POINT X TO 3RD ADDRESS ON STACK - IGNORE THE 
                      *         FIRST TWO RETURN ADDRESSES ON THE STACK  
C3B8  C612            LABFB     LDB  #18           ;18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
C3BA  9F0F                      STX  TEMPTR        ;SAVE POINTER 
C3BC  A684                      LDA  ,X            ;GET 1ST BYTE 
C3BE  8080                      SUBA #$80          ;* CHECK FOR TYPE OF STACK JUMP FOUND 
C3C0  2615                      BNE  LAC1A         ;* BRANCH IF NOT 'FOR/NEXT'
C3C2  AE01                      LDX  1,X           ;= GET INDEX VARIABLE DESCRIPTOR 
C3C4  9F11                      STX  TMPTR1        ;= POINTER AND SAVE IT IN TMPTR1 
C3C6  9E3B                      LDX  VARDES        ;GET INDEX VARIABLE BEING SEARCHED FOR 
C3C8  2709                      BEQ  LAC16         ;BRANCH IF DEFAULT INDEX VARIABLE - USE THE 
                      *                            ;FIRST 'FOR/NEXT' DATA FOUND ON STACK
                      *                            ;IF NO INDEX VARIABLE AFTER 'NEXT'
C3CA  9C11                      CMPX TMPTR1        ;DOES THE STACK INDEX MATCH THE ONE 
                      *                            ;BEING SEARCHED FOR? 
C3CC  2709                      BEQ  LAC1A         ;YES 
C3CE  9E0F                      LDX  TEMPTR        ;* RESTORE INITIAL POINTER, ADD 
C3D0  3A                        ABX                ;* 18 TO IT AND LOOK FOR 
C3D1  20E5                      BRA  LABFB         ;* NEXT BLOCK OF DATA 
C3D3  9E11            LAC16     LDX  TMPTR1        ;= GET 1ST INDEX VARIABLE FOUND AND 
C3D5  9F3B                      STX  VARDES        ;= SAVE AS 'NEXT' INDEX
C3D7  9E0F            LAC1A     LDX  TEMPTR        ;POINT X TO START OF 'FOR/NEXT' DATA
C3D9  4D                        TSTA               ;SET ZERO FLAG IF 'FOR/NEXT' DATA
C3DA  39                        RTS                  
                      * CHECK FOR MEMORY SPACE FOR NEW TOP OF                      
                      * ARRAYS AND MOVE ARRAYS TO NEW LOCATION                      
C3DB  8D17            LAC1E     BSR  LAC37         ;ACCD = NEW BOTTOM OF FREE RAM - IS THERE 
                      *                            ;ROOM FOR THE STACK? 
                      * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND                      
                      * SAVE FINAL VALUE OF U IN V45                      
C3DD  DE41            LAC20     LDU  V41           ;POINT U TO DESTINATION ADDRESS (V41) 
C3DF  3341                      LEAU 1,U           ;ADD ONE TO U - COMPENSATE FOR FIRST PSHU 
C3E1  9E43                      LDX  V43           ;POINT X TO SOURCE ADDRESS (V43) 
C3E3  3001                      LEAX 1,X           ;ADD ONE - COMPENSATE FOR FIRST LDA ,X 
C3E5  A682            LAC28     LDA  ,-X           ;GRAB A BYTE FROM SOURCE 
C3E7  3602                      PSHU A             ;MOVE IT TO DESTINATION 
C3E9  9C47                      CMPX V47           ;DONE? 
C3EB  26F8                      BNE  LAC28         ;NO - KEEP MOVING BYTES 
C3ED  DF45                      STU  V45           ;SAVE FINAL DESTINATION ADDRESS 
C3EF  39              LAC32     RTS                  
                      * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB                      
                      * BYTES IN FREE RAM - OM ERROR IF NOT                      
C3F0  4F              LAC33     CLRA               ;* ACCD CONTAINS NUMBER OF EXTRA 
C3F1  58                        ASLB               ;* BYTES TO PUT ON STACK 
C3F2  D31F                      ADDD ARYEND        ;END OF PROGRAM AND VARIABLES 
C3F4  C3003A          LAC37     ADDD #STKBUF       ;ADD STACK BUFFER - ROOM FOR STACK? 
C3F7  2508                      BCS  LAC44         ;BRANCH IF GREATER THAN $FFFF 
C3F9  10DF17                    STS  BOTSTK        ;CURRENT NEW BOTTOM OF STACK STACK POINTER 
C3FC  109317                    CMPD BOTSTK        ;ARE WE GOING TO BE BELOW STACK? 
C3FF  25EE                      BCS  LAC32         ;YES - NO ERROR 
C401  C60C            LAC44     LDB  #6*2          ;OUT OF MEMORY ERROR 
                                                     
                      * ERROR SERVICING ROUTINE                      
C403  BDC4D4          LAC46     JSR  LAD33         ;RESET STACK, STRING STACK, CONTINUE POINTER 
C406  BDD0AC                    JSR  LB95C         ;SEND A CR TO SCREEN 
C409  BDD0FB                    JSR  LB9AF         ;SEND A '?' TO SCREEN
C40C  8EC368                    LDX  #LABAF        ;POINT TO ERROR TABLE 
C40F  3A              LAC60     ABX                ;ADD MESSAGE NUMBER OFFSET 
C410  8D31                      BSR  LACA0         ;* GET TWO CHARACTERS FROM X AND 
C412  8D2F                      BSR  LACA0         ;* SEND TO CONSOLE OUT (SCREEN) 
C414  8EC39D                    LDX  #LABE1-1      ;POINT TO "ERROR" MESSAGE 
C417  BDD0E8          LAC68     JSR  LB99C         ;PRINT MESSAGE POINTED TO BY X 
C41A  9668                      LDA  CURLIN        ;GET CURRENT LINE NUMBER (CURL IN) 
C41C  4C                        INCA               ;TEST FOR DIRECT MODE 
C41D  2703                      BEQ  LAC73         ;BRANCH IF DIRECT MODE 
C41F  BDD511                    JSR  LBDC5         ;PRINT 'IN ****'
                                                     
                      * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE                      
C422  BDD0AC          LAC73     JSR  LB95C         ;MOVE CURSOR TO START OF LINE 
C425  8EC3AA                    LDX  #LABED        ;POINT X TO 'OK', CR MESSAGE
C428  BDD0E8                    JSR  LB99C         ;PRINT 'OK', CR
C42B  BDC13C          LAC7C     JSR  LA390         ;GO GET AN INPUT LINE 
C42E  CEFFFF                    LDU  #$FFFF        ;THE LINE NUMBER FOR DIRECT MODE IS $FFFF 
C431  DF68                      STU  CURLIN        ;SAVE IT IN CURLIN 
C433  25F6                      BCS  LAC7C         ;BRANCH IF LINE INPUT TERMINATED BY BREAK 
C435  9F83                      STX  CHARAD        ;SAVE (X) AS CURRENT INPUT POINTER - THIS WILL 
                      *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
                      *         LINE JUST ENTERED WILL BE INTERPRETED  
C437  9D7C                      JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
C439  27F0                      BEQ  LAC7C         ;NO LINE INPUT - GET ANOTHER LINE 
C43B  250B                      BCS  LACA5         ;BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE 
                      *         THE  STATEMENT ENTERED, SO THIS STATEMENT  
                      *         WILL BE MERGED INTO;THE BASIC PROGRAM  
C43D  BDCF9A                    JSR  LB821         ;GO CRUNCH LINE 
C440  7EC571                    JMP  LADC0         ;GO EXECUTE THE STATEMENT (LIVE KEYBOARD) 
                      *                              
C443  A680            LACA0     LDA  ,X+           ;GET A CHARACTER 
C445  7ED0FD                    JMP  LB9B1         ;SEND TO CONSOLE OUT 
                      * TAKE A LINE FROM THE LINE INPUT BUFFER                      
                      * AND INSERT IT INTO THE BASIC PROGRAM                      
C448  BDC717          LACA5     JSR  LAF67         ;CONVERT LINE NUMBER TO BINARY 
C44B  9E2B            LACA8     LDX  BINVAL        ;GET CONVERTED LINE NUMBER 
C44D  9FF1                      STX  LINHDR        ;STORE IT IN LINE INPUT HEADER 
C44F  BDCF9A                    JSR  LB821         ;GO CRUNCH THE LINE 
C452  D703                      STB  TMPLOC        ;SAVE LINE LENGTH 
C454  8D4C                      BSR  LAD01         ;FIND OUT WHERE TO INSERT LINE 
C456  2512                      BCS  LACC8         ;BRANCH IF LINE NUMBER DOES NOT ALREADY EXIST 
C458  DC47                      LDD  V47           ;GET ABSOLUTE ADDRESS OF LINE NUMBER 
C45A  A384                      SUBD ,X            ;SUBTRACT ADDRESS OF NEXT LINE NUMBER 
C45C  D31B                      ADDD VARTAB        ;* ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE 
C45E  DD1B                      STD  VARTAB        ;* THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM 
C460  EE84                      LDU  ,X            ;POINT U TO ADDRESS OF NEXT LINE NUMBER 
                      * DELETE OLD LINE FROM BASIC PROGRAM                      
C462  3702            LACC0     PULU A             ;GET A BYTE FROM WHAT'S LEFT OF PROGRAM
C464  A780                      STA  ,X+           ;MOVE IT DOWN 
C466  9C1B                      CMPX VARTAB        ;COMPARE TO END OF BASIC PROGRAM 
C468  26F8                      BNE  LACC0         ;BRANCH IF NOT AT END 
C46A  96F3            LACC8     LDA  LINBUF        ;* CHECK TO SEE IF THERE IS A LINE IN 
C46C  271C                      BEQ  LACE9         ;* THE BUFFER AND BRANCH IF NONE 
C46E  DC1B                      LDD  VARTAB        ;= SAVE CURRENT END OF 
C470  DD43                      STD  V43           ;= PROGRAM IN V43 
C472  DB03                      ADDB TMPLOC        ;* ADD LENGTH OF CRUNCHED LINE, 
C474  8900                      ADCA #0            ;* PROPOGATE CARRY AND SAVE NEW END 
C476  DD41                      STD  V41           ;* OF PROGRAM IN V41 
C478  BDC3DB                    JSR  LAC1E         ;= MAKE SURE THERE'S ENOUGH RAM FOR THIS
                      *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE  
C47B  CE00EF                    LDU  #LINHDR-2     ;POINT U TO LINE TO BE INSERTED 
C47E  3702            LACDD     PULU A             ;GET A BYTE FROM NEW LINE 
C480  A780                      STA  ,X+           ;INSERT IT IN PROGRAM 
C482  9C45                      CMPX V45           ;* COMPARE TO ADDRESS OF END OF INSERTED 
C484  26F8                      BNE  LACDD         ;* LINE AND BRANCH IF NOT DONE 
C486  9E41                      LDX  V41           ;= GET AND SAVE 
C488  9F1B                      STX  VARTAB        ;= END OF PROGRAM 
C48A  8D36            LACE9     BSR  LAD21         ;RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE 
C48C  8D02                      BSR  LACEF         ;ADJUST START OF NEXT LINE ADDRESSES 
C48E  209B                      BRA  LAC7C         ;REENTER BASIC'S INPUT LOOP
                      * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM                      
C490  9E19            LACEF     LDX  TXTTAB        ;POINT X TO START OF PROGRAM 
C492  EC84            LACF1     LDD  ,X            ;GET ADDRESS OF NEXT LINE 
C494  2721                      BEQ  LAD16         ;RETURN IF END OF PROGRAM 
C496  3304                      LEAU 4,X           ;POINT U TO START OF BASIC TEXT IN LINE 
C498  A6C0            LACF7     LDA  ,U+           ;* SKIP THROUGH THE LINE UNTIL A 
C49A  26FC                      BNE  LACF7         ;* ZERO (END OF LINE) IS FOUND 
C49C  EF84                      STU  ,X            ;SAVE THE NEW START OF NEXT LINE ADDRESS 
C49E  AE84                      LDX  ,X            ;POINT X TO START OF NEXT LINE 
C4A0  20F0                      BRA  LACF1         ;KEEP GOING 
                      *                              
                      * FIND A LINE NUMBER IN THE BASIC PROGRAM                      
                      * RETURN WITH CARRY SET IF NO;MATCH FOUND                      
C4A2  DC2B            LAD01     LDD  BINVAL        ;GET THE LINE NUMBER TO FIND 
C4A4  9E19                      LDX  TXTTAB        ;BEGINNING OF PROGRAM 
C4A6  EE84            LAD05     LDU  ,X            ;GET ADDRESS OF NEXT LINE NUMBER 
C4A8  2709                      BEQ  LAD12         ;BRANCH IF END OF PROG 
C4AA  10A302                    CMPD 2,X           ;IS IT A MATCH? 
C4AD  2306                      BLS  LAD14         ;CARRY SET IF LOWER; CARRY CLEAR IF MATCH 
C4AF  AE84                      LDX  ,X            ;X = ADDRESS OF NEXT LINE 
C4B1  20F3                      BRA  LAD05         ;KEEP LOOPING FOR LINE NUMBER 
C4B3  1A01            LAD12     ORCC #1            ;SET CARRY FLAG 
C4B5  9F47            LAD14     STX  V47           ;SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER 
                      *                            ;WHERE IT SHOULD HAVE BEEN 
C4B7  39              LAD16     RTS                  
                                                     
                      * NEW                          
C4B8  26FB            NEW       BNE  LAD14         ;BRANCH IF ARGUMENT GIVEN 
C4BA  9E19            LAD19     LDX  TXTTAB        ;GET START OF BASIC 
C4BC  6F80                      CLR  ,X+           ;* PUT 2 ZERO BYTES THERE - ERASE 
C4BE  6F80                      CLR  ,X+           ;* THE BASIC PROGRAM 
C4C0  9F1B                      STX  VARTAB        ;AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM 
C4C2  9E19            LAD21     LDX  TXTTAB        ;GET START OF BASIC 
C4C4  BDC66B                    JSR  LAEBB         ;PUT INPUT POINTER ONE BEFORE START OF BASIC 
                      * ERASE ALL VARIABLES                      
C4C7  9E27            LAD26     LDX  MEMSIZ        ;* RESET START OF STRING VARIABLES 
C4C9  9F23                      STX  STRTAB        ;* TO TOP OF STRING SPACE 
C4CB  BDC59C                    JSR  RESTOR        ;RESET 'DATA' POINTER TO START OF BASIC
C4CE  9E1B                      LDX  VARTAB        ;* GET START OF VARIABLES AND USE IT 
C4D0  9F1D                      STX  ARYTAB        ;* TO RESET START OF ARRAYS 
C4D2  9F1F                      STX  ARYEND        ;RESET END OF ARRAYS 
C4D4  8E00C9          LAD33     LDX  #STRSTK       ;* RESET STRING STACK POINTER TO 
C4D7  9F0B                      STX  TEMPPT        ;* BOTTOM OF STRING STACK 
C4D9  AEE4                      LDX  ,S            ;GET RETURN ADDRESS OFF STACK 
C4DB  10DE21                    LDS  FRETOP        ;RESTORE STACK POINTER 
C4DE  6FE2                      CLR  ,-S           ;PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF 
                      *                            ;FOR/NEXT DATA FROM THE STACK 
C4E0  0F2D                      CLR  OLDPTR        ;RESET 'CONT' ADDRESS SO YOU
C4E2  0F2E                      CLR  OLDPTR+1      ;'CAN'T CONTINUE'
C4E4  0F08                      CLR  ARYDIS        ;CLEAR THE ARRAY DISABLE FLAG 
C4E6  6E84                      JMP  ,X            ;RETURN TO CALLING ROUTINE - THIS IS NECESSARY 
                      *                            ;SINCE THE STACK WAS RESET 
                      *                              
                      * FOR                          
                      *                              
                      * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR                      
                      * EACH FOR-NEXT LOOP WHICH IS;BEING PROCESSED. THESE                      
                      * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);                      
                      *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;  
                      *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;  
                      * 9-13=FP VALUE OF 'TO' PARAMETER;
                      * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END                      
                      *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
C4E8  8680            FOR       LDA  #$80          ;* SAVE THE DISABLE ARRAY FLAG IN VO8 
C4EA  9708                      STA  ARYDIS        ;* DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY 
C4EC  BDC739                    JSR  LET           ;SET INDEX VARIABLE TO INITIAL VALUE 
C4EF  BDC3B6                    JSR  LABF9         ;SEARCH THE STACK FOR 'FOR/NEXT' DATA
C4F2  3262                      LEAS 2,S           ;PURGE RETURN ADDRESS OFF OF THE STACK 
C4F4  2604                      BNE  LAD59         ;BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED 
C4F6  9E0F                      LDX  TEMPTR        ;GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
C4F8  3285                      LEAS B,X           ;MOVE THE STACK POINTER TO THE BEGINNING OF THE 
                      * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
                      * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY                      
                      * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
                      * THIS POINT ON THE STACK                      
C4FA  C609            LAD59     LDB  #$09          ;* CHECK FOR ROOM FOR 18 BYTES 
C4FC  BDC3F0                    JSR  LAC33         ;* IN FREE RAM 
C4FF  BDC698                    JSR  LAEE8         ;GET ADDR OF END OF SUBLINE IN X 
C502  DC68                      LDD  CURLIN        ;GET CURRENT LINE NUMBER 
C504  3416                      PSHS X,B,A         ;SAVE LINE ADDR AND LINE NUMBER ON STACK 
C506  C6A0                      LDB  #TOK_TO       ;TOKEN FOR 'TO'
C508  BDC9FB                    JSR  LB26F         ;SYNTAX CHECK FOR 'TO'
C50B  BDC8CF                    JSR  LB143         ;'TM' ERROR IF INDEX VARIABLE SET TO STRING
C50E  BDC8CD                    JSR  LB141         ;EVALUATE EXPRESSION 
                      *                              
C511  D654                      LDB  FP0SGN        ;GET FPA0 MANTISSA SIGN 
C513  CA7F                      ORB  #$7F          ;FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA 
C515  D450                      ANDB FPA0          ;PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA 
C517  D750                      STB  FPA0          ;SAVE THE PACKED HIGH ORDER MANTISSA 
C519  108EC520                  LDY  #LAD7F        ;LOAD FOLLOWING ADDRESS INTO Y AS A RETURN 
C51D  7EC976                    JMP  LB1EA         ;ADDRESS - PUSH FPA0 ONTO THE STACK 
C520  8ED211          LAD7F     LDX  #LBAC5        ;POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE) 
C523  BDD360                    JSR  LBC14         ;MOVE (X) TO FPA0 
C526  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C528  81A4                      CMPA #TOK_STEP     ;STEP TOKEN 
C52A  2605                      BNE  LAD90         ;BRANCH IF NO 'STEP' VALUE
C52C  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C52E  BDC8CD                    JSR  LB141         ;EVALUATE NUMERIC EXPRESSION 
C531  BDD3B9          LAD90     JSR  LBC6D         ;CHECK STATUS OF FPA0 
C534  BDC972                    JSR  LB1E6         ;SAVE STATUS AND FPA0 ON THE STACK 
C537  DC3B                      LDD  VARDES        ;* GET DESCRIPTOR POINTER FOR THE 'STEP'
C539  3406                      PSHS B,A           ;* VARIABLE AND SAVE IT ON THE STACK 
C53B  8680                      LDA  #$80          ;= GET THE 'FOR' FLAG AND
C53D  3402                      PSHS A             ;= SAVE IT ON THE STACK 
                      *                              
                      * MAIN COMMAND INTERPRETATION;LOOP                      
C53F  1CAF            LAD9E     ANDCC #$AF         ;ENABLE IRQ,FIRQ 
C541  8D60                      BSR  LADEB         ;CHECK FOR KEYBOARD BREAK 
C543  9E83                      LDX  CHARAD        ;GET BASIC'S INPUT POINTER
C545  9F2F                      STX  TINPTR        ;SAVE IT 
C547  A680                      LDA  ,X+           ;GET CURRENT INPUT CHAR & MOVE POINTER 
C549  2707                      BEQ  LADB4         ;BRANCH IF END OF LINE 
C54B  813A                      CMPA #':           ;CHECK FOR LINE SEPARATOR 
C54D  2722                      BEQ  LADC0         ;BRANCH IF COLON 
C54F  7ECA03          LADB1     JMP  LB277         ;'SYNTAX ERROR'-IF NOT LINE SEPARATOR
C552  A681            LADB4     LDA  ,X++          ;GET MS BYTE OF ADDRESS OF NEXT BASIC LINE 
C554  9700                      STA  ENDFLG        ;SAVE IN STOP/END FLAG - CAUSE A STOP IF 
                      *                            ;NEXT LINE ADDRESS IS < $8000; CAUSE 
                      *                            ;AN END IF ADDRESS > $8000 
C556  2775                      BEQ  LAE15         ;BRANCH TO 'STOP' - END OF PROGRAM
C558  EC80                      LDD  ,X+           ;GET CURRENT LINE NUMBER 
C55A  DD68                      STD  CURLIN        ;SAVE IN CURLIN 
C55C  9F83                      STX  CHARAD        ;SAVE ADDRESS OF FIRST BYTE OF LINE 
                      * EXTENDED BASIC TRACE                      
C55E  968C                      LDA  TRCFLG        ;TEST THE TRACE FLAG 
C560  270F                      BEQ  LADC0         ;BRANCH IF TRACE OFF 
C562  865B                      LDA  #$5B          ;<LEFT HAND MARKER FOR TRON LINE NUMBER 
C564  BDC017                    JSR  PUTCHR        ;OUTPUT A CHARACTER 
C567  9668                      LDA  CURLIN        ;GET MS BYTE OF LINE NUMBER 
C569  BDD518                    JSR  LBDCC         ;CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN 
C56C  865D                      LDA  #$5D          ;> RIGHT HAND MARKER FOR TRON LINE NUMBER 
C56E  BDC017                    JSR  PUTCHR        ;OUTPUT A CHARACTER 
                      * END OF EXTENDED BASIC TRACE                      
C571  9D7C            LADC0     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C573  8D02                      BSR  LADC6         ;GO PROCESS COMMAND 
C575  20C8                      BRA  LAD9E         ;GO BACK TO MAIN LOOP 
C577  2729            LADC6     BEQ  LADEA         ;RETURN IF END OF LINE (RTS - was BEQ LAE40) 
C579  4D                        TSTA               ;CHECK FOR TOKEN - BIT 7 SET (NEGATIVE) 
C57A  102A01BB                  LBPL LET           ;BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
                      *                            ;IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
C57E  81FF                      CMPA #$FF          ;SECONDARY TOKEN 
C580  270F                      BEQ  SECTOK          
C582  819E                      CMPA #TOK_HIGH_EXEC   ;SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC 
C584  22C9                      BHI  LADB1         ;'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
C586  BEC0EF                    LDX  COMVEC+3      ;GET ADDRESS OF BASIC'S COMMAND TABLE
C589  48              LADD4     ASLA               ;X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7 
C58A  1F89                      TFR  A,B           ;SAVE COMMAND OFFSET IN ACCB 
C58C  3A                        ABX                ;NON X POINTS TO COMMAND JUMP ADDR 
C58D  9D7C                      JSR  GETNCH        ;GET AN INPUT CHAR 
                      *                              
                      * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
C58F  6E94                      JMP  [,X]          ;GO DO A COMMAND 
C591                  SECTOK                         
                      * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS                      
                      * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE                      
C591  9D7C                      JSR  GETNCH        ;GET AN INPUT CHAR 
C593  8197                      CMPA #TOK_MID      ;TOKEN FOR "MID$" 
C595  102714F3                  LBEQ L86D6         ;PROCESS MID$ REPLACEMENT 
C599  7ECA03                    JMP  LB277         ;SYNTAX ERROR 
                                                     
                      *                              
                      * RESTORE                      
C59C  9E19            RESTOR    LDX  TXTTAB        ;BEGINNING OF PROGRAM ADDRESS 
C59E  301F                      LEAX -1,X          ;MOVE TO ONE BYTE BEFORE PROGRAM 
C5A0  9F33            LADE8     STX  DATPTR        ;SAVE NEW DATA POINTER 
C5A2  39              LADEA     RTS                  
                      *                              
                      * BREAK CHECK                      
C5A3  BDC008          LADEB     JSR  LA1C1         ;GET A KEYSTROKE ENTRY 
C5A6  270A                      BEQ  LADFA         ;RETURN IF NO INPUT 
C5A8  8103            LADF0     CMPA #3            ;CONTROL C? (BREAK) 
C5AA  2715                      BEQ  STOP          ;YES 
C5AC  8113                      CMPA #$13          ;CONTROL S? (PAUSE) 
C5AE  2703                      BEQ  LADFB         ;YES 
C5B0  9773                      STA  IKEYIM        ;SAVE KEYSTROKE IN INKEY IMAGE 
C5B2  39              LADFA     RTS                  
C5B3  BDC008          LADFB     JSR  KEYIN         ;GET A KEY 
C5B6  27FB                      BEQ  LADFB         ;BRANCH IF NO KEY DOWN 
C5B8  20EE                      BRA  LADF0         ;CONTINUE - DO A BREAK CHECK
                       IF MON09
                      *
                      * BYE ;RETURN TO MON09
C5BA  7EE47C          BYE       JMP  MON09_RESET  ;RESET TO MON09
                       ENDIF
                      
                      *                              
                      * END                          
C5BD  9D82            END       JSR  GETCCH        ;GET CURRENT INPUT CHAR 
C5BF  2002                      BRA  LAE0B           
                      *                              
                      * STOP                         
C5C1  1A01            STOP      ORCC #$01          ;SET CARRY FLAG 
C5C3  2631            LAE0B     BNE  LAE40         ;BRANCH IF ARGUMENT EXISTS 
C5C5  9E83                      LDX  CHARAD        ;* SAVE CURRENT POSITION OF 
C5C7  9F2F                      STX  TINPTR        ;* BASIC'S INPUT POINTER
C5C9  0600            LAE11     ROR  ENDFLG        ;ROTATE CARRY INTO BIT 7 OF STOP/END FLAG 
C5CB  3262                      LEAS 2,S           ;PURGE RETURN ADDRESS OFF STACK 
C5CD  9E68            LAE15     LDX  CURLIN        ;GET CURRENT LINE NUMBER 
C5CF  8CFFFF                    CMPX #$FFFF        ;DIRECT MODE? 
C5D2  2706                      BEQ  LAE22         ;YES 
C5D4  9F29                      STX  OLDTXT        ;SAVE CURRENT LINE NUMBER 
C5D6  9E2F                      LDX  TINPTR        ;* GET AND SAVE CURRENT POSITION 
C5D8  9F2D                      STX  OLDPTR        ;* OF BASIC'S INPUT POINTER
C5DA                  LAE22                          
C5DA  8EC3AE                    LDX  #LABF2-1      ;POINT TO CR, 'BREAK' MESSAGE
C5DD  0D00                      TST  ENDFLG        ;CHECK STOP/END FLAG 
C5DF  102AFE3F                  LBPL LAC73         ;BRANCH TO MAIN LOOP OF BASIC IF END 
C5E3  7EC417                    JMP  LAC68         ;PRINT 'BREAK AT ####' AND GO TO
                      *                            ;BASIC'S MAIN LOOP IF 'STOP'
                                                     
                      * CONT                         
C5E6  260E            CONT      BNE  LAE40         ;RETURN IF ARGUMENT GIVEN 
C5E8  C620                      LDB  #2*16         ;'CAN'T CONTINUE' ERROR
C5EA  9E2D                      LDX  OLDPTR        ;GET CONTINUE ADDRESS (INPUT POINTER) 
C5EC  1027FE13                  LBEQ LAC46         ;'CN' ERROR IF CONTINUE ADDRESS = 0
C5F0  9F83                      STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C5F2  9E29                      LDX  OLDTXT        ;GET LINE NUMBER 
C5F4  9F68                      STX  CURLIN        ;RESET CURRENT LINE NUMBER 
C5F6  39              LAE40     RTS                  
                      *                              
                      * CLEAR                        
C5F7  272C            CLEAR     BEQ  LAE6F         ;BRANCH IF NO ARGUMENT 
C5F9  BDCB6D                    JSR  LB3E6         ;EVALUATE ARGUMENT 
C5FC  3406                      PSHS B,A           ;SAVE AMOUNT OF STRING SPACE ON STACK 
C5FE  9E27                      LDX  MEMSIZ        ;GET CURRENT TOP OF CLEARED SPACE 
C600  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C602  270C                      BEQ  LAE5A         ;BRANCH IF NO NEW TOP OF CLEARED SPACE 
C604  BDC9F9                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
C607  BDCEC4                    JSR  LB73D         ;EVALUATE EXPRESSlON; RETURN VALUE IN X 
C60A  301F                      LEAX -1,X          ;X = TOP OF CLEARED SPACE 
C60C  9C71                      CMPX TOPRAM        ;COMPARE TO TOP OF RAM 
C60E  2218                      BHI  LAE72         ;'OM' ERROR IF > TOP OF RAM
C610  1F10            LAE5A     TFR  X,D           ;ACCD = TOP OF CLEARED SPACE 
C612  A3E1                      SUBD ,S++          ;SUBTRACT OUT AMOUNT OF CLEARED SPACE 
C614  2512                      BCS  LAE72         ;'OM' ERROR IF FREE MEM < 0
C616  1F03                      TFR  D,U           ;U = BOTTOM OF CLEARED SPACE 
C618  83003A                    SUBD #STKBUF       ;SUBTRACT OUT STACK BUFFER 
C61B  250B                      BCS  LAE72         ;'OM' ERROR IF FREE MEM < 0
C61D  931B                      SUBD VARTAB        ;SUBTRACT OUT START OF VARIABLES 
C61F  2507                      BCS  LAE72         ;'OM' ERROR IF FREE MEM < 0
C621  DF21                      STU  FRETOP        ;SAVE NEW BOTTOM OF CLEARED SPACE 
C623  9F27                      STX  MEMSIZ        ;SAVE NEW TOP OF CLEARED SPACE 
C625  7EC4C7          LAE6F     JMP  LAD26         ;ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC 
C628  7EC401          LAE72     JMP  LAC44         ;'OM' ERROR
                      *                              
                      * RUN                          
C62B  9D82            RUN       JSR  GETCCH        ;* GET CURRENT INPUT CHARACTER 
C62D  1027FE91                  LBEQ LAD21         ;* IF NO LINE NUMBER 
C631  BDC4C7                    JSR  LAD26         ;ERASE ALL VARIABLES 
C634  2019                      BRA  LAE9F         ;'GOTO' THE RUN ADDRESS
                      *                              
                      * GO                           
C636  1F89            GO        TFR  A,B           ;SAVE INPUT CHARACTER IN ACCB 
C638  9D7C            LAE88     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C63A  C1A0                      CMPB #TOK_TO       ;'TO' TOKEN
C63C  2716                      BEQ  LAEA4         ;BRANCH IF GOTO 
C63E  C1A1                      CMPB #TOK_SUB      ;'SUB' TOKEN
C640  2645                      BNE  LAED7         ;'SYNTAX ERROR' IF NEITHER
C642  C603                      LDB  #3            ;=ROOM FOR 6 
C644  BDC3F0                    JSR  LAC33         ;=BYTES ON STACK? 
C647  DE83                      LDU  CHARAD        ;* SAVE CURRENT BASIC INPUT POINTER, LINE 
C649  9E68                      LDX  CURLIN        ;* NUMBER AND SUB TOKEN ON STACK 
C64B  86A1                      LDA  #TOK_SUB      ;* 
C64D  3452                      PSHS U,X,A         ;* 
C64F  8D03            LAE9F     BSR  LAEA4         ;GO DO A 'GOTO'
C651  7EC53F                    JMP  LAD9E         ;JUMP BACK TO BASIC'S MAIN LOOP
                      * GOTO                         
C654  9D82            LAEA4     JSR  GETCCH        ;GET CURRENT INPUT CHAR 
C656  BDC717                    JSR  LAF67         ;GET LINE NUMBER TO BINARY IN BINVAL 
C659  8D40                      BSR  LAEEB         ;ADVANCE BASIC'S POINTER TO END OF LINE
C65B  3001                      LEAX $01,X         ;POINT TO START OF NEXT LINE 
C65D  DC2B                      LDD  BINVAL        ;GET THE LINE NUMBER TO RUN 
C65F  109368                    CMPD CURLIN        ;COMPARE TO CURRENT LINE NUMBER 
C662  2202                      BHI  LAEB6         ;IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
                      *              DON'T START LOOKING FROM
                      *              START OF PROGRAM  
C664  9E19                      LDX  TXTTAB        ;BEGINNING OF PROGRAM 
C666  BDC4A6          LAEB6     JSR  LAD05         ;GO FIND A LINE NUMBER 
C669  2517                      BCS  LAED2         ;'UNDEFINED LINE NUMBER'
C66B  301F            LAEBB     LEAX -1,X          ;MOVE BACK TO JUST BEFORE START OF LINE 
C66D  9F83                      STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C66F  39              LAEBF     RTS                  
                      *                              
                      * RETURN                       
C670  26FD            RETURN    BNE  LAEBF         ;EXIT ROUTINE IF ARGUMENT GIVEN 
C672  86FF                      LDA  #$FF          ;* PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF 
C674  973B                      STA  VARDES        ;* VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
                      *              STACK TO BE IGNORED  
C676  BDC3B6                    JSR  LABF9         ;CHECK FOR RETURN DATA ON THE STACK 
C679  1F14                      TFR  X,S           ;RESET STACK POINTER - PURGE TWO RETURN ADDRESSES 
                      *              FROM THE STACK  
C67B  8121                      CMPA #TOK_SUB-$80  ;SUB TOKEN - $80 
C67D  270B                      BEQ  LAEDA         ;BRANCH IF 'RETURN' FROM SUBROUTINE
C67F  C604                      LDB  #2*2          ;ERROR #2 'RETURN WITHOUT GOSUB'
C681  8C                        FCB  SKP2          ;SKIP TWO BYTES 
C682  C60E            LAED2     LDB  #7*2          ;ERROR #7 'UNDEFINED LINE NUMBER'
C684  7EC403                    JMP  LAC46         ;JUMP TO ERROR HANDLER 
C687  7ECA03          LAED7     JMP  LB277         ;'SYNTAX ERROR'
C68A  3552            LAEDA     PULS A,X,U         ;* RESTORE VALUES OF CURRENT LINE NUMBER AND 
C68C  9F68                      STX  CURLIN        ;* BASIC'S INPUT POINTER FOR THIS SUBROUTINE
C68E  DF83                      STU  CHARAD        ;* AND LOAD ACCA WITH SUB TOKEN ($A6) 
                      *                              
                      * DATA                         
C690  8D06            DATA      BSR  LAEE8         ;MOVE INPUT POINTER TO END OF SUBLINE OR LINE 
C692  8C                        FCB  SKP2          ;SKIP 2 BYTES 
                                                     
                      * REM, ELSE                      
C693                  ELSE                           
C693  8D06            REM       BSR  LAEEB         ;MOVE INPUT POINTER TO END OF LINE 
C695  9F83                      STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C697  39              LAEE7     RTS                  
                      * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE                      
C698  C63A            LAEE8     LDB  #':           ;COLON = SUBLINE TERMINATOR CHARACTER 
C69A  86              LAEEA     FCB  SKP1LD        ;SKPILD SKIP ONE BYTE; LDA #$5F 
                      * ADVANCE BASIC'S INPUT POINTER TO END OF
                      * LINE - RETURN ADDRESS OF END OF LINE+1 IN X                      
C69B  5F              LAEEB     CLRB               ;0 = LINE TERMINATOR CHARACTER 
C69C  D701                      STB  CHARAC        ;TEMP STORE PRIMARY TERMINATOR CHARACTER 
C69E  5F                        CLRB               ;0 (END OF LINE) = ALTERNATE TERM. CHAR. 
C69F  9E83                      LDX  CHARAD        ;LOAD X W/BASIC'S INPUT POINTER
C6A1  1F98            LAEF1     TFR  B,A           ;* CHANGE TERMINATOR CHARACTER 
C6A3  D601                      LDB  CHARAC        ;* FROM ACCB TO CHARAC - SAVE OLD TERMINATOR 
                      *         IN   CHARAC          
C6A5  9701                      STA  CHARAC        ;SWAP PRIMARY AND SECONDARY TERMINATORS 
C6A7  A684            LAEF7     LDA  ,X            ;GET NEXT INPUT CHARACTER 
C6A9  27EC                      BEQ  LAEE7         ;RETURN IF 0 (END OF LINE) 
C6AB  3404                      PSHS B             ;SAVE TERMINATOR ON STACK 
C6AD  A1E0                      CMPA ,S+           ;COMPARE TO INPUT CHARACTER 
C6AF  27E6                      BEQ  LAEE7         ;RETURN IF EQUAL 
C6B1  3001                      LEAX 1,X           ;MOVE POINTER UP ONE 
C6B3  8122                      CMPA #'"           ;CHECK FOR DOUBLE QUOTES 
C6B5  27EA                      BEQ  LAEF1         ;BRANCH IF " - TOGGLE TERMINATOR CHARACTERS 
C6B7  4C                        INCA               ;* CHECK FOR $FF AND BRANCH IF 
C6B8  2602                      BNE  LAF0C         ;* NOT SECONDARY TOKEN 
C6BA  3001                      LEAX 1,X           ;MOVE INPUT POINTER 1 MORE IF SECONDARY 
C6BC  8186            LAF0C     CMPA #TOK_IF+1     ;TOKEN FOR IF? 
C6BE  26E7                      BNE  LAEF7         ;NO - GET ANOTHER INPUT CHARACTER 
C6C0  0C04                      INC  IFCTR         ;INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY 
                      *                            ;'IF' STATEMENTS ARE NESTED IN ONE LINE
C6C2  20E3                      BRA  LAEF7         ;GET ANOTHER INPUT CHARACTER 
                                                     
                      * IF                           
C6C4  BDC8CD          IF        JSR  LB141         ;EVALUATE NUMERIC EXPRESSION 
C6C7  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C6C9  8181                      CMPA #TOK_GO       ;TOKEN FOR GO 
C6CB  2705                      BEQ  LAF22         ;TREAT 'GO' THE SAME AS 'THEN'
C6CD  C6A2                      LDB  #TOK_THEN     ;TOKEN FOR THEN 
C6CF  BDC9FB                    JSR  LB26F         ;DO A SYNTAX CHECK ON ACCB 
C6D2  964F            LAF22     LDA  FP0EXP        ;CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO 
C6D4  2613                      BNE  LAF39         ;BRANCH IF CONDITION TRUE 
C6D6  0F04                      CLR  IFCTR         ;CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT 
                      *                            ;TO SEARCH FOR IN NESTED 'IF' LOOPS
C6D8  8DB6            LAF28     BSR  DATA          ;MOVE BASIC'S POINTER TO END OF SUBLINE
C6DA  4D                        TSTA               ;* CHECK TO SEE IF END OF LINE OR SUBLINE 
C6DB  27BA                      BEQ  LAEE7         ;* AND RETURN IF END OF LINE 
C6DD  9D7C                      JSR  GETNCH        ;GET AN INPUT CHARACTER FROM BASIC 
C6DF  8184                      CMPA #TOK_ELSE     ;TOKEN FOR ELSE 
C6E1  26F5                      BNE  LAF28         ;IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
                      *                            ;END OF LINE (ZERO BYTE) 
C6E3  0A04                      DEC  IFCTR         ;CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE 
C6E5  2AF1                      BPL  LAF28         ;BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
C6E7  9D7C                      JSR  GETNCH        ;GET AN INPUT CHARACTER FROM BASIC 
C6E9  9D82            LAF39     JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C6EB  1025FF65                  LBCS LAEA4         ;BRANCH TO 'GOTO' IF NUMERIC CHARACTER
C6EF  7EC577                    JMP  LADC6         ;RETURN TO MAIN INTERPRETATION LOOP 
                                                     
                      * ON                           
C6F2  BDCE92          ON        JSR  LB70B         ;EVALUATE EXPRESSION 
C6F5  C681                      LDB  #TOK_GO       ;TOKEN FOR GO 
C6F7  BDC9FB                    JSR  LB26F         ;SYNTAX CHECK FOR GO 
C6FA  3402                      PSHS A             ;SAVE NEW TOKEN (TO,SUB) 
C6FC  81A1                      CMPA #TOK_SUB      ;TOKEN FOR SUB? 
C6FE  2704                      BEQ  LAF54         ;YES 
C700  81A0                      CMPA #TOK_TO       ;TOKEN FOR TO? 
C702  2683            LAF52     BNE  LAED7         ;'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
C704  0A53            LAF54     DEC  FPA0+3        ;DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS 
                      *                            ;IS THE ARGUMENT OF THE 'ON' STATEMENT
C706  2605                      BNE  LAF5D         ;BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER 
C708  3504                      PULS B             ;GET BACK THE TOKEN FOLLOWING 'GO'
C70A  7EC638                    JMP  LAE88         ;GO DO A 'GOTO' OR 'GOSUB'
C70D  9D7C            LAF5D     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C70F  8D06                      BSR  LAF67         ;CONVERT BASIC LINE NUMBER TO BINARY 
C711  812C                      CMPA #',           ;IS CHARACTER FOLLOWING LINE NUMBER A COMMA? 
C713  27EF                      BEQ  LAF54         ;YES 
C715  3584                      PULS B,PC          ;IF NOT, FALL THROUGH TO NEXT COMMAND 
C717  9E74            LAF67     LDX  ZERO          ;DEFAULT LINE NUMBER OF ZERO 
C719  9F2B                      STX  BINVAL        ;SAVE IT IN BINVAL 
                      *                              
                      * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL                      
                      *                              
C71B  2461            LAF6B     BCC  LAFCE         ;RETURN IF NOT NUMERIC CHARACTER 
C71D  8030                      SUBA #'0           ;MASK OFF ASCII 
C71F  9701                      STA  CHARAC        ;SAVE DIGIT IN VO1 
C721  DC2B                      LDD  BINVAL        ;GET ACCUMULATED LINE NUMBER VALUE 
C723  8118                      CMPA #24           ;LARGEST LINE NUMBER IS $F9FF (63999) - 
                      *         (24*256+255)*10+9                 
C725  22DB                      BHI  LAF52         ;'SYNTAX' ERROR IF TOO BIG
                      * MULT ACCD X 10                      
C727  58                        ASLB               ;* 
C728  49                        ROLA               ;* TIMES 2 
C729  58                        ASLB               ;= 
C72A  49                        ROLA               ;= TIMES 4 
C72B  D32B                      ADDD BINVAL        ;ADD 1 = TIMES 5 
C72D  58                        ASLB               ;* 
C72E  49                        ROLA               ;* TIMES 10 
C72F  DB01                      ADDB CHARAC        ;ADD NEXT DIGIT 
C731  8900                      ADCA #0            ;PROPAGATE CARRY 
C733  DD2B                      STD  BINVAL        ;SAVE NEW ACCUMULATED LINE NUMBER 
C735  9D7C                      JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
C737  20E2                      BRA  LAF6B         ;LOOP- PROCESS NEXT DIGIT 
                      *                              
                      * LET (EXBAS)                      
                      * EVALUATE A NON-TOKEN EXPRESSION                      
                      * TARGET = REPLACEMENT                      
C739  BDCADE          LET       JSR  LB357         ;FIND TARGET VARIABLE DESCRIPTOR 
C73C  9F3B                      STX  VARDES        ;SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION 
C73E  C6AE                      LDB  #TOK_EQUALS   ;TOKEN FOR "=" 
C740  BDC9FB                    JSR  LB26F         ;DO A SYNTAX CHECK FOR '='
C743  9606                      LDA  VALTYP        ;* GET VARIABLE TYPE AND 
C745  3402                      PSHS A             ;* SAVE ON THE STACK 
C747  BDC8E2                    JSR  LB156         ;EVALUATE EXPRESSION 
C74A  3502                      PULS A             ;* REGET VARIABLE TYPE OF 1ST EXPRESSION AND 
C74C  46                        RORA               ;* SET CARRY IF STRING 
C74D  BDC8D4                    JSR  LB148         ;TYPE CHECK-TM ERROR IF VARIABLE TYPES ON 
                      *                            ;BOTH SIDES OF EQUALS SIGN NOT THE SAME 
C750  10270C2B                  LBEQ LBC33         ;GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC 
                      * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT                      
                      * FPA0+2 INTO THE STRING SPACE. TRANSFER THE                      
                      * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES                      
                      * DON'T MOVE THE STRING IF IT;IS ALREADY IN THE
                      * STRING SPACE. REMOVE DESCRIPTOR FROM STRING                      
                      * STACK IF IT IS LAST ONE ON THE STACK                      
C754  9E52            LAFA4     LDX  FPA0+2        ;POINT X TO DESCRIPTOR OF REPLACEMENT STRING 
C756  DC21                      LDD  FRETOP        ;LOAD ACCD WITH START OF STRING SPACE 
C758  10A302                    CMPD 2,X           ;IS THE STRING IN STRING SPACE? 
C75B  2411                      BCC  LAFBE         ;BRANCH IF IT'S NOT IN THE STRING SPACE
C75D  9C1B                      CMPX VARTAB        ;COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES 
C75F  250D                      BCS  LAFBE         ;BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES 
C761  E684            LAFB1     LDB  ,X            ;GET LENGTH OF REPLACEMENT STRING 
C763  BDCC94                    JSR  LB50D         ;RESERVE ACCB BYTES OF STRING SPACE 
C766  9E4D                      LDX  V4D           ;GET DESCRIPTOR ADDRESS BACK 
C768  BDCDCA                    JSR  LB643         ;MOVE STRING INTO STRING SPACE 
C76B  8E0056                    LDX  #STRDES       ;POINT X TO TEMP STRING DESCRIPTOR ADDRESS 
C76E  9F4D            LAFBE     STX  V4D           ;SAVE STRING DESCRIPTOR ADDRESS IN V4D 
C770  BDCDFC                    JSR  LB675         ;REMOVE STRING DESCRIPTOR IF LAST ONE 
                      *              ON STRING STACK  
C773  DE4D                      LDU  V4D           ;POINT U TO REPLACEMENT DESCRIPTOR ADDRESS 
C775  9E3B                      LDX  VARDES        ;GET TARGET DESCRIPTOR ADDRESS 
C777  3726                      PULU A,B,Y         ;GET LENGTH AND START OF REPLACEMENT STRING 
C779  A784                      STA  ,X            ;* SAVE STRING LENGTH AND START IN 
C77B  10AF02                    STY  2,X           ;* TARGET DESCRIPTOR LOCATION 
C77E  39              LAFCE     RTS                  
                                                     
C77F  3F5245444F      LAFCF     FCC  "?REDO"       ;?REDO MESSAGE 
C784  0D00                      FCB  CR,$00          
                                                     
C786                  LAFD6                          
C786  7EC403          LAFDC     JMP  LAC46         ;JMP TO ERROR HANDLER 
C789  9609            LAFDF     LDA  INPFLG        ;= GET THE INPUT FLAG AND BRANCH 
C78B  2707                      BEQ  LAFEA         ;= IF 'INPUT'
C78D  9E31                      LDX  DATTXT        ;* GET LINE NUMBER WHERE THE ERROR OCCURRED 
C78F  9F68                      STX  CURLIN        ;* AND USE IT AS THE CURRENT LINE NUMBER 
C791  7ECA03                    JMP  LB277         ;'SYNTAX ERROR'
C794  8EC77E          LAFEA     LDX  #LAFCF-1      ;* POINT X TO '?REDO' AND PRINT
C797  BDD0E8                    JSR  LB99C         ;* IT ON THE SCREEN 
C79A  9E2F                      LDX  TINPTR        ;= GET THE SAVED ABSOLUTE ADDRESS OF 
C79C  9F83                      STX  CHARAD        ;= INPUT POINTER AND RESTORE IT 
C79E  39                        RTS                  
                      *                              
                      * INPUT                        
C79F  C616            INPUT     LDB  #11*2         ;'ID' ERROR
C7A1  9E68                      LDX  CURLIN        ;GET CURRENT LINE NUMBER 
C7A3  3001                      LEAX 1,X           ;ADD ONE 
C7A5  27DF                      BEQ  LAFDC         ;'ID' ERROR BRANCH IF DIRECT MODE
C7A7  8D01                      BSR  LB00F         ;GET SOME INPUT DATA - WAS LB002 
C7A9  39                        RTS                  
C7AA  8122            LB00F     CMPA #'"           ;CHECK FOR PROMPT STRING DELIMITER 
C7AC  260B                      BNE  LB01E         ;BRANCH IF NO PROMPT STRING 
C7AE  BDC9D0                    JSR  LB244         ;PUT PROMPT STRING ON STRING STACK 
C7B1  C63B                      LDB  #';           ;* 
C7B3  BDC9FB                    JSR  LB26F         ;* DO A SYNTAX CHECK FOR SEMICOLON 
C7B6  BDD0EB                    JSR  LB99F         ;PRINT MESSAGE TO CONSOLE OUT 
C7B9  8E00F3          LB01E     LDX  #LINBUF       ;POINT TO BASIC'S LINE BUFFER
C7BC  6F84                      CLR  ,X            ;CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA 
                      *              IN LINE BUFFER  
C7BE  8D06                      BSR  LB02F         ;INPUT A STRING TO LINE BUFFER 
C7C0  C62C                      LDB  #',           ;* INSERT A COMMA AT THE END 
C7C2  E784                      STB  ,X            ;* OF THE LINE INPUT BUFFER 
C7C4  2016                      BRA  LB049           
                      * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
C7C6  BDD0FB          LB02F     JSR  LB9AF         ;SEND A "?" TO CONSOLE OUT 
C7C9  BDD0F8                    JSR  LB9AC         ;SEND A 'SPACE' TO CONSOLE OUT
C7CC  BDC13C          LB035     JSR  LA390         ;GO READ IN A BASIC LINE 
C7CF  2405                      BCC  LB03F         ;BRANCH IF ENTER KEY ENDED ENTRY 
C7D1  3264                      LEAS 4,S           ;PURGE TWO RETURN ADDRESSES OFF THE STACK 
C7D3  7EC5C9                    JMP  LAE11         ;GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
C7D6  C62E            LB03F     LDB  #2*23         ;'INPUT PAST END OF FILE' ERROR
C7D8  39                        RTS                  
                      *                              
                      * READ                         
C7D9  9E33            READ      LDX  DATPTR        ;GET 'READ' START ADDRESS
C7DB  86                        FCB  SKP1LD        ;SKIP ONE BYTE - LDA #*$4F 
C7DC  4F              LB049     CLRA               ;'INPUT' ENTRY POINT: INPUT FLAG = 0
C7DD  9709                      STA  INPFLG        ;SET INPUT FLAG; 0 = INPUT: <> 0 = READ 
C7DF  9F35                      STX  DATTMP        ;SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
C7E1  BDCADE          LB04E     JSR  LB357         ;EVALUATE A VARIABLE 
C7E4  9F3B                      STX  VARDES        ;SAVE DESCRIPTOR ADDRESS 
C7E6  9E83                      LDX  CHARAD        ;* GET BASIC'S INPUT POINTER
C7E8  9F2B                      STX  BINVAL        ;* AND SAVE IT 
C7EA  9E35                      LDX  DATTMP        ;GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
C7EC  A684                      LDA  ,X            ;GET A CHARACTER FROM THE BASIC PROGRAM 
C7EE  2609                      BNE  LB069         ;BRANCH IF NOT END OF LINE 
C7F0  9609                      LDA  INPFLG        ;* CHECK INPUT FLAG AND BRANCH 
C7F2  2651                      BNE  LB0B9         ;* IF LOOKING FOR DATA (READ) 
                      * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
                      * NOT COMING FROM SCREEN                      
C7F4  BDD0FB                    JSR  LB9AF         ;SEND A '?' TO CONSOLE OUT 
C7F7  8DCD                      BSR  LB02F         ;FILL INPUT BUFFER FROM CONSOLE IN 
C7F9  9F83            LB069     STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C7FB  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C7FD  D606                      LDB  VALTYP        ;* CHECK VARIABLE TYPE AND 
C7FF  2723                      BEQ  LB098         ;* BRANCH IF NUMERIC 
                      * READ/INPUT A STRING VARIABLE                      
C801  9E83                      LDX  CHARAD        ;LOAD X WITH CURRENT BASIC INPUT POINTER 
C803  9701                      STA  CHARAC        ;SAVE CURRENT INPUT CHARACTER 
C805  8122                      CMPA #'"           ;CHECK FOR STRING DELIMITER 
C807  270E                      BEQ  LB08B         ;BRANCH IF STRING DELIMITER 
C809  301F                      LEAX -1,X          ;BACK UP POINTER 
C80B  4F                        CLRA               ;* ZERO = END OF LINE CHARACTER 
C80C  9701                      STA  CHARAC        ;* SAVE AS TERMINATOR 
C80E  BDC12E                    JSR  LA35F         ;SET UP PRINT PARAMETERS 
C811  863A                      LDA  #':           ;END OF SUBLINE CHARACTER 
C813  9701                      STA  CHARAC        ;SAVE AS TERMINATOR I 
C815  862C                      LDA  #',           ;COMMA 
C817  9702            LB08B     STA  ENDCHR        ;SAVE AS TERMINATOR 2 
C819  BDCCA5                    JSR  LB51E         ;STRIP A STRING FROM THE INPUT BUFFER 
C81C  BDC9D5                    JSR  LB249         ;MOVE INPUT POINTER TO END OF STRING 
C81F  BDC754                    JSR  LAFA4         ;PUT A STRING INTO THE STRING SPACE IF NECESSARY 
C822  2006                      BRA  LB09E         ;CHECK FOR ANOTHER DATA ITEM 
                      * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM                      
C824  BDD45E          LB098     JSR  LBD12         ;CONVERT AN ASCII STRING TO FP NUMBER 
C827  BDD37F                    JSR  LBC33         ;PACK FPA0 AND STORE IT IN ADDRESS IN VARDES - 
                      *                            ;INPUT OR READ DATA ITEM 
C82A  9D82            LB09E     JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C82C  2706                      BEQ  LB0A8         ;BRANCH IF END OF LINE 
C82E  812C                      CMPA #',           ;CHECK FOR A COMMA 
C830  1026FF52                  LBNE LAFD6         ;BAD FILE DATA' ERROR OR RETRY 
C834  9E83            LB0A8     LDX  CHARAD        ;* GET CURRENT INPUT 
C836  9F35                      STX  DATTMP        ;* POINTER (USED AS A DATA POINTER) AND SAVE IT 
C838  9E2B                      LDX  BINVAL        ;* RESET INPUT POINTER TO INPUT OR 
C83A  9F83                      STX  CHARAD        ;* READ STATEMENT 
C83C  9D82                      JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
C83E  2721                      BEQ  LB0D5         ;BRANCH IF END OF LINE - EXIT COMMAND 
C840  BDC9F9                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
C843  209C                      BRA  LB04E         ;GET ANOTHER INPUT OR READ ITEM 
                      * SEARCH FROM ADDRESS IN X FOR                      
                      * 1ST OCCURENCE OF THE TOKEN FOR DATA                      
C845  9F83            LB0B9     STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C847  BDC698                    JSR  LAEE8         ;SEARCH FOR END OF CURRENT LINE OR SUBLINE 
C84A  3001                      LEAX 1,X           ;MOVE X ONE PAST END OF LINE 
C84C  4D                        TSTA               ;CHECK FOR END OF LINE 
C84D  260A                      BNE  LB0CD         ;BRANCH IF END OF SUBLINE 
C84F  C606                      LDB  #2*3          ;'OUT OF DATA' ERROR
C851  EE81                      LDU  ,X++          ;GET NEXT 2 CHARACTERS 
C853  2741                      BEQ  LB10A         ;'OD' ERROR IF END OF PROGRAM
C855  EC81                      LDD  ,X++          ;GET BASIC LINE NUMBER AND 
C857  DD31                      STD  DATTXT        ;SAVE IT IN DATTXT 
C859  A684            LB0CD     LDA  ,X            ;GET AN INPUT CHARACTER 
C85B  8186                      CMPA #TOK_DATA     ;DATA TOKEN? 
C85D  26E6                      BNE  LB0B9         ;NO ' KEEP LOOKING
C85F  2098                      BRA  LB069         ;YES 
                      * EXIT READ AND INPUT COMMANDS                      
C861  9E35            LB0D5     LDX  DATTMP        ;GET DATA POINTER 
C863  D609                      LDB  INPFLG        ;* CHECK INPUT FLAG 
C865  1026FD37                  LBNE LADE8         ;* SAVE NEW DATA POINTER IF READ 
C869  A684                      LDA  ,X            ;= CHECK NEXT CHARACTER IN 'INPUT' BUFFER
C86B  2706                      BEQ  LB0E7         ;= 
C86D  8EC873                    LDX  #LB0E8-1      ;POINT X TO '?EXTRA IGNORED'
C870  7ED0E8                    JMP  LB99C         ;PRINT THE MESSAGE 
C873  39              LB0E7     RTS                  
                                                     
C874  3F45585452412049474E4F524544 LB0E8     FCC  "?EXTRA IGNORED" ;?EXTRA IGNORED MESSAGE 
                                                     
                                                     
C882  0D00                      FCB  CR,$00          
                                                     
                      * NEXT                         
C884  2604            NEXT      BNE  LB0FE         ;BRANCH IF ARGUMENT GIVEN 
C886  9E74                      LDX  ZERO          ;X = 0: DEFAULT FOR NO ARGUMENT 
C888  2003                      BRA  LB101           
C88A  BDCADE          LB0FE     JSR  LB357         ;EVALUATE AN ALPHA EXPRESSION 
C88D  9F3B            LB101     STX  VARDES        ;SAVE VARIABLE DESCRIPTOR POINTER 
C88F  BDC3B6                    JSR  LABF9         ;GO SCAN FOR 'FOR/NEXT' DATA ON STACK
C892  2704                      BEQ  LB10C         ;BRANCH IF DATA FOUND 
C894  C600                      LDB  #0            ;'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
C896  2047            LB10A     BRA  LB153         ;PROCESS ERROR 
C898  1F14            LB10C     TFR  X,S           ;POINT S TO START OF 'FOR/NEXT' DATA
C89A  3003                      LEAX 3,X           ;POINT X TO FP VALUE OF STEP 
C89C  BDD360                    JSR  LBC14         ;COPY A FP NUMBER FROM (X) TO FPA0 
C89F  A668                      LDA  8,S           ;GET THE DIRECTION OF STEP 
C8A1  9754                      STA  FP0SGN        ;SAVE IT AS THE SIGN OF FPA0 
C8A3  9E3B                      LDX  VARDES        ;POINT (X) TO INDEX VARIABLE DESCRIPTOR 
C8A5  BDD10E                    JSR  LB9C2         ;ADD (X) TO FPA0 (STEP TO INDEX) 
C8A8  BDD37F                    JSR  LBC33         ;PACK FPA0 AND STORE IT IN ADDRESS 
                      *                            ;CONTAINED IN VARDES 
C8AB  3069                      LEAX 9,S           ;POINT (X) TO TERMINAL VALUE OF INDEX 
C8AD  BDD3E2                    JSR  LBC96         ;COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX 
C8B0  E068                      SUBB 8,S           ;ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF 
                      *                            ;STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR 
                      *                            ;STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE 
C8B2  270C                      BEQ  LB134         ;BRANCH IF 'FOR/NEXT' LOOP DONE
C8B4  AE6E                      LDX  14,S          ;* GET LINE NUMBER AND 
C8B6  9F68                      STX  CURLIN        ;* BASIC POINTER OF 
C8B8  AEE810                    LDX  16,S          ;* STATEMENT FOLLOWING THE 
C8BB  9F83                      STX  CHARAD        ;* PROPER FOR STATEMENT 
C8BD  7EC53F          LB131     JMP  LAD9E         ;JUMP BACK TO COMMAND INTEPR. LOOP 
C8C0  32E812          LB134     LEAS 18,S          ;PULL THE 'FOR-NEXT' DATA OFF THE STACK
C8C3  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C8C5  812C                      CMPA #',           ;CHECK FOR ANOTHER ARGUMENT 
C8C7  26F4                      BNE  LB131         ;RETURN IF NONE 
C8C9  9D7C                      JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
C8CB  8DBD                      BSR  LB0FE         ;BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
                                                     
                                                     
C8CD  8D13            LB141     BSR  LB156         ;EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC 
C8CF  1CFE            LB143     ANDCC #$FE         ;CLEAR CARRY FLAG 
C8D1  7D              LB145     FCB  $7D           ;OP CODE OF TST $1A01 - SKIP TWO BYTES (DO 
                      *              NOT CHANGE CARRY FLAG)  
C8D2  1A01            LB146     ORCC #1            ;SET CARRY 
                                                     
                      * STRING TYPE MODE CHECK - IF;ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR                      
                      * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR                      
                      * IF ENTERED AT LB148, A TYPE;CHECK IS DONE ON VALTYP                      
                      * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC                      
                      * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.                      
C8D4  0D06            LB148     TST  VALTYP        ;TEST TYPE FLAG; DO NOT CHANGE CARRY 
C8D6  2503                      BCS  LB14F         ;BRANCH IF STRING 
C8D8  2A99                      BPL  LB0E7         ;RETURN ON PLUS 
C8DA  8C                        FCB  SKP2          ;SKIP 2 BYTES - 'TM' ERROR
C8DB  2B96            LB14F     BMI  LB0E7         ;RETURN ON MINUS 
C8DD  C618                      LDB  #12*2         ;'TYPE M1SMATCH' ERROR
C8DF  7EC403          LB153     JMP  LAC46         ;PROCESS ERROR 
                      * EVALUATE EXPRESSION                      
C8E2  8D6E            LB156     BSR  LB1C6         ;BACK UP INPUT POINTER 
C8E4  4F              LB158     CLRA               ;END OF OPERATION PRECEDENCE FLAG 
C8E5  8C                        FCB  SKP2          ;SKIP TWO BYTES 
C8E6  3404            LB15A     PSHS B             ;SAVE FLAG (RELATIONAL OPERATOR FLAG) 
C8E8  3402                      PSHS A             ;SAVE FLAG (PRECEDENCE FLAG) 
C8EA  C601                      LDB  #1            ;* 
C8EC  BDC3F0                    JSR  LAC33         ;* SEE IF ROOM IN FREE RAM FOR (B) WORDS 
C8EF  BDC9AF                    JSR  LB223         ;GO EVALUATE AN EXPRESSION 
C8F2  0F3F                      CLR  TRELFL        ;RESET RELATIONAL OPERATOR FLAG 
C8F4  9D82            LB168     JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
                      * CHECK FOR RELATIONAL OPERATORS                      
C8F6  80AD            LB16A     SUBA #TOK_GREATER  ;TOKEN FOR > 
C8F8  2513                      BCS  LB181         ;BRANCH IF LESS THAN RELATIONAL OPERATORS 
C8FA  8103                      CMPA #3            ;* 
C8FC  240F                      BCC  LB181         ;* BRANCH IF GREATER THAN RELATIONAL OPERATORS 
C8FE  8101                      CMPA #1            ;SET CARRY IF '>'
C900  49                        ROLA               ;CARRY TO BIT 0 
C901  983F                      EORA TRELFL        ;* CARRY SET IF 
C903  913F                      CMPA TRELFL        ;* TRELFL = ACCA 
C905  2564                      BCS  LB1DF         ;BRANCH IF SYNTAX ERROR : == << OR >> 
C907  973F                      STA  TRELFL        ;BIT 0: >, BIT 1 =, BIT 2: < 
C909  9D7C                      JSR  GETNCH        ;GET AN INPUT CHARACTER 
C90B  20E9                      BRA  LB16A         ;CHECK FOR ANOTHER RELATIONAL OPERATOR 
                      *                              
C90D  D63F            LB181     LDB  TRELFL        ;GET RELATIONAL OPERATOR FLAG 
C90F  2633                      BNE  LB1B8         ;BRANCH IF RELATIONAL COMPARISON 
C911  1024006B                  LBCC LB1F4         ;BRANCH IF > RELATIONAL OPERATOR 
C915  8B07                      ADDA #7            ;SEVEN ARITHMETIC/LOGICAL OPERATORS 
C917  2467                      BCC  LB1F4         ;BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR 
C919  9906                      ADCA VALTYP        ;ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER 
C91B  10270477                  LBEQ LB60F         ;BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
                      *                            ;CONCATENATE TWO STRINGS 
C91F  89FF                      ADCA #-1           ;RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER 
C921  3402                      PSHS A             ;* STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2 
C923  48                        ASLA               ;* THEN ADD THE STORED STACK DATA = MULTIPLY 
C924  ABE0                      ADDA ,S+           ;* X 3; 3 BYTE/TABLE ENTRY 
C926  8EC206                    LDX  #LAA51        ;JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS 
C929  3086                      LEAX A,X           ;POINT X TO PROPER TABLE 
C92B  3502            LB19F     PULS A             ;GET PRECEDENCE FLAG FROM STACK 
C92D  A184                      CMPA ,X            ;COMPARE TO CURRENT OPERATOR 
C92F  2455                      BCC  LB1FA         ;BRANCH IF STACK OPERATOR > CURRENT OPERATOR 
C931  8D9C                      BSR  LB143         ;'TM' ERROR IF VARIABLE TYPE = STRING
                                                     
                      * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.                      
C933  3402            LB1A7     PSHS A             ;SAVE PRECEDENCE FLAG 
C935  8D29                      BSR  LB1D4         ;PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK 
C937  9E3D                      LDX  RELPTR        ;GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR 
                      *                            ;LAST CALCULATED OPERATION 
C939  3502                      PULS A             ;GET PRECEDENCE FLAG OF PREVIOUS OPERATION 
C93B  261D                      BNE  LB1CE         ;BRANCH IF NOT END OF OPERATION 
C93D  4D                        TSTA               ;CHECK TYPE OF PRECEDENCE FLAG 
C93E  1027006A                  LBEQ LB220         ;BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION 
C942  204B                      BRA  LB203         ;EVALUATE AN OPERATION 
                                                     
C944  0806            LB1B8     ASL  VALTYP        ;BIT 7 OF TYPE FLAG TO CARRY 
C946  59                        ROLB               ;SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0 
C947  8D09                      BSR  LB1C6         ;MOVE THE INPUT POINTER BACK ONE 
C949  8EC957                    LDX  #LB1CB        ;POINT X TO RELATIONAL COMPARISON JUMP TABLE 
C94C  D73F                      STB  TRELFL        ;SAVE RELATIONAL COMPARISON DATA 
C94E  0F06                      CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
C950  20D9                      BRA  LB19F         ;PERFORM OPERATION OR SAVE ON STACK 
                                                     
C952  9E83            LB1C6     LDX  CHARAD        ;* GET BASIC'S INPUT POINTER AND
C954  7EC66B                    JMP  LAEBB         ;* MOVE IT BACK ONE 
                      * RELATIONAL COMPARISON JUMP TABLE                      
C957  64              LB1CB     FCB  $64           ;RELATIONAL COMPARISON FLAG 
C958  CA7B            LB1CC     FDB  LB2F4         ;JUMP ADDRESS 
                                                     
C95A  A184            LB1CE     CMPA ,X            ;COMPARE PRECEDENCE OF LAST DONE OPERATION TO 
                      *         NEXT TO BE DONE OPERATION  
C95C  2431                      BCC  LB203         ;EVALUATE OPERATION IF LOWER PRECEDENCE 
C95E  20D3                      BRA  LB1A7         ;PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE 
                                                     
                      * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR                      
C960  EC01            LB1D4     LDD  1,X           ;GET ADDRESS OF OPERATOR ROUTINE 
C962  3406                      PSHS B,A           ;SAVE IT ON THE STACK 
C964  8D08                      BSR  LB1E2         ;PUSH FPA0 ONTO STACK 
C966  D63F                      LDB  TRELFL        ;GET BACK RELATIONAL OPERATOR FLAG 
C968  16FF7B                    LBRA LB15A         ;EVALUATE ANOTHER EXPRESSION 
C96B  7ECA03          LB1DF     JMP  LB277         ;'SYNTAX ERROR'
                      * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT      
                      * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA  
                      * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA  
C96E  D654            LB1E2     LDB  FP0SGN        ;GET SIGN OF FPA0 MANTISSA 
C970  A684                      LDA  ,X            ;GET PRECEDENCE CODE TO ACCA 
C972  3520            LB1E6     PULS Y             ;GET RETURN ADDRESS FROM STACK & PUT IT IN Y 
C974  3404                      PSHS B             ;SAVE ACCB ON STACK 
C976  D64F            LB1EA     LDB  FP0EXP        ;* PUSH FPA0 ONTO THE STACK 
C978  9E50                      LDX  FPA0          ;* 
C97A  DE52                      LDU  FPA0+2        ;* 
C97C  3454                      PSHS U,X,B         ;* 
C97E  6EA4                      JMP  ,Y            ;JUMP TO ADDRESS IN Y 
                                                     
                      * BRANCH HERE IF NON-OPERATOR;CHARACTER FOUND - USUALLY ')' OR END OF LINE
C980  9E74            LB1F4     LDX  ZERO          ;POINT X TO DUMMY VALUE (ZERO) 
C982  A6E0                      LDA  ,S+           ;GET PRECEDENCE FLAG FROM STACK 
C984  2726                      BEQ  LB220         ;BRANCH IF END OF EXPRESSION 
C986  8164            LB1FA     CMPA #$64          ;* CHECK FOR RELATIONAL COMPARISON FLAG 
C988  2703                      BEQ  LB201         ;* AND BRANCH IF RELATIONAL COMPARISON 
C98A  BDC8CF                    JSR  LB143         ;'TM' ERROR IF VARIABLE TYPE = STRING
C98D  9F3D            LB201     STX  RELPTR        ;SAVE POINTER TO OPERATOR ROUTINE 
C98F  3504            LB203     PULS B             ;GET RELATIONAL OPERATOR FLAG FROM STACK 
C991  815A                      CMPA #$5A          ;CHECK FOR 'NOT' OPERATOR
C993  2719                      BEQ  LB222         ;RETURN IF 'NOT' - NO RELATIONAL COMPARISON
C995  817D                      CMPA #$7D          ;CHECK FOR NEGATION (UNARY) FLAG 
C997  2715                      BEQ  LB222         ;RETURN IF NEGATION - NO RELATIONAL COMPARISON 
                                                     
                      * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES                      
                      * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH                      
                      * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR                      
                      * TO EVALUATING ROUTINE.                      
C999  54                        LSRB               ;= ROTATE VALTYP BIT INTO CARRY 
C99A  D70A                      STB  RELFLG        ;= FLAG AND SAVE NEW RELFLG 
C99C  3552                      PULS A,X,U         ;* PULL A FP VALUE OFF OF THE STACK 
C99E  975C                      STA  FP1EXP        ;* AND SAVE IT IN FPA1 
C9A0  9F5D                      STX  FPA1          ;* 
C9A2  DF5F                      STU  FPA1+2        ;* 
C9A4  3504                      PULS B             ;= GET MANTISSA SIGN AND 
C9A6  D761                      STB  FP1SGN        ;= SAVE IT IN FPA1 
C9A8  D854                      EORB FP0SGN        ;EOR IT WITH FPA1 MANTISSA SIGN 
C9AA  D762                      STB  RESSGN        ;SAVE IT IN RESULT SIGN BYTE 
C9AC  D64F            LB220     LDB  FP0EXP        ;GET EXPONENT OF FPA0 
C9AE  39              LB222     RTS                  
                                                     
C9AF  BDDBFC          LB223     JSR  XVEC15        ;CALL EXTENDED BASIC ADD-IN 
C9B2  0F06                      CLR  VALTYP        ;INITIALIZE TYPE FLAG TO NUMERIC 
C9B4  9D7C                      JSR  GETNCH        ;GET AN INPUT CHAR 
C9B6  2403                      BCC  LB22F         ;BRANCH IF NOT NUMERIC 
C9B8  7ED45E          LB22C     JMP  LBD12         ;CONVERT ASCII STRING TO FLOATING POINT - 
                      *         RETURN RESULT IN FPA0  
                      * PROCESS A NON NUMERIC FIRST;CHARACTER                      
C9BB  BDCB29          LB22F     JSR  LB3A2         ;SET CARRY IF NOT ALPHA 
C9BE  2450                      BCC  LB284         ;BRANCH IF ALPHA CHARACTER 
C9C0  812E                      CMPA #'.           ;IS IT '.' (DECIMAL POINT)?
C9C2  27F4                      BEQ  LB22C         ;CONVERT ASCII STRING TO FLOATING POINT 
C9C4  81A7                      CMPA #TOK_MINUS    ;MINUS TOKEN 
C9C6  2740                      BEQ  LB27C         ;YES - GO PROCESS THE MINUS OPERATOR 
C9C8  81A6                      CMPA #TOK_PLUS     ;PLUS TOKEN 
C9CA  27E3                      BEQ  LB223         ;YES - GET ANOTHER CHARACTER 
C9CC  8122                      CMPA #'"           ;STRING DELIMITER? 
C9CE  260A                      BNE  LB24E         ;NO 
C9D0  9E83            LB244     LDX  CHARAD        ;CURRENT BASIC POINTER TO X 
C9D2  BDCC9F                    JSR  LB518         ;SAVE STRING ON STRING STACK 
C9D5  9E64            LB249     LDX  COEFPT        ;* GET ADDRESS OF END OF STRING AND 
C9D7  9F83                      STX  CHARAD        ;* PUT BASIC'S INPUT POINTER THERE
C9D9  39                        RTS                  
C9DA  81A3            LB24E     CMPA #TOK_NOT      ;NOT TOKEN? 
C9DC  260D                      BNE  LB25F         ;NO 
                      * PROCESS THE NOT OPERATOR                      
C9DE  865A                      LDA  #$5A          ;'NOT' PRECEDENCE FLAG
C9E0  BDC8E6                    JSR  LB15A         ;PROCESS OPERATION FOLLOWING 'NOT'
C9E3  BDCB74                    JSR  INTCNV        ;CONVERT FPA0 TO INTEGER IN ACCD 
C9E6  43                        COMA               ;* 'NOT' THE INTEGER
C9E7  53                        COMB               ;* 
C9E8  7ECC7B                    JMP  GIVABF        ;CONVERT ACCD TO FLOATING POINT (FPA0) 
C9EB  4C              LB25F     INCA               ;CHECK FOR TOKENS PRECEEDED BY $FF 
C9EC  272E                      BEQ  LB290         ;IT WAS PRECEEDED BY $FF 
C9EE  8D06            LB262     BSR  LB26A         ;SYNTAX CHECK FOR A '('
C9F0  BDC8E2                    JSR  LB156         ;EVALUATE EXPRESSIONS WITHIN PARENTHESES AT 
                      *         HIGHEST PRECEDENCE      
C9F3  C629            LB267     LDB  #')           ;SYNTAX CHECK FOR ')'
C9F5  8C                        FCB  SKP2          ;SKIP 2 BYTES 
C9F6  C628            LB26A     LDB  #'(           ;SYNTAX CHECK FOR '('
C9F8  8C                        FCB  SKP2          ;SKIP 2 BYTES 
C9F9  C62C            LB26D     LDB  #',           ;SYNTAX CHECK FOR COMMA 
C9FB  E19F0083        LB26F     CMPB [CHARAD]      ;* COMPARE ACCB TO CURRENT INPUT 
C9FF  2602                      BNE  LB277         ;* CHARACTER - SYNTAX ERROR IF NO MATCH 
CA01  0E7C                      JMP  GETNCH        ;GET A CHARACTER FROM BASIC 
CA03  C602            LB277     LDB  #2*1          ;SYNTAX ERROR 
CA05  7EC403                    JMP  LAC46         ;JUMP TO ERROR HANDLER 
                                                     
                      * PROCESS THE MINUS (UNARY) OPERATOR                      
CA08  867D            LB27C     LDA  #$7D          ;MINUS (UNARY) PRECEDENCE FLAG 
CA0A  BDC8E6                    JSR  LB15A         ;PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
CA0D  7ED635                    JMP  LBEE9         ;CHANGE SIGN OF FPA0 MANTISSA 
                                                     
                      * EVALUATE ALPHA EXPRESSION                      
CA10  BDCADE          LB284     JSR  LB357         ;FIND THE DESCRIPTOR ADDRESS OF A VARIABLE 
CA13  9F52            LB287     STX  FPA0+2        ;SAVE DESCRIPTOR ADDRESS IN FPA0 
CA15  9606                      LDA  VALTYP        ;TEST VARIABLE TYPE 
CA17  2695                      BNE  LB222         ;RETURN IF STRING 
CA19  7ED360                    JMP  LBC14         ;COPY A FP NUMBER FROM (X) TO FPA0 
                                                     
                      * EVALUATING A SECONDARY TOKEN                      
CA1C  9D7C            LB290     JSR  GETNCH        ;GET AN INPUT CHARACTER (SECONDARY TOKEN) 
CA1E  1F89                      TFR  A,B           ;SAVE IT IN ACCB 
CA20  58                        ASLB               ;X2 & BET RID OF BIT 7 
CA21  9D7C                      JSR  GETNCH        ;GET ANOTHER INPUT CHARACTER 
CA23  C138                      CMPB #(NUM_SEC_FNS-1)*2 ;29 SECONDARY FUNCTIONS - 1 
CA25  2303                      BLS  LB29F         ;BRANCH IF COLOR BASIC TOKEN 
CA27  7ECA03                    JMP  LB277         ;SYNTAX ERROR 
CA2A  3404            LB29F     PSHS B             ;SAVE TOKEN OFFSET ON STACK 
CA2C  C12A                      CMPB #(TOK_LEFT-$80)*2 ;CHECK FOR TOKEN WITH AN ARGUMENT 
CA2E  251E                      BCS  LB2C7         ;DO SECONDARIES STRING$ OR LESS 
CA30  C130                      CMPB #(TOK_INKEY-$80)*2 ;* 
CA32  241C                      BCC  LB2C9         ;* DO SECONDARIES $92 (INKEY$) OR > 
CA34  8DC0                      BSR  LB26A         ;SYNTAX CHECK FOR A '('
CA36  A6E4                      LDA  ,S            ;GET TOKEN NUMBER 
                      * DO SECONDARIES (LEFT$, RIGHT$, MID$)                      
CA38  BDC8E2                    JSR  LB156         ;EVALUATE FIRST STRING IN ARGUMENT 
CA3B  8DBC                      BSR  LB26D         ;SYNTAX CHECK FOR A COMMA 
CA3D  BDC8D2                    JSR  LB146         ;'TM' ERROR IF NUMERIC VARiABLE
CA40  3502                      PULS A             ;GET TOKEN OFFSET FROM STACK 
CA42  DE52                      LDU  FPA0+2        ;POINT U TO STRING DESCRIPTOR 
CA44  3442                      PSHS U,A           ;SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS 
CA46  BDCE92                    JSR  LB70B         ;EVALUATE FIRST NUMERIC ARGUMENT 
CA49  3502                      PULS A             ;GET TOKEN OFFSET FROM STACK 
CA4B  3406                      PSHS B,A           ;SAVE TOKEN OFFSET AND NUMERIC ARGUMENT 
CA4D  8E                        FCB  $8E           ;OP CODE OF LDX# - SKlP 2 BYTES 
CA4E  8D9E            LB2C7     BSR  LB262         ;SYNTAX CHECK FOR A '('
CA50  3504            LB2C9     PULS B             ;GET TOKEN OFFSET 
CA52  BEC0F4                    LDX  COMVEC+8      ;GET SECONDARY FUNCTION JUMP TABLE ADDRESS 
CA55  3A              LB2CE     ABX                ;ADD IN COMMAND OFFSET 
                      *                              
                      * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION                      
CA56  AD94                      JSR  [,X]          ;GO DO AN SECONDARY FUNCTION 
CA58  7EC8CF                    JMP  LB143         ;'TM' ERROR IF VARIABLE TYPE = STRING
                                                     
                      * LOGICAL OPERATOR 'OR' JUMPS;HERE
CA5B  86              LB2D4     FCB  SKP1LD        ;SKIP ONE BYTE - 'OR' FLAG = $4F
                                                     
                      * LOGICAL OPERATOR 'AND' JUMPS HERE
CA5C  4F              LB2D5     CLRA               ;AND FLAG = 0 
CA5D  9703                      STA  TMPLOC        ;AND/OR FLAG 
CA5F  BDCB74                    JSR  INTCNV        ;CONVERT FPA0 INTO AN INTEGER IN ACCD 
CA62  DD01                      STD  CHARAC        ;TEMP SAVE ACCD 
CA64  BDD396                    JSR  LBC4A         ;MOVE FPA1 TO FPA0 
CA67  BDCB74                    JSR  INTCNV        ;CONVERT FPA0 INTO AN INTEGER IN ACCD 
CA6A  0D03                      TST  TMPLOC        ;CHECK AND/OR FLAG 
CA6C  2606                      BNE  LB2ED         ;BRANCH IF OR 
CA6E  9401                      ANDA CHARAC        ;* 'AND' ACCD WITH FPA0 INTEGER
CA70  D402                      ANDB ENDCHR        ;* STORED IN ENDCHR 
CA72  2004                      BRA  LB2F1         ;CONVERT TO FP 
CA74  9A01            LB2ED     ORA  CHARAC        ;* 'OR' ACCD WITH FPA0 INTEGER
CA76  DA02                      ORB  ENDCHR        ;* STORED IN CHARAC 
CA78  7ECC7B          LB2F1     JMP  GIVABF        ;CONVERT THE VALUE IN ACCD INTO A FP NUMBER 
                                                     
                      * RELATIONAL COMPARISON PROCESS HANDLER                      
CA7B  BDC8D4          LB2F4     JSR  LB148         ;'TM' ERROR IF TYPE MISMATCH
CA7E  2610                      BNE  LB309         ;BRANCH IF STRING VARIABLE 
CA80  9661                      LDA  FP1SGN        ;* 'PACK' THE MANTISSA
CA82  8A7F                      ORA  #$7F          ;* SIGN OF FPA1 INTO 
CA84  945D                      ANDA FPA1          ;* BIT 7 OF THE 
CA86  975D                      STA  FPA1          ;* MANTISSA MS BYTE 
CA88  8E005C                    LDX  #FP1EXP       ;POINT X TO FPA1 
CA8B  BDD3E2                    JSR  LBC96         ;COMPARE FPA0 TO FPA1 
CA8E  2036                      BRA  LB33F         ;CHECK TRUTH OF RELATIONAL COMPARISON 
                                                     
                      * RELATIONAL COMPARISON OF STRINGS                      
CA90  0F06            LB309     CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
CA92  0A3F                      DEC  TRELFL        ;REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE 
                      *                            ;DESIRED RELATIONAL COMPARISON DATA 
CA94  BDCDDE                    JSR  LB657         ;GET LENGTH AND ADDRESS OF STRING WHOSE 
                      *                            ;DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0 
CA97  D756                      STB  STRDES        ;* SAVE LENGTH AND ADDRESS IN TEMPORARY 
CA99  9F58                      STX  STRDES+2      ;* DESCRIPTOR (STRING B) 
CA9B  9E5F                      LDX  FPA1+2        ;= RETURN LENGTH AND ADDRESS OF STRING 
CA9D  BDCDE0                    JSR  LB659         ;= WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2 
CAA0  9656                      LDA  STRDES        ;LOAD ACCA WITH LENGTH OF STRING B 
CAA2  3404                      PSHS B             ;SAVE LENGTH A ON STACK 
CAA4  A0E0                      SUBA ,S+           ;SUBTRACT LENGTH A FROM LENGTH B 
CAA6  2707                      BEQ  LB328         ;BRANCH IF STRINGS OF EQUAL LENGTH 
CAA8  8601                      LDA  #1            ;TRUE FLAG 
CAAA  2403                      BCC  LB328         ;TRUE IF LENGTH B > LENGTH A 
CAAC  D656                      LDB  STRDES        ;LOAD ACCB WITH LENGTH B 
CAAE  40                        NEGA               ;SET FLAG = FALSE (1FF) 
CAAF  9754            LB328     STA  FP0SGN        ;SAVE TRUE/FALSE FLAG 
CAB1  DE58                      LDU  STRDES+2      ;POINT U TO START OF STRING 
CAB3  5C                        INCB               ;COMPENSATE FOR THE DECB BELOW 
                      * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING                      
CAB4  5A              LB32D     DECB               ;DECREMENT SHORTER STRING LENGTH 
CAB5  2604                      BNE  LB334         ;BRANCH IF ALL OF STRING NOT COMPARED 
CAB7  D654                      LDB  FP0SGN        ;GET TRUE/FALSE FLAB 
CAB9  200B                      BRA  LB33F         ;CHECK TRUTH OF RELATIONAL COMPARISON 
CABB  A680            LB334     LDA  ,X+           ;GET A BYTE FROM STRING A 
CABD  A1C0                      CMPA ,U+           ;COMPARE TO STRING B 
CABF  27F3                      BEQ  LB32D         ;CHECK ANOTHER CHARACTER IF = 
CAC1  C6FF                      LDB  #$FF          ;FALSE FLAG IF STRING A > B 
CAC3  2401                      BCC  LB33F         ;BRANCH IF STRING A > STRING B 
CAC5  50                        NEGB               ;SET FLAG = TRUE 
                                                     
                      * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0                      
CAC6  CB01            LB33F     ADDB #1            ;CONVERT $FF,0,1 TO 0,1,2 
CAC8  59                        ROLB               ;NOW IT'S 1,2,4 FOR > = <
CAC9  D40A                      ANDB RELFLG        ;'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
CACB                  COMPARISON                      
CACB  2702                      BEQ  LB348         ;BRANCH IF FALSE (NO MATCHING BITS) 
CACD  C6FF                      LDB  #$FF          ;TRUE FLAG 
CACF  7ED3C8          LB348     JMP  LBC7C         ;CONVERT ACCB INTO FP NUMBER IN FPA0 
                                                     
                      * DIM                          
CAD2  BDC9F9          LB34B     JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
CAD5  C601            DIM       LDB  #1            ;DIMENSION FLAG 
CAD7  8D08                      BSR  LB35A         ;SAVE ARRAY SPACE FOR THIS VARIABLE 
CAD9  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
CADB  26F5                      BNE  LB34B         ;KEEP DIMENSIONING IF NOT END OF LINE 
CADD  39                        RTS                  
                      * EVALUATE A VARIABLE - RETURN X AND                      
                      * VARPTR POINTING TO VARIABLE;DESCRIPTOR                      
                      * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO                      
                      * BYTES ARE THE VARIABLE NAME;AND THE NEXT 5                      
                      * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE                      
                      * FIRST BYTE OF VARlABLE NAME;IS SET, THE                      
                      * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF                      
                      * THE SECOND BYTE OF VARIABLE;NAME IS SET, THE                      
                      * VARIABLE IS A STRING, OTHERWISE THE VARIABLE                      
                      * IS NUMERIC.                      
                      * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS                      
                      * INSERTED INTO THE VARIABLE SPACE                      
CADE  5F              LB357     CLRB               ;DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY 
CADF  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
CAE1  D705            LB35A     STB  DIMFLG        ;SAVE ARRAY FLAG 
                      * ENTRY POINT FOR DEF FN VARIABLE SEARCH                      
CAE3  9737            LB35C     STA  VARNAM        ;SAVE INPUT CHARACTER 
CAE5  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
CAE7  8D40                      BSR  LB3A2         ;SET CARRY IF NOT ALPHA 
CAE9  1025FF16                  LBCS LB277         ;SYNTAX ERROR IF NOT ALPHA 
CAED  5F                        CLRB               ;DEFAULT 2ND VARIABLE CHARACTER TO ZERO 
CAEE  D706                      STB  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
CAF0  9D7C                      JSR  GETNCH        ;GET ANOTHER CHARACTER FROM BASIC 
CAF2  2504                      BCS  LB371         ;BRANCH IF NUMERIC (2ND CHARACTER IN 
                      *                            ;VARIABLE MAY BE NUMERIC) 
CAF4  8D33                      BSR  LB3A2         ;SET CARRY IF NOT ALPHA 
CAF6  250A                      BCS  LB37B         ;BRANCH IF NOT ALPHA 
CAF8  1F89            LB371     TFR  A,B           ;SAVE 2ND CHARACTER IN ACCB 
                      * READ INPUT CHARACTERS UNTIL;A NON ALPHA OR                      
                      * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS                      
                      * IN VARIABLE NAME AFTER THE 1ST TWO                      
CAFA  9D7C            LB373     JSR  GETNCH        ;GET AN INPUT CHARACTER 
CAFC  25FC                      BCS  LB373         ;BRANCH IF NUMERIC 
CAFE  8D29                      BSR  LB3A2         ;SET CARRY IF NOT ALPHA 
CB00  24F8                      BCC  LB373         ;BRANCH IF ALPHA 
CB02  8124            LB37B     CMPA #'$           ;CHECK FOR A STRING VARIABLE 
CB04  2606                      BNE  LB385         ;BRANCH IF IT IS NOT A STRING 
CB06  0306                      COM  VALTYP        ;SET VARIABLE TYPE TO STRING 
CB08  CB80                      ADDB #$80          ;SET BIT 7 OF 2ND CHARACTER (STRING) 
CB0A  9D7C                      JSR  GETNCH        ;GET AN INPUT CHARACTER 
CB0C  D738            LB385     STB  VARNAM+1      ;SAVE 2ND CHARACTER IN VARNAM+1 
CB0E  9A08                      ORA  ARYDIS        ;OR IN THE ARRAY DISABLE FLAG - IF = $80, 
                      *              DON'T SEARCH FOR VARIABLES IN THE ARRAYS
CB10  8028                      SUBA #'(           ;IS THIS AN ARRAY VARIABLE? 
CB12  10270075                  LBEQ LB404         ;BRANCH IF IT IS 
CB16  0F08                      CLR  ARYDIS        ;RESET THE ARRAY DISABLE FLAG 
CB18  9E1B                      LDX  VARTAB        ;POINT X TO THE START OF VARIABLES 
CB1A  DC37                      LDD  VARNAM        ;GET VARIABLE IN QUESTION 
CB1C  9C1D            LB395     CMPX ARYTAB        ;COMPARE X TO THE END OF VARIABLES 
CB1E  2712                      BEQ  LB3AB         ;BRANCH IF END OF VARIABLES 
CB20  10A381                    CMPD ,X++          ;* COMPARE VARIABLE IN QUESTION TO CURRENT 
CB23  273E                      BEQ  LB3DC         ;* VARIABLE AND BRANCH IF MATCH 
CB25  3005                      LEAX 5,X           ;= MOVE POINTER TO NEXT VARIABLE AND 
CB27  20F3                      BRA  LB395         ;= KEEP LOOKING 
                                                     
                      * SET CARRY IF NOT UPPER CASE;ALPHA                      
CB29  8141            LB3A2     CMPA #'A           ;* CARRY SET IF < 'A'
CB2B  2504                      BCS  LB3AA         ;* 
CB2D  805B                      SUBA #'Z+1         ;= 
                      *         SUBA #-('Z+1)      ;= CARRY CLEAR IF <= 'Z' 
CB2F  80A5                      FCB  $80,$A5         
CB31  39              LB3AA     RTS                  
                      * PUT A NEW VARIABLE IN TABLE;OF VARIABLES                      
CB32  8E0074          LB3AB     LDX  #ZERO         ;POINT X TO ZERO LOCATION 
CB35  EEE4                      LDU  ,S            ;GET CURRENT RETURN ADDRESS 
CB37  1183CA13                  CMPU #LB287        ;DID WE COME FROM 'EVALUATE ALPHA EXPR'?
CB3B  2728                      BEQ  LB3DE         ;YES - RETURN A ZERO VALUE 
CB3D  DC1F                      LDD  ARYEND        ;* GET END OF ARRAYS ADDRESS AND 
CB3F  DD43                      STD  V43           ;* SAVE IT AT V43 
CB41  C30007                    ADDD #7            ;= ADD 7 TO END OF ARRAYS (EACH 
CB44  DD41                      STD  V41           ;= VARIABLE = 7 BYTES) AND SAVE AT V41 
CB46  9E1D                      LDX  ARYTAB        ;* GET END OF VARIABLES AND SAVE AT V47 
CB48  9F47                      STX  V47           ;* 
CB4A  BDC3DB                    JSR  LAC1E         ;MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT 
                      *         TOP  OF VARIABLES    
CB4D  9E41                      LDX  V41           ;= GET NEW END OF ARRAYS AND SAVE IT 
CB4F  9F1F                      STX  ARYEND        ;= 
CB51  9E45                      LDX  V45           ;* GET NEW END OF VARIABLES AND SAVE IT 
CB53  9F1D                      STX  ARYTAB        ;* 
CB55  9E47                      LDX  V47           ;GET OLD END OF VARIABLES 
CB57  DC37                      LDD  VARNAM        ;GET NEW VARIABLE NAME 
CB59  ED81                      STD  ,X++          ;SAVE VARIABLE NAME 
CB5B  4F                        CLRA               ;* ZERO OUT THE FP VALUE OF THE NUMERIC 
CB5C  5F                        CLRB               ;* VARIABLE OR THE LENGTH AND ADDRESS 
CB5D  ED84                      STD  ,X            ;* OF A STRING VARIABLE 
CB5F  ED02                      STD  2,X           ;* 
CB61  A704                      STA  4,X           ;* 
CB63  9F39            LB3DC     STX  VARPTR        ;STORE ADDRESS OF VARIABLE VALUE 
CB65  39              LB3DE     RTS                  
                      *                              
CB66  9080000000      LB3DF     FCB  $90,$80,$00,$00,$00 ;* FLOATING POINT -32768 
                      *                            ;SMALLEST SIGNED TWO BYTE INTEGER 
                      *                              
CB6B  9D7C            LB3E4     JSR  GETNCH        ;GET AN INPUT CHARACTER FROM BASIC 
CB6D  BDC8CD          LB3E6     JSR  LB141         ;GO EVALUATE NUMERIC EXPRESSION 
CB70  9654            LB3E9     LDA  FP0SGN        ;GET FPA0 MANTISSA SIGN 
CB72  2B5D                      BMI  LB44A         ;'FC' ERROR IF NEGATIVE NUMBER
                                                     
                                                     
CB74  BDC8CF          INTCNV    JSR  LB143         ;'TM' ERROR IF STRING VARIABLE
CB77  964F                      LDA  FP0EXP        ;GET FPA0 EXPONENT 
CB79  8190                      CMPA #$90          ;* COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND 
CB7B  2508                      BCS  LB3FE         ;* BRANCH IF FPA0 < 32768 
CB7D  8ECB66                    LDX  #LB3DF        ;POINT X TO FP VALUE OF -32768 
CB80  BDD3E2                    JSR  LBC96         ;COMPARE -32768 TO FPA0 
CB83  264C                      BNE  LB44A         ;'FC' ERROR IF NOT =
CB85  BDD414          LB3FE     JSR  LBCC8         ;CONVERT FPA0 TO A TWO BYTE INTEGER 
CB88  DC52                      LDD  FPA0+2        ;GET THE INTEGER 
CB8A  39                        RTS                  
                      * EVALUATE AN ARRAY VARIABLE                      
CB8B  DC05            LB404     LDD  DIMFLG        ;GET ARRAY FLAG AND VARIABLE TYPE 
CB8D  3406                      PSHS B,A           ;SAVE THEM ON STACK 
CB8F  12                        NOP                ;DEAD SPACE CAUSED BY 1.2 REVISION 
CB90  5F                        CLRB               ;RESET DIMENSION COUNTER 
CB91  9E37            LB40A     LDX  VARNAM        ;GET VARIABLE NAME 
CB93  3414                      PSHS X,B           ;SAVE VARIABLE NAME AND DIMENSION COUNTER 
CB95  8DD4                      BSR  LB3E4         ;EVALUATE EXPRESSION (DIMENSlON LENGTH) 
CB97  3534                      PULS B,X,Y         ;PULL OFF VARIABLE NAME, DIMENSlON COUNTER, 
                      *                            ;ARRAY FLAG 
CB99  9F37                      STX  VARNAM        ;SAVE VARIABLE NAME AND VARIABLE TYPE 
CB9B  DE52                      LDU  FPA0+2        ;GET DIMENSION LENGTH 
CB9D  3460                      PSHS U,Y           ;SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE 
CB9F  5C                        INCB               ;INCREASE DIMENSION COUNTER 
CBA0  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
CBA2  812C                      CMPA #',           ;CHECK FOR ANOTHER DIMENSION 
CBA4  27EB                      BEQ  LB40A         ;BRANCH IF MORE 
CBA6  D703                      STB  TMPLOC        ;SAVE DIMENSION COUNTER 
CBA8  BDC9F3                    JSR  LB267         ;SYNTAX CHECK FOR A ')'
CBAB  3506                      PULS A,B           ;* RESTORE VARIABLE TYPE AND ARRAY 
CBAD  DD05                      STD  DIMFLG        ;* FLAG - LEAVE DIMENSION LENGTH ON STACK 
CBAF  9E1D                      LDX  ARYTAB        ;GET START OF ARRAYS 
CBB1  9C1F            LB42A     CMPX ARYEND        ;COMPARE TO END OF ARRAYS 
CBB3  2721                      BEQ  LB44F         ;BRANCH IF NO MATCH FOUND 
CBB5  DC37                      LDD  VARNAM        ;GET VARIABLE IN QUESTION 
CBB7  10A384                    CMPD ,X            ;COMPARE TO CURRENT VARIABLE 
CBBA  2706                      BEQ  LB43B         ;BRANCH IF = 
CBBC  EC02                      LDD  2,X           ;GET OFFSET TO NEXT ARRAY VARIABLE 
CBBE  308B                      LEAX D,X           ;ADD TO CURRENT POINTER 
CBC0  20EF                      BRA  LB42A         ;KEEP SEARCHING 
CBC2  C612            LB43B     LDB  #2*9          ;'REDIMENSIONED ARRAY' ERROR
CBC4  9605                      LDA  DIMFLG        ;* TEST ARRAY FLAG - IF <>0 YOU ARE TRYING 
CBC6  260B                      BNE  LB44C         ;* TO REDIMENSION AN ARRAY 
CBC8  D603                      LDB  TMPLOC        ;GET NUMBER OF DIMENSIONS IN ARRAY 
CBCA  E104                      CMPB 4,X           ;COMPARE TO THIS ARRAYS DIMENSIONS 
CBCC  2759                      BEQ  LB4A0         ;BRANCH IF = 
CBCE  C610            LB447     LDB  #8*2          ;'BAD SUBSCRIPT'
CBD0  8C                        FCB  SKP2          ;SKIP TWO BYTES 
CBD1  C608            LB44A     LDB  #4*2          ;'ILLEGAL FUNCTION CALL'
CBD3  7EC403          LB44C     JMP  LAC46         ;JUMP TO ERROR SERVICING ROUTINE 
                                                     
                      * INSERT A NEW ARRAY INTO ARRAY VARIABLES                      
                      * EACH SET OF ARRAY VARIABLES;IS PRECEEDED BY A DE-                      
                      * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE                      
                      * NUMBER OF DIMENSIONS IN THE;ARRAY. THE BLOCK IS DEFINED                      
                      * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
                      * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-                      
                      * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-                      
                      * SION 2;' 4+N,5+N:LENGTH OF DIMENSION N.
                                                     
CBD6  CC0005          LB44F     LDD  #5            ;* 5 BYTES/ARRAY ENTRY SAVE AT COEFPT 
CBD9  DD64                      STD  COEFPT        ;* 
CBDB  DC37                      LDD  VARNAM        ;= GET NAME OF ARRAY AND SAVE IN 
CBDD  ED84                      STD  ,X            ;= FIRST 2 BYTES OF DESCRIPTOR 
CBDF  D603                      LDB  TMPLOC        ;GET NUMBER OF DIMENSIONS AND SAVE IN 
CBE1  E704                      STB  4,X           ;* 5TH BYTE OF DESCRIPTOR 
CBE3  BDC3F0                    JSR  LAC33         ;CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM 
CBE6  9F41                      STX  V41           ;TEMPORARILY SAVE DESCRIPTOR ADDRESS 
CBE8  C60B            LB461     LDB  #11           ;* DEFAULT DIMENSION VALUE:X(10) 
CBEA  4F                        CLRA               ;* 
CBEB  0D05                      TST  DIMFLG        ;= CHECK ARRAY FLAG AND BRANCH IF 
CBED  2705                      BEQ  LB46D         ;= NOT DIMENSIONING AN ARRAY 
CBEF  3506                      PULS A,B           ;GET DIMENSION LENGTH 
CBF1  C30001                    ADDD #1            ;ADD ONE (X(0) HAS A LENGTH OF ONE) 
CBF4  ED05            LB46D     STD  5,X           ;SAVE LENGTH OF ARRAY DIMENSION 
CBF6  8D5D                      BSR  LB4CE         ;MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH 
                      *                            ;OF NEW DIMENSION 
CBF8  DD64                      STD  COEFPT        ;TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE 
CBFA  3002                      LEAX 2,X           ;BUMP POINTER UP TWO 
CBFC  0A03                      DEC  TMPLOC        ;* DECREMENT DIMENSION COUNTER AND BRANCH IF 
CBFE  26E8                      BNE  LB461         ;* NOT DONE WITH ALL DIMENSIONS 
CC00  9F0F                      STX  TEMPTR        ;SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5) 
CC02  D30F                      ADDD TEMPTR        ;ADD TOTAL SIZE OF NEW ARRAY 
CC04  1025F7F9                  LBCS LAC44         ;'OM' ERROR IF > $FFFF
CC08  1F01                      TFR  D,X           ;SAVE END OF ARRAY IN X 
CC0A  BDC3F4                    JSR  LAC37         ;MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY 
CC0D  830035                    SUBD #STKBUF-5     ;SUBTRACT OUT THE (STACK BUFFER - 5) 
CC10  DD1F                      STD  ARYEND        ;SAVE NEW END OF ARRAYS 
CC12  4F                        CLRA               ;ZERO = TERMINATOR BYTE 
CC13  301F            LB48C     LEAX -1,X          ;* STORE TWO TERMINATOR BYTES AT 
CC15  A705                      STA  5,X           ;* THE END OF THE ARRAY DESCRIPTOR 
CC17  9C0F                      CMPX TEMPTR        ;* 
CC19  26F8                      BNE  LB48C         ;* 
CC1B  9E41                      LDX  V41           ;GET ADDRESS OF START OF DESCRIPTOR 
CC1D  961F                      LDA  ARYEND        ;GET MSB OF END OF ARRAYS; LSB ALREADY THERE 
CC1F  9341                      SUBD V41           ;SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR 
CC21  ED02                      STD  2,X           ;SAVE LENGTH OF (ARRAY AND DESCRIPTOR) 
CC23  9605                      LDA  DIMFLG        ;* GET ARRAY FLAG AND BRANCH 
CC25  262D                      BNE  LB4CD         ;* BACK IF DIMENSIONING 
                      * CALCULATE POINTER TO CORRECT ELEMENT                      
CC27  E604            LB4A0     LDB  4,X           ;GET THE NUMBER OF DIMENSIONS 
CC29  D703                      STB  TMPLOC        ;TEMPORARILY SAVE 
CC2B  4F                        CLRA               ;* INITIALIZE POINTER 
CC2C  5F                        CLRB               ;* TO ZERO 
CC2D  DD64            LB4A6     STD  COEFPT        ;SAVE ACCUMULATED POINTER 
CC2F  3506                      PULS A,B           ;* PULL DIMENSION ARGUMENT OFF THE 
CC31  DD52                      STD  FPA0+2        ;* STACK AND SAVE IT 
CC33  10A305                    CMPD 5,X           ;COMPARE TO STORED 'DIM' ARGUMENT
CC36  243A                      BCC  LB4EB         ;'BS' ERROR IF > = "DIM" ARGUMENT
CC38  DE64                      LDU  COEFPT        ;* GET ACCUMULATED POINTER AND 
CC3A  2704                      BEQ  LB4B9         ;* BRANCH IF 1ST DIMENSION 
CC3C  8D17                      BSR  LB4CE         ;= MULTIPLY ACCUMULATED POINTER AND DIMENSION 
CC3E  D352                      ADDD FPA0+2        ;= LENGTH AND ADD TO CURRENT ARGUMENT 
CC40  3002            LB4B9     LEAX 2,X           ;MOVE POINTER TO NEXT DIMENSION 
CC42  0A03                      DEC  TMPLOC        ;* DECREMENT DIMENSION COUNTER AND 
CC44  26E7                      BNE  LB4A6         ;* BRANCH IF ANY DIMENSIONS LEFT 
                      * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE                      
CC46  EDE3                      STD  ,--S            
CC48  58                        ASLB                 
CC49  49                        ROLA               ;TIMES 2 
CC4A  58                        ASLB                 
CC4B  49                        ROLA               ;TIMES 4 
CC4C  E3E1                      ADDD ,S++          ;TIMES 5 
CC4E  308B                      LEAX D,X           ;ADD OFFSET TO START OF ARRAY 
CC50  3005                      LEAX 5,X           ;ADJUST POINTER FOR SIZE OF DESCRIPTOR 
CC52  9F39                      STX  VARPTR        ;SAVE POINTER TO ARRAY VALUE 
CC54  39              LB4CD     RTS                  
                      * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER                      
                      * IN COEFPT. RETURN RESULT IN;ACCD, BS ERROR IF > $FFFF                      
CC55  8610            LB4CE     LDA  #16           ;16 SHIFTS TO DO A MULTIPLY 
CC57  9745                      STA  V45           ;SHIFT COUNTER 
CC59  EC05                      LDD  5,X           ;* GET SIZE OF DIMENSION 
CC5B  DD17                      STD  BOTSTK        ;* AND SAVE IT 
CC5D  4F                        CLRA               ;* ZERO 
CC5E  5F                        CLRB               ;* ACCD 
CC5F  58              LB4D8     ASLB               ;= SHIFT ACCB LEFT 
CC60  49                        ROLA               ;= ONE BIT 
CC61  250F                      BCS  LB4EB         ;BS' ERROR IF CARRY 
CC63  0865                      ASL  COEFPT+1      ;* SHIFT MULTIPLICAND LEFT ONE 
CC65  0964                      ROL  COEFPT        ;* BIT - ADD MULTIPLIER TO ACCUMULATOR 
CC67  2404                      BCC  LB4E6         ;* IF CARRY <> 0 
CC69  D317                      ADDD BOTSTK        ;ADD MULTIPLIER TO ACCD 
CC6B  2505                      BCS  LB4EB         ;BS' ERROR IF CARRY (>$FFFF) 
CC6D  0A45            LB4E6     DEC  V45           ;* DECREMENT SHIFT COUNTER 
CC6F  26EE                      BNE  LB4D8         ;* IF NOT DONE 
CC71  39                        RTS                  
CC72  7ECBCE          LB4EB     JMP  LB447         ;BS' ERROR 
                      *                              
                      * MEM                          
                      * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE                      
                      * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK                      
                      * FOR WHICH MEM DOES NOT ALLOW.                      
                      *                              
CC75  1F40            MEM       TFR  S,D           ;PUT STACK POINTER INTO ACCD 
CC77  931F                      SUBD ARYEND        ;SUBTRACT END OF ARRAYS 
CC79  21                        FCB  SKP1          ;SKIP ONE BYTE 
                      *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0                      
CC7A  4F              LB4F3     CLRA               ;CLEAR MS BYTE OF ACCD 
                      * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0                      
CC7B  0F06            GIVABF    CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
CC7D  DD50                      STD  FPA0          ;SAVE ACCD IN TOP OF FACA 
CC7F  C690                      LDB  #$90          ;EXPONENT REQUIRED IF THE TOP TWO BYTES 
                      *         OF   FPA0 ARE TO BE;TREATED AS AN INTEGER IN FPA0  
CC81  7ED3CE                    JMP  LBC82         ;CONVERT THE REST OF FPA0 TO AN INTEGER 
                                                     
                      * STR$                         
CC84  BDC8CF          STR       JSR  LB143         ;TM' ERROR IF STRING VARIABLE 
CC87  CE01F0                    LDU  #STRBUF+2     ;*CONVERT FP NUMBER TO ASCII STRING IN 
CC8A  BDD528                    JSR  LBDDC         ;*THE STRING BUFFER 
CC8D  3262                      LEAS 2,S           ;PURGE THE RETURN ADDRESS FROM THE STACK 
CC8F  8E01EF                    LDX  #STRBUF+1     ;*POINT X TO STRING BUFFER AND SAVE 
CC92  200B                      BRA  LB518         ;*THE STRING IN THE STRING SPACE 
                      * RESERVE ACCB BYTES OF STRING SPACE. RETURN START                      
                      * ADDRESS IN (X) AND FRESPC                      
CC94  9F4D            LB50D     STX  V4D           ;SAVE X IN V4D 
CC96  8D5C            LB50F     BSR  LB56D         ;RESERVE ACCB BYTES IN STRING SPACE 
CC98  9F58            LB511     STX  STRDES+2      ;SAVE NEW STRING ADDRESS 
CC9A  D756                      STB  STRDES        ;SAVE LENGTH OF RESERVED BLOCK 
CC9C  39                        RTS                  
CC9D  301F            LB516     LEAX -1,X          ;MOVE POINTER BACK ONE 
                      * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR                      
                      * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.                      
                      * THE RESULTING STRING IS STORED IN THE STRING SPACE                      
                      * ONLY IF THE START OF THE STRING IS <= STRBUF+2                      
CC9F  8622            LB518     LDA  #'"           ;* INITIALIZE 
CCA1  9701                      STA  CHARAC        ;* TERMINATORS 
CCA3  9702            LB51A     STA  ENDCHR        ;* TO " 
CCA5  3001            LB51E     LEAX 1,X           ;MOVE POINTER UP ONE 
CCA7  9F62                      STX  RESSGN        ;TEMPORARILY SAVE START OF STRING 
CCA9  9F58                      STX  STRDES+2      ;SAVE START OF STRING IN TEMP DESCRIPTOR 
CCAB  C6FF                      LDB  #-1           ;INITIALIZE CHARACTER COUNTER TO - 1 
CCAD  5C              LB526     INCB               ;INCREMENT CHARACTER COUNTER 
CCAE  A680                      LDA  ,X+           ;GET CHARACTER 
CCB0  270C                      BEQ  LB537         ;BRANCH IF END OF LINE 
CCB2  9101                      CMPA CHARAC        ;* CHECK FOR TERMINATORS 
CCB4  2704                      BEQ  LB533         ;* IN CHARAC AND ENDCHR 
CCB6  9102                      CMPA ENDCHR        ;* DON'T MOVE POINTER BACK
CCB8  26F3                      BNE  LB526         ;* ONE IF TERMINATOR IS "MATCHED" 
CCBA  8122            LB533     CMPA #'"           ;= COMPARE CHARACTER TO STRING DELIMITER 
CCBC  2702                      BEQ  LB539         ;= & DON'T MOVE POINTER BACK IF SO
CCBE  301F            LB537     LEAX -1,X          ;MOVE POINTER BACK ONE 
CCC0  9F64            LB539     STX  COEFPT        ;SAVE END OF STRING ADDRESS 
CCC2  D756                      STB  STRDES        ;SAVE STRING LENGTH IN TEMP DESCRIPTOR 
CCC4  DE62                      LDU  RESSGN        ;GET INITlAL STRING START 
CCC6  118301F0                  CMPU #STRBUF+2     ;COMPARE TO START OF STRING BUFFER 
CCCA  2207            LB543     BHI  LB54C         ;BRANCH IF > START OF STRING BUFFER 
CCCC  8DC6                      BSR  LB50D         ;GO RESERVE SPACE FOR THE STRING 
CCCE  9E62                      LDX  RESSGN        ;POINT X TO THE BEGINNING OF THE STRING 
CCD0  BDCDCC                    JSR  LB645         ;MOVE (B) BYTES FROM (X) TO 
                      *                            ;[FRESPC] - MOVE STRING DATA 
                      * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA                      
                      * ON THE STRING STACK. SET VARIABLE TYPE TO STRING                      
CCD3  9E0B            LB54C     LDX  TEMPPT        ;GET NEXT AVAILABLE STRING STACK DESCRIPTOR 
CCD5  8C00F1                    CMPX #LINHDR       ;COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF 
CCD8  2605                      BNE  LB558         ;FORMULA O.K. 
CCDA  C61E                      LDB  #15*2         ;STRING FORMULA TOO COMPLEX' ERROR 
CCDC  7EC403          LB555     JMP  LAC46         ;JUMP TO ERROR SERVICING ROUTINE 
CCDF  9656            LB558     LDA  STRDES        ;* GET LENGTH OF STRING AND SAVE IT 
                      *         STA  ,X            ;* IN BYTE 0 OF DESCRIPTOR 
CCE1  A700                      FCB  $A7,$00         
CCE3  DC58                      LDD  STRDES+2      ;= GET START ADDRESS OF ACTUAL STRING 
CCE5  ED02                      STD  2,X           ;= AND SAVE IN BYTES 2,3 OF DESCRIPTOR 
CCE7  86FF                      LDA  #$FF          ;* VARIABLE TYPE = STRING 
CCE9  9706                      STA  VALTYP        ;* SAVE IN VARIABLE TYPE FLAG 
CCEB  9F0D                      STX  LASTPT        ;= SAVE START OF DESCRIPTOR 
CCED  9F52                      STX  FPA0+2        ;= ADDRESS IN LASTPT AND FPA0 
CCEF  3005                      LEAX 5,X           ;5 BYTES/STRING DESCRIPTOR 
CCF1  9F0B                      STX  TEMPPT        ;NEXT AVAILABLE STRING VARIABLE DESCRIPTOR 
CCF3  39                        RTS                  
                      * RESERVE ACCB BYTES IN STRING STORAGE SPACE                      
                      * RETURN WITH THE STARTING ADDRESS OF THE                      
                      * RESERVED STRING SPACE IN (X) AND FRESPC                      
CCF4  0F07            LB56D     CLR  GARBFL        ;CLEAR STRING REORGANIZATION FLAG 
CCF6  4F              LB56F     CLRA               ;* PUSH THE LENGTH OF THE 
CCF7  3406                      PSHS B,A           ;* STRING ONTO THE STACK 
CCF9  DC23                      LDD  STRTAB        ;GET START OF STRING VARIABLES 
CCFB  A3E0                      SUBD ,S+           ;SUBTRACT STRING LENGTH 
CCFD  109321                    CMPD FRETOP        ;COMPARE TO START OF STRING STORAGE 
CD00  250A                      BCS  LB585         ;IF BELOW START, THEN REORGANIZE 
CD02  DD23                      STD  STRTAB        ;SAVE NEW START OF STRING VARIABLES 
CD04  9E23                      LDX  STRTAB        ;GET START OF STRING VARIABLES 
CD06  3001                      LEAX 1,X           ;ADD ONE 
CD08  9F25                      STX  FRESPC        ;SAVE START ADDRESS OF NEWLY RESERVED SPACE 
CD0A  3584                      PULS B,PC          ;RESTORE NUMBER OF BYTES RESERVED AND RETURN 
CD0C  C61A            LB585     LDB  #2*13         ;OUT OF STRING SPACE' ERROR 
CD0E  0307                      COM  GARBFL        ;TOGGLE REORGANIZATiON FLAG 
CD10  27CA                      BEQ  LB555         ;ERROR IF FRESHLY REORGANIZED 
CD12  8D04                      BSR  LB591         ;GO REORGANIZE STRING SPACE 
CD14  3504                      PULS B             ;GET BACK THE NUMBER OF BYTES TO RESERVE 
CD16  20DE                      BRA  LB56F         ;TRY TO RESERVE ACCB BYTES AGAIN 
                      * REORGANIZE THE STRING SPACE                      
CD18  9E27            LB591     LDX  MEMSIZ        ;GET THE TOP OF STRING SPACE 
CD1A  9F23            LB593     STX  STRTAB        ;SAVE TOP OF UNORGANIZED STRING SPACE 
CD1C  4F                        CLRA               ;* ZERO OUT ACCD 
CD1D  5F                        CLRB               ;* AND RESET VARIABLE 
CD1E  DD4B                      STD  V4B           ;* POINTER TO 0 
CD20  9E21                      LDX  FRETOP        ;POINT X TO START OF STRING SPACE 
CD22  9F47                      STX  V47           ;SAVE POINTER IN V47 
CD24  8E00C9                    LDX  #STRSTK       ;POINT X TO START OF STRING DESCRIPTOR STACK 
CD27  9C0B            LB5A0     CMPX TEMPPT        ;COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR 
CD29  2704                      BEQ  LB5A8         ;BRANCH IF TOP OF STRING STACK 
CD2B  8D32                      BSR  LB5D8         ;CHECK FOR STRING IN UNORGANIZED STRING SPACE 
CD2D  20F8                      BRA  LB5A0         ;KEEP CHECKING 
CD2F  9E1B            LB5A8     LDX  VARTAB        ;GET THE END OF BASIC PROGRAM 
CD31  9C1D            LB5AA     CMPX ARYTAB        ;COMPARE TO END OF VARIABLES 
CD33  2704                      BEQ  LB5B2         ;BRANCH IF AT TOP OF VARIABLES 
CD35  8D22                      BSR  LB5D2         ;CHECK FOR STRING IN UNORGANIZED STRING SPACE 
CD37  20F8                      BRA  LB5AA         ;KEEP CHECKING VARIABLES 
CD39  9F41            LB5B2     STX  V41           ;SAVE ADDRESS OF THE END OF VARIABLES 
CD3B  9E41            LB5B4     LDX  V41           ;GET CURRENT ARRAY POINTER 
CD3D  9C1F            LB5B6     CMPX ARYEND        ;COMPARE TO THE END OF ARRAYS 
CD3F  2735                      BEQ  LB5EF         ;BRANCH IF AT END OF ARRAYS 
CD41  EC02                      LDD  2,X           ;GET LENGTH OF ARRAY AND DESCRIPTOR 
CD43  D341                      ADDD V41           ;* ADD TO CURRENT ARRAY POINTER 
CD45  DD41                      STD  V41           ;* AND SAVE IT 
CD47  A601                      LDA  1,X           ;GET 1ST CHARACTER OF VARIABLE NAME 
CD49  2AF0                      BPL  LB5B4         ;BRANCH IF NUMERIC ARRAY 
CD4B  E604                      LDB  4,X           ;GET THE NUMBER OF DIMENSIONS IN THIS ARRAY 
CD4D  58                        ASLB               ;MULTIPLY BY 2 
CD4E  CB05                      ADDB #5            ;ADD FIVE BYTES (VARIABLE NAME, ARRAY 
                      *                            ;LENGTH, NUMBER DIMENSIONS) 
CD50  3A                        ABX                ;X NOW POINTS TO START OF ARRAY ELEMENTS 
CD51  9C41            LB5CA     CMPX V41           ;AT END OF THIS ARRAY? 
CD53  27E8                      BEQ  LB5B6         ;YES - CHECK FOR ANOTHER 
CD55  8D08                      BSR  LB5D8         ;CHECK FOR STRING LOCATED IN 
                      *                            ;UNORGANIZED STRING SPACE 
CD57  20F8                      BRA  LB5CA         ;KEEP CHECKING ELEMENTS IN THIS ARRAY 
CD59  A601            LB5D2     LDA  1,X           ;GET F1RST BYTE OF VARIABLE NAME 
CD5B  3002                      LEAX 2,X           ;MOVE POINTER TO DESCRIPTOR 
CD5D  2A14                      BPL  LB5EC         ;BRANCH IF VARIABLE IS NUMERIC 
                      * SEARCH FOR STRING - ENTER WITH X POINTING TO                      
                      * THE STRING DESCRIPTOR. IF STRING IS STORED                      
                      * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER                      
                      * IN V4B AND RESET V47 TO STRING ADDRESS                      
CD5F  E684            LB5D8     LDB  ,X            ;GET THE LENGTH OF THE STRING 
CD61  2710                      BEQ  LB5EC         ;BRANCH IF NULL - NO STRING 
CD63  EC02                      LDD  2,X           ;GET STARTING ADDRESS OF THE STRING 
CD65  109323                    CMPD STRTAB        ;COMPARE TO THE START OF STRING VARIABLES 
CD68  2209                      BHI  LB5EC         ;BRANCH IF THIS STRING IS STORED IN 
                      *              THE STRING VARIABLES  
CD6A  109347                    CMPD V47           ;COMPARE TO START OF STRING SPACE 
CD6D  2304                      BLS  LB5EC         ;BRANCH IF NOT STORED IN THE STRING SPACE 
CD6F  9F4B                      STX  V4B           ;SAVE VARIABLE POINTER IF STORED IN STRING SPACE 
CD71  DD47                      STD  V47           ;SAVE STRING STARTING ADDRESS 
CD73  3005            LB5EC     LEAX 5,X           ;MOVE TO NEXT VARIABLE DESCRIPTOR 
CD75  39              LB5EE     RTS                  
CD76  9E4B            LB5EF     LDX  V4B           ;GET ADDRESS OF THE DESCRIPTOR FOR THE 
                      *              STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN  
                      *              THE UNORGANIZED STRING SPACE  
CD78  27FB                      BEQ  LB5EE         ;BRANCH IF NONE FOUND AND REORGANIZATION DONE 
CD7A  4F                        CLRA               ;CLEAR MS BYTE OF LENGTH 
CD7B  E684                      LDB  ,X            ;GET LENGTH OF STRING 
CD7D  5A                        DECB               ;SUBTRACT ONE 
CD7E  D347                      ADDD V47           ;ADD LENGTH OF STRING TO ITS STARTING ADDRESS 
CD80  DD43                      STD  V43           ;SAVE AS MOVE STARTING ADDRESS 
CD82  9E23                      LDX  STRTAB        ;POINT X TO THE START OF ORGANIZED STRING VARIABLES 
CD84  9F41                      STX  V41           ;SAVE AS MOVE ENDING ADDRESS 
CD86  BDC3DD                    JSR  LAC20         ;MOVE STRING FROM CURRENT POSITION TO THE 
                      *              TOP OF UNORGANIZED STRING SPACE  
CD89  9E4B                      LDX  V4B           ;POINT X TO STRING DESCRIPTOR 
CD8B  DC45                      LDD  V45           ;* GET NEW STARTING ADDRESS OF STRING AND 
CD8D  ED02                      STD  2,X           ;* SAVE IT IN DESCRIPTOR 
CD8F  9E45                      LDX  V45           ;GET NEW TOP OF UNORGANIZED STRING SPACE 
CD91  301F                      LEAX -1,X          ;MOVE POINTER BACK ONE 
CD93  7ECD1A                    JMP  LB593         ;JUMP BACK AND REORGANIZE SOME MORE 
                                                     
                                                     
CD96  DC52            LB60F     LDD  FPA0+2        ;* GET DESCRIPTOR ADDRESS OF STRING A 
CD98  3406                      PSHS B,A           ;* AND SAVE IT ON THE STACK 
CD9A  BDC9AF                    JSR  LB223         ;GET DESCRIPTOR ADDRESS OF STRING B 
CD9D  BDC8D2                    JSR  LB146         ;TM' ERROR IF NUMERIC VARIABLE 
CDA0  3510                      PULS X             ;* POINT X TO STRING A DESCRIPTOR 
CDA2  9F62                      STX  RESSGN        ;* ADDRESS AND SAVE IT IN RESSGN 
CDA4  E684                      LDB  ,X            ;GET LENGTH OF STRING A 
CDA6  9E52                      LDX  FPA0+2        ;POINT X TO DESCRIPTOR OF STRING B 
CDA8  EB84                      ADDB ,X            ;ADD LENGTH OF STRING B TO STR1NG A 
CDAA  2405                      BCC  LB62A         ;BRANCH IF LENGTH < 256 
CDAC  C61C                      LDB  #2*14         ;STRING TOO LONG' ERROR IF LENGTH > 255 
CDAE  7EC403                    JMP  LAC46         ;JUMP TO ERROR SERVICING ROUTINE 
CDB1  BDCC94          LB62A     JSR  LB50D         ;RESERVE ROOM IN STRING SPACE FOR NEW STRING 
CDB4  9E62                      LDX  RESSGN        ;GET DESCRIPTOR ADDRESS OF STRING A 
CDB6  E684                      LDB  ,X            ;GET LENGTH OF STRING A 
CDB8  8D10                      BSR  LB643         ;MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE 
CDBA  9E4D                      LDX  V4D           ;GET DESCRIPTOR ADDRESS OF STRING B 
CDBC  8D22                      BSR  LB659         ;GET LENGTH AND ADDRESS OF STRING B 
CDBE  8D0C                      BSR  LB645         ;MOVE STRING B INTO REST OF RESERVED BUFFER 
CDC0  9E62                      LDX  RESSGN        ;POINT X TO DESCRIPTOR OF STRING A 
CDC2  8D1C                      BSR  LB659         ;DELETE STRING A IF LAST STRING ON STRING STACK 
CDC4  BDCCD3                    JSR  LB54C         ;PUT STRING DESCRIPTOR ON THE STRING STACK 
CDC7  7EC8F4                    JMP  LB168         ;BRANCH BACK TO EXPRESSION EVALUATION 
                                                     
                      * MOVE (B) BYTES FROM 2,X TO FRESPC                      
CDCA  AE02            LB643     LDX  2,X           ;POINT X TO SOURCE ADDRESS 
CDCC  DE25            LB645     LDU  FRESPC        ;POINT U TO DESTINATION ADDRESS 
CDCE  5C                        INCB               ;COMPENSATION FOR THE DECB BELOW 
CDCF  2004                      BRA  LB64E         ;GO MOVE THE BYTES 
                      * MOVE B BYTES FROM (X) TO (U)                      
CDD1  A680            LB64A     LDA  ,X+           ;* GET A SOURCE BYTE AND MOVE IT 
CDD3  A7C0                      STA  ,U+           ;* TO THE DESTINATION 
CDD5  5A              LB64E     DECB               ;DECREMENT BYTE COUNTER 
CDD6  26F9                      BNE  LB64A         ;BRANCH IF ALL BYTES NOT MOVED 
CDD8  DF25                      STU  FRESPC        ;SAVE ENDING ADDRESS IN FRESPC 
CDDA  39                        RTS                  
                      * RETURN LENGTH (ACCB) AND ADDRESS (X) OF                      
                      * STRING WHOSE DESCRIPTOR IS IN FPA0+2                      
                      * DELETE THE STRING IF IT IS THE LAST ONE                      
                      * PUT ON THE STRING STACK. REMOVE STRING FROM STRING                      
                      * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.                      
CDDB  BDC8D2          LB654     JSR  LB146         ;TM' ERROR IF VARIABLE TYPE = NUMERIC 
CDDE  9E52            LB657     LDX  FPA0+2        ;GET ADDRESS OF SELECTED STRING DESCRIPTOR 
CDE0  E684            LB659     LDB  ,X            ;GET LENGTH OF STRING 
CDE2  8D18                      BSR  LB675         ;* CHECK TO SEE IF THIS STRING DESCRIPTOR WAS 
CDE4  2613                      BNE  LB672         ;* THE LAST ONE PUT ON THE STRING STACK AND 
                      *                            ;* BRANCH IF NOT 
CDE6  AE07                      LDX  5+2,X         ;GET START ADDRESS OF STRING JUST REMOVED 
CDE8  301F                      LEAX -1,X          ;MOVE POINTER DOWN ONE 
CDEA  9C23                      CMPX STRTAB        ;COMPARE TO START OF STRING VARIABLES 
CDEC  2608                      BNE  LB66F         ;BRANCH IF THIS STRING IS NOT AT THE BOTTOM 
                      *                            ;OF STRING VARIABLES 
CDEE  3404                      PSHS B             ;SAVE LENGTH; ACCA WAS CLEARED 
CDF0  D323                      ADDD STRTAB        ;* ADD THE LENGTH OF THE JUST REMOVED STRING 
CDF2  DD23                      STD  STRTAB        ;* TO THE START OF STRING VARIABLES - THIS WILL 
                      *                            ;* REMOVE THE STRING FROM THE STRING SPACE 
CDF4  3504                      PULS B             ;RESTORE LENGTH 
CDF6  3001            LB66F     LEAX 1,X           ;ADD ONE TO POINTER 
CDF8  39                        RTS                  
CDF9  AE02            LB672     LDX  2,X           ;*POINT X TO ADDRESS OF STRING NOT 
CDFB  39                        RTS                ;*ON THE STRING STACK 
                      * REMOVE STRING FROM STRING STACK. ENTER WITH X                      
                      * POINTING TO A STRING DESCRIPTOR - DELETE THE                      
                      * STRING FROM STACK IF IT IS ON TOP OF THE                      
                      * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG                      
CDFC  9C0D            LB675     CMPX LASTPT        ;*COMPARE TO LAST USED DESCRIPTOR ADDRESS 
CDFE  2607                      BNE  LB680         ;*ON THE STRING STACK, RETURN IF DESCRIPTOR 
                      *                            ;*ADDRESS NOT ON THE STRING STACK 
CE00  9F0B                      STX  TEMPPT        ;SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE 
CE02  301B                      LEAX -5,X          ;* MOVE LAST USED DESCRIPTOR BACK 5 BYTES 
CE04  9F0D                      STX  LASTPT        ;* AND SAVE AS THE LAST USED DESCRIPTOR ADDR 
CE06  4F                        CLRA               ;SET ZERO FLAG 
CE07  39              LB680     RTS                  
                                                     
                      * LEN                          
CE08  8D03            LEN       BSR  LB686         ;POINT X TO PROPER STRING AND GET LENGTH 
CE0A  7ECC7A          LB683     JMP  LB4F3         ;CONVERT ACCB TO FP NUMBER IN FPA0 
                      * POINT X TO STRING ADDRESS LOAD LENGTH INTO                      
                      * ACCB. ENTER WITH THE STRING;DESCRIPTOR IN                      
                      * BOTTOM TWO BYTES OF FPA0                      
CE0D  8DCC            LB686     BSR  LB654         ;GET LENGTH AND ADDRESS OF STRING 
CE0F  0F06                      CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
CE11  5D                        TSTB               ;SET FLAGS ACCORDING TO LENGTH 
CE12  39                        RTS                  
                                                     
                      * CHR$                         
CE13  BDCE95          CHR       JSR  LB70E         ;CONVERT FPA0 TO AN INTEGER IN ACCD 
CE16  C601            LB68F     LDB  #1            ;* RESERVE ONE BYTE IN 
CE18  BDCCF4                    JSR  LB56D         ;* THE STRING SPACE 
CE1B  9653                      LDA  FPA0+3        ;GET ASCII STRING VALUE 
CE1D  BDCC98                    JSR  LB511         ;SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR 
CE20  A784                      STA  ,X            ;SAVE THE STRING (IT'S ONLY ONE BYTE)
CE22  3262            LB69B     LEAS 2,S           ;PURGE THE RETURN ADDRESS OFF OF THE STACK 
CE24  7ECCD3          LB69D     JMP  LB54C         ;PUT TEMP DESCRIPTOR DATA ONTO STRING STACK 
                                                     
                                                     
CE27  8D02            ASC       BSR  LB6A4         ;PUT 1ST CHARACTER OF STRING INTO ACCB 
CE29  20DF                      BRA  LB683         ;CONVERT ACCB INTO FP NUMBER IN FPA0 
CE2B  8DE0            LB6A4     BSR  LB686         ;POINT X TO STRING DESCRIPTOR 
CE2D  275E                      BEQ  LB706         ;FC' ERROR IF NULL STRING 
CE2F  E684                      LDB  ,X            ;GET FIRST BYTE OF STRING 
CE31  39                        RTS                  
                                                     
                                                     
CE32  8D48            LEFT      BSR  LB6F5         ;GET ARGUMENTS FROM STACK 
CE34  4F              LB6AD     CLRA               ;CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$ 
CE35  E184            LB6AE     CMPB ,X            ;* COMPARE LENGTH PARAMETER TO LENGTH OF 
CE37  2303                      BLS  LB6B5         ;* STRING AND BRANCH IF LENGTH OF STRING 
                      *                            ;>= LENGTH PARAMETER 
CE39  E684                      LDB  ,X            ;USE LENGTH OF STRING OTHERWISE 
CE3B  4F                        CLRA               ;CLEAR STRING POINTER OFFSET (0 FOR LEFT$) 
CE3C  3406            LB6B5     PSHS B,A           ;PUSH PARAMETERS ONTO STACK 
CE3E  BDCC96                    JSR  LB50F         ;RESERVE ACCB BYTES IN THE STRING SPACE 
CE41  9E4D                      LDX  V4D           ;POINT X TO STRING DESCRIPTOR 
CE43  8D9B                      BSR  LB659         ;GET ADDRESS OF OLD STRING (X=ADDRESS) 
CE45  3504                      PULS B             ;* PULL STRING POINTER OFFSET OFF OF THE STACK 
CE47  3A                        ABX                ;* AND ADD IT TO STRING ADDRESS 
CE48  3504                      PULS B             ;PULL LENGTH PARAMETER OFF OF THE STACK 
CE4A  BDCDCC                    JSR  LB645         ;MOVE ACCB BYTES FROM (X) TO [FRESPC] 
CE4D  20D5                      BRA  LB69D         ;PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK 
                                                     
                      * RIGHT$                       
CE4F  8D2B            RIGHT     BSR  LB6F5         ;GET ARGUMENTS FROM STACK 
CE51  A084                      SUBA ,X            ;ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING 
CE53  40                        NEGA               ;NOW ACCA = LENGTH OF OLD STRING 
CE54  20DF                      BRA  LB6AE         ;PUT NEW STRING IN THE STRING SPACE 
                                                     
                      * MID$                         
CE56  C6FF            MID       LDB  #$FF          ;* GET DEFAULT VALUE OF LENGTH AND 
CE58  D753                      STB  FPA0+3        ;* SAVE IT IN FPA0 
CE5A  9D82                      JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
CE5C  8129                      CMPA #')           ;ARGUMENT DELIMITER? 
CE5E  2705                      BEQ  LB6DE         ;YES - NO LENGTH PARAMETER GIVEN 
CE60  BDC9F9                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
CE63  8D2D                      BSR  LB70B         ;EVALUATE NUMERIC EXPRESSION (LENGTH) 
CE65  8D15            LB6DE     BSR  LB6F5         ;GET ARGUMENTS FROM STACK 
CE67  2724                      BEQ  LB706         ;FC' ERROR IF NULL STRING 
CE69  5F                        CLRB               ;CLEAR LENGTH COUNTER (DEFAULT VALUE) 
CE6A  4A                        DECA               ;*SUOTRACT ONE FROM POSITION PARAMETER (THESE 
CE6B  A184                      CMPA ,X            ;*ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE) 
                      *                            ;*AND COMPARE IT TO LENGTH OF OLD STRING 
CE6D  24CD                      BCC  LB6B5         ;IF POSITION > LENGTH OF OLD STRING, THEN NEW 
                      *                            ;STRING WILL BE A NULL STRING 
CE6F  1F89                      TFR  A,B           ;SAVE ABSOLUTE POSITION PARAMETER IN ACCB 
CE71  E084                      SUBB ,X            ;ACCB=POSITION-LENGTH OF OLD STRING 
CE73  50                        NEGB               ;NOW ACCB=LENGTH OF OLDSTRING-POSITION 
CE74  D153                      CMPB FPA0+3        ;*IF THE AMOUNT OF OLD STRING TO THE RIGHT OF 
CE76  23C4                      BLS  LB6B5         ;*POSITION IS <= THE LENGTH PARAMETER, BRANCH AND 
                      * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION                      
                      * INSTEAD OF THE LENGTH PARAMETER                      
CE78  D653                      LDB  FPA0+3        ;GET LENGTH OF NEW STRING 
CE7A  20C0                      BRA  LB6B5         ;PUT NEW STRING IN STRING SPACE 
                      * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC                      
                      * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK                      
CE7C  BDC9F3          LB6F5     JSR  LB267         ;SYNTAX CHECK FOR A ")" 
CE7F  EEE4                      LDU  ,S            ;LOAD THE RETURN ADDRESS INTO U REGISTER 
CE81  AE65                      LDX  5,S           ;* GET ADDRESS OF STRING AND 
CE83  9F4D                      STX  V4D           ;* SAVE IT IN V4D 
CE85  A664                      LDA  4,S           ;= PUT LENGTH OF STRING IN 
CE87  E664                      LDB  4,S           ;= BOTH ACCA AND ACCB 
CE89  3267                      LEAS 7,S           ;REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK 
CE8B  1F35                      TFR  U,PC          ;JUMP TO ADDRESS IN U REGISTER 
CE8D  7ECBD1          LB706     JMP  LB44A         ;ILLEGAL FUNCTION CALL' 
                      * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN                      
                      * ACCB - 'FC' ERROR IF EXPRESSION > 255                      
CE90  9D7C            LB709     JSR  GETNCH        ;GET NEXT BASIC INPUT CHARACTER 
CE92  BDC8CD          LB70B     JSR  LB141         ;EVALUATE A NUMERIC EXPRESSION 
CE95  BDCB70          LB70E     JSR  LB3E9         ;CONVERT FPA0 TO INTEGER IN ACCD 
CE98  4D                        TSTA               ;TEST MS BYTE OF INTEGER 
CE99  26F2                      BNE  LB706         ;FC' ERROR IF EXPRESSION > 255 
CE9B  0E82                      JMP  GETCCH        ;GET CURRENT INPUT CHARACTER FROM BASIC 
                                                     
                      * VAL                          
CE9D  BDCE0D          VAL       JSR  LB686         ;POINT X TO STRING ADDRESS 
CEA0  102702E1                  LBEQ LBA39         ;IF NULL STRING SET FPA0 
CEA4  DE83                      LDU  CHARAD        ;SAVE INPUT POINTER IN REGISTER U 
CEA6  9F83                      STX  CHARAD        ;POINT INPUT POINTER TO ADDRESS OF STRING 
CEA8  3A                        ABX                ;MOVE POINTER TO END OF STRING TERMINATOR  
CEA9  A684                      LDA  ,X            ;GET LAST BYTE OF STRING 
CEAB  3452                      PSHS U,X,A         ;SAVE INPUT POINTER, STRING TERMINATOR 
                      *         ADDRESS AND CHARACTER   
CEAD  6F84                      CLR  ,X            ;CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION 
CEAF  9D82                      JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
CEB1  BDD45E                    JSR  LBD12         ;CONVERT AN ASCII STRING TO FLOATING POINT 
CEB4  3552                      PULS A,X,U         ;RESTORE CHARACTERS AND POINTERS 
CEB6  A784                      STA  ,X            ;REPLACE STRING TERMINATOR 
CEB8  DF83                      STU  CHARAD        ;RESTORE INPUT CHARACTER 
CEBA  39                        RTS                  
                                                     
CEBB  8D07            LB734     BSR  LB73D         ;* EVALUATE AN EXPRESSION, RETURN 
CEBD  9F2B                      STX  BINVAL        ;* THE VALUE IN X; STORE IT IN BINVAL 
CEBF  BDC9F9          LB738     JSR  LB26D         ;SYNTAX CHECK FOR A COMMA 
CEC2  20CE                      BRA  LB70B         ;EVALUATE EXPRESSION IN RANGE 0 <= X < 256 
                      * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF                      
                                                     
CEC4  BDC8CD          LB73D     JSR  LB141         ;EVALUATE NUMERIC EXPRESSION 
CEC7  9654            LB740     LDA  FP0SGN        ;GET SIGN OF FPA0 MANTISSA 
CEC9  2BC2                      BMI  LB706         ;ILLEGAL FUNCTION CALL' IF NEGATIVE 
CECB  964F                      LDA  FP0EXP        ;GET EXPONENT OF FPA0 
CECD  8190                      CMPA #$90          ;COMPARE TO LARGEST POSITIVE INTEGER 
CECF  22BC                      BHI  LB706         ;ILLEGAL FUNCTION CALL' IF TOO LARGE 
CED1  BDD414                    JSR  LBCC8         ;SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0 
CED4  9E52                      LDX  FPA0+2        ;LOAD X WITH LOWER TWO BYTES OF FPA0 
CED6  39                        RTS                  
                                                     
                      * PEEK                         
CED7  8DEE            PEEK      BSR  LB740         ;CONVERT FPA0 TO INTEGER IN REGISTER X 
CED9  E684                      LDB  ,X            ;GET THE VALUE BEING 'PEEK'ED 
CEDB  7ECC7A                    JMP  LB4F3         ;CONVERT ACCB INTO A FP NUMBER 
                                                     
                      * POKE                         
CEDE  8DDB            POKE      BSR  LB734         ;EVALUATE 2 EXPRESSIONS 
CEE0  9E2B                      LDX  BINVAL        ;GET THE ADDRESS TO BE 'POKE'ED 
CEE2  E784                      STB  ,X            ;STORE THE DATA IN THAT ADDRESS 
CEE4  39                        RTS                  
                                                     
                                                     
                      * LIST                         
CEE5  3401            LIST      PSHS CC            ;SAVE ZERO FLAG ON STACK 
CEE7  BDC717                    JSR  LAF67         ;CONVERT DECIMAL LINE NUMBER TO BINARY 
CEEA  BDC4A2                    JSR  LAD01         ;* FIND RAM ADDRESS OF THAT LINE NUMBER AND 
CEED  9F66                      STX  LSTTXT        ;* SAVE IT IN LSTTXT 
CEEF  3501                      PULS CC            ;GET ZERO FLAG FROM STACK 
CEF1  2712                      BEQ  LB784         ;BRANCH IF END OF LINE 
CEF3  9D82                      JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
CEF5  2713                      BEQ  LB789         ;BRANCH IF END OF LINE 
CEF7  81A7                      CMPA #TOK_MINUS    ;MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?) 
CEF9  2609                      BNE  LB783         ;NO - RETURN 
CEFB  9D7C                      JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
CEFD  2706                      BEQ  LB784         ;BRANCH IF END OF LINE 
CEFF  BDC717                    JSR  LAF67         ;GET ENDING LINE NUMBER 
CF02  2706                      BEQ  LB789         ;BRANCH IF LEGAL LINE NUMBER 
CF04  39              LB783 RTS                      
                      * LIST THE ENTIRE PROGRAM                      
CF05  CEFFFF          LB784     LDU  #$FFFF        ;* SET THE DEFAULT ENDING LINE NUMBER 
CF08  DF2B                      STU  BINVAL        ;* TO $FFFF 
CF0A  3262            LB789     LEAS 2,S           ;PURGE RETURN ADDRESS FROM THE STACK 
CF0C  9E66                      LDX  LSTTXT        ;POINT X TO STARTING LINE ADDRESS 
CF0E  BDD0AC          LB78D     JSR  LB95C         ;MOVE CURSOR TO START OF A NEW LINE 
CF11  BDC195                    JSR  LA549         ;CHECK FOR A BREAK OR PAUSE 
CF14  EC84                      LDD  ,X            ;GET ADDRESS OF NEXT BASIC LINE 
CF16  2603                      BNE  LB79F         ;BRANCH IF NOT END OF PROGRAM 
CF18                  LB797                          
CF18  7EC422                    JMP  LAC73         ;RETURN TO BASIC'S MAIN INPUT LOOP
CF1B  9F66            LB79F     STX  LSTTXT        ;SAVE NEW STARTING LINE ADDRESS 
CF1D  EC02                      LDD  2,X           ;* GET THE LINE NUMBER OF THIS LINE AND 
CF1F  10932B                    CMPD BINVAL        ;* COMPARE IT TO ENDING LINE NUMBER 
CF22  22F4                      BHI  LB797         ;EXIT IF LINE NUMBER > ENDING LINE NUMBER 
CF24  BDD518                    JSR  LBDCC         ;PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL 
CF27  BDD0F8                    JSR  LB9AC         ;SEND A SPACE TO CONSOLE OUT 
CF2A  9E66                      LDX  LSTTXT        ;GET RAM ADDRESS OF THIS LINE 
CF2C  8D10                      BSR  LB7C2         ;UNCRUNCH A LINE 
CF2E  AE9F0066                  LDX  [LSTTXT]      ;POINT X TO START OF NEXT LINE 
CF32  CE00F4                    LDU  #LINBUF+1     ;POINT U TO BUFFER FULL OF UNCRUNCHED LINE 
CF35  A6C0            LB7B9     LDA  ,U+           ;GET A BYTE FROM THE BUFFER 
CF37  27D5                      BEQ  LB78D         ;BRANCH IF END OF BUFFER 
CF39  BDD0FD                    JSR  LB9B1         ;SEND CHARACTER TO CONSOLE OUT 
CF3C  20F7                      BRA  LB7B9         ;GET ANOTHER CHARACTER 
                                                     
                      * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
CF3E  3004            LB7C2     LEAX 4,X           ;MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER 
CF40  108E00F4                  LDY  #LINBUF+1     ;UNCRUNCH LINE INTO LINE INPUT BUFFER 
CF44  A680            LB7CB     LDA  ,X+           ;GET A CHARACTER 
CF46  2751                      BEQ  LB820         ;BRANCH IF END OF LINE 
CF48  2B15                      BMI  LB7E6         ;BRANCH IF IT'S A TOKEN
CF4A  813A                      CMPA #':           ;CHECK FOR END OF SUB LINE 
CF4C  260D                      BNE  LB7E2         ;BRNCH IF NOT END OF SUB LINE 
CF4E  E684                      LDB  ,X            ;GET CHARACTER FOLLOWING COLON 
CF50  C184                      CMPB #TOK_ELSE     ;TOKEN FOR ELSE? 
CF52  27F0                      BEQ  LB7CB         ;YES - DON'T PUT IT IN BUFFER
CF54  C182                      CMPB #TOK_SNGL_Q   ;TOKEN FOR REMARK? 
CF56  27EC                      BEQ  LB7CB         ;YES - DON'T PUT IT IN BUFFER
CF58  8C                        FCB  SKP2          ;SKIP TWO BYTES 
CF59  8621            LB7E0     LDA  #'!           ;EXCLAMATION POINT 
CF5B  8D30            LB7E2     BSR  LB814         ;PUT CHARACTER IN BUFFER 
CF5D  20E5                      BRA  LB7CB         ;GET ANOTHER CHARACTER 
                                                     
CF5F  CEC0E2          LB7E6     LDU  #COMVEC-10    ;FIRST DO COMMANDS 
CF62  81FF                      CMPA #$FF          ;CHECK FOR SECONDARY TOKEN 
CF64  2604                      BNE  LB7F1         ;BRANCH IF NON SECONDARY TOKEN 
CF66  A680                      LDA  ,X+           ;GET SECONDARY TOKEN 
CF68  3345                      LEAU 5,U           ;BUMP IT UP TO SECONDARY FUNCTIONS 
CF6A  847F            LB7F1     ANDA #$7F          ;MASK OFF BIT 7 OF TOKEN 
CF6C  334A            LB7F3     LEAU 10,U          ;MOVE TO NEXT COMMAND TABLE 
CF6E  6DC4                      TST  ,U            ;IS THIS TABLE ENABLED? 
CF70  27E7                      BEQ  LB7E0         ;NO - ILLEGAL TOKEN 
CF72  A0C4                      SUBA ,U            ;SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER 
CF74  2AF6                      BPL  LB7F3         ;BRANCH IF TOKEN NOT IN THIS TABLE 
CF76  ABC4                      ADDA ,U            ;RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE 
CF78  EE41                      LDU  1,U           ;POINT U TO COMMAND DICTIONARY TABLE 
CF7A  4A              LB801     DECA               ;DECREMENT TOKEN NUMBER 
CF7B  2B06                      BMI  LB80A         ;BRANCH IF THIS IS THE CORRECT TOKEN 
                      * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN                      
CF7D  6DC0            LB804     TST  ,U+           ;GRAB A BYTE 
CF7F  2AFC                      BPL  LB804         ;BRANCH IF BIT 7 NOT SET 
CF81  20F7                      BRA  LB801         ;GO SEE IF THIS IS THE CORRECT TOKEN 
CF83  A6C4            LB80A     LDA  ,U            ;GET A CHARACTER FROM DICTIONARY TABLE 
CF85  8D06                      BSR  LB814         ;PUT CHARACTER IN BUFFER 
CF87  6DC0                      TST  ,U+           ;CHECK FOR START OF NEXT TOKEN 
CF89  2AF8                      BPL  LB80A         ;BRANCH IF NOT DONE WITH THIS TOKEN 
CF8B  20B7                      BRA  LB7CB         ;GO GET ANOTHER CHARACTER 
CF8D  108C01ED        LB814     CMPY #LINBUF+LBUFMX ;TEST FOR END OF LINE INPUT BUFFER
CF91  2406                      BCC  LB820         ;BRANCH IF AT END OF BUFFER 
CF93  847F                      ANDA #$7F          ;MASK OFF BIT 7 
CF95  A7A0                      STA  ,Y+           ;* SAVE CHARACTER IN BUFFER AND 
CF97  6FA4                      CLR  ,Y            ;* CLEAR NEXT CHARACTER SLOT IN BUFFER 
CF99  39              LB820     RTS                  
                      *                              
                      * CRUNCH THE LINE THAT THE INPUT POINTER IS                      
                      * POINTING TO INTO THE LINE INPUT BUFFER                      
                      * RETURN LENGTH OF CRUNCHED LINE IN ACCD                      
                      *                              
CF9A  9E83            LB821     LDX  CHARAD        ;GET BASIC'S INPUT POINTER ADDRESS 
CF9C  CE00F3                    LDU  #LINBUF       ;POINT X TO LINE INPUT BUFFER 
CF9F  0F43            LB829     CLR  V43           ;CLEAR ILLEGAL TOKEN FLAG 
CFA1  0F44                      CLR  V44           ;CLEAR DATA FLAG 
CFA3  A680            LB82D     LDA  ,X+           ;GET INPUT CHAR 
CFA5  2721                      BEQ  LB852         ;BRANCH IF END OF LINE 
CFA7  0D43                      TST  V43           ;* CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT 
CFA9  270F                      BEQ  LB844         ;* PROCESSING AN ILLEGAL TOKEN 
CFAB  BDCB29                    JSR  LB3A2         ;SET CARRY IF NOT UPPER CASE ALPHA 
CFAE  2418                      BCC  LB852         ;BRANCH IF UPPER CASE ALPHA 
CFB0  8130                      CMPA #'0           ;* DON'T CRUNCH ASCII NUMERIC CHARACTERS
CFB2  2504                      BLO  LB842         ;* BRANCH IF NOT NUMERIC 
CFB4  8139                      CMPA #'9           ;* 
CFB6  2310                      BLS  LB852         ;* BRANCH IF NUMERIC 
                      * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC                      
CFB8  0F43            LB842     CLR  V43           ;CLEAR ILLEGAL TOKEN FLAG 
CFBA  8120            LB844     CMPA #SPACE        ;SPACE? 
CFBC  270A                      BEQ  LB852         ;DO NOT REMOVE SPACES 
CFBE  9742                      STA  V42           ;SAVE INPUT CHARACTER AS SCAN DELIMITER 
CFC0  8122                      CMPA #'"           ;CHECK FOR STRING DELIMITER 
CFC2  2738                      BEQ  LB886         ;BRANCH IF STRING 
CFC4  0D44                      TST  V44           ;* CHECK DATA FLAG AND BRANCH IF CLEAR 
CFC6  2719                      BEQ  LB86B         ;* DO NOT CRUNCH DATA 
CFC8  A7C0            LB852     STA  ,U+           ;SAVE CHARACTER IN BUFFER 
CFCA  2706                      BEQ  LB85C         ;BRANCH IF END OF LINE 
CFCC  813A                      CMPA #':           ;* CHECK FOR END OF SUBLINE 
CFCE  27CF                      BEQ  LB829         ;* AND RESET FLAGS IF END OF SUBLINE 
CFD0  20D1            LB85A     BRA  LB82D         ;GO GET ANOTHER CHARACTER 
CFD2  6FC0            LB85C     CLR  ,U+           ;* DOUBLE ZERO AT END OF LINE 
CFD4  6FC0                      CLR  ,U+           ;* 
CFD6  1F30                      TFR  U,D           ;SAVE ADDRESS OF END OF LINE IN ACCD 
CFD8  8300F1                    SUBD #LINHDR       ;LENGTH OF LINE IN ACCD 
CFDB  8E00F2                    LDX  #LINBUF-1     ;* SET THE INPUT POINTER TO ONE BEFORE 
CFDE  9F83                      STX  CHARAD        ;* THE START OF THE CRUNCHED LINE 
CFE0  39                        RTS                ;EXIT 'CRUNCH'   
CFE1  813F            LB86B     CMPA #'?           ;CHECK FOR "?" - PRINT ABBREVIATION 
CFE3  2604                      BNE  LB873         ;BRANCH IF NOT PRINT ABBREVIATION 
CFE5  8687                      LDA  #TOK_PRINT    ;* GET THE PRINT TOKEN AND SAVE IT 
CFE7  20DF                      BRA  LB852         ;* IN BUFFER 
CFE9  8127            LB873     CMPA #''           ;APOSTROPHE IS SAME AS REM 
CFEB  2613                      BNE  LB88A         ;BRANCH IF NOT REMARK 
CFED  CC3A82                    LDD  #$3A00+TOK_SNGL_Q ;COLON, REM TOKEN 
CFF0  EDC1                      STD  ,U++          ;SAVE IN BUFFER 
CFF2  0F42            LB87C     CLR  V42           ;SET DELIMITER = 0 (END OF LINE) 
CFF4  A680            LB87E     LDA  ,X+           ;SCAN TILL WE MATCH [V42] 
CFF6  27D0                      BEQ  LB852         ;BRANCH IF END OF LINE 
CFF8  9142                      CMPA V42           ;DELIMITER? 
CFFA  27CC                      BEQ  LB852         ;BRANCH OUT IF SO 
CFFC  A7C0            LB886     STA  ,U+           ;DON'T CRUNCH REMARKS OR STRINGS
CFFE  20F4                      BRA  LB87E         ;GO GET MORE STRING OR REMARK 
D000  8130            LB88A     CMPA #'0           ;* LESS THAN ASCII ZERO? 
D002  2504                      BCS  LB892         ;* BRANCH IF SO 
D004  813C                      CMPA #';+1         ;= CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON 
D006  25C0                      BCS  LB852         ;= AND INSERT IN BUFFER IF SO 
D008  301F            LB892     LEAX -1,X          ;MOVE INPUT POINTER BACK ONE 
D00A  3450                      PSHS U,X           ;SAVE POINTERS TO INPUT STRING, OUTPUT STRING 
D00C  0F41                      CLR  V41           ;TOKEN FLAG 0 = COMMAND, FF = SECONDARY 
D00E  CEC0E2                    LDU  #COMVEC-10    ;POINT U TO COMMAND INTERPRETATION 
                      *                            ;TABLE FOR BASIC - 10 
D011  0F42            LB89B     CLR  V42           ;INITIALIZE V42 AS TOKEN COUNTER 
D013  334A            LB89D     LEAU 10,U          ;MOVE TO NEXT COMMAND INTERPRETATION TABLE 
D015  A6C4                      LDA  ,U            ;GET NUMBER OF COMMANDS 
D017  2731                      BEQ  LB8D4         ;GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE 
D019  10AE41                    LDY  1,U           ;POINT Y TO COMMAND DICTIONARY TABLE 
D01C  AEE4            LB8A6     LDX  ,S            ;GET POINTER TO INPUT STRING 
D01E  E6A0            LB8A8     LDB  ,Y+           ;GET A BYTE FROM DICTIONARY TABLE 
D020  E080                      SUBB ,X+           ;SUBTRACT INPUT CHARACTER 
D022  27FA                      BEQ  LB8A8         ;LOOP IF SAME 
D024  C180                      CMPB #$80          ;LAST CHAR IN RESERVED WORD TABLE HAD 
                      *                            ;BIT 7 SET, SO IF WE HAVE $80 HERE 
                      *                            ;THEN IT IS A GOOD COMPARE 
D026  2638                      BNE  LB8EA         ;BRANCH IF NO MATCH - CHECK ANOTHER COMMAND 
D028  3262                      LEAS 2,S           ;DELETE OLD INPUT POINTER FROM STACK 
D02A  3540                      PULS U             ;GET POINTER TO OUTPUT STRING 
D02C  DA42                      ORB  V42           ;OR IN THE TABLE POSITION TO MAKE THE TOKEN 
                      *                            ;- NOTE THAT B ALREADY HAD $80 IN IT - 
D02E  9641                      LDA  V41           ;* CHECK TOKEN FLAG AND BRANCH 
D030  2606                      BNE  LB8C2         ;* IF SECONDARY 
D032  C184                      CMPB #TOK_ELSE     ;IS IT ELSE TOKEN? 
D034  2606                      BNE  LB8C6         ;NO 
D036  863A                      LDA  #':           ;PUT A COLON (SUBLINE) BEFORE ELSE TOKEN 
D038  EDC1            LB8C2     STD  ,U++          ;SECONDARY TOKENS PRECEEDED BY $FF 
D03A  2094                      BRA  LB85A         ;GO PROCESS MORE INPUT CHARACTERS 
D03C  E7C0            LB8C6     STB  ,U+           ;SAVE THIS TOKEN 
D03E  C186                      CMPB #TOK_DATA     ;DATA TOKEN? 
D040  2602                      BNE  LB8CE         ;NO 
D042  0C44                      INC  V44           ;SET DATA FLAG 
D044  C182            LB8CE     CMPB #TOK_REM      ;REM TOKEN? 
D046  27AA                      BEQ  LB87C         ;YES 
D048  2086            LB8D2     BRA  LB85A         ;GO PROCESS MORE INPUT CHARACTERS 
                      * CHECK FOR A SECONDARY TOKEN                      
D04A  CEC0E7          LB8D4     LDU  #COMVEC-5     ;NOW DO SECONDARY FUNCTIONS 
D04D  0341                      COM  V41           ;TOGGLE THE TOKEN FLAG 
D04F  26C0                      BNE  LB89B         ;BRANCH IF NOW CHECKING SECONDARY COMMANDS 
                                                     
                      * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO                      
                      * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN                      
D051  3550                      PULS X,U           ;RESTORE INPUT AND OUTPUT POINTERS 
D053  A680                      LDA  ,X+           ;* MOVE THE FIRST CHARACTER OF AN 
D055  A7C0                      STA  ,U+           ;* ILLEGAL TOKEN 
D057  BDCB29                    JSR  LB3A2         ;SET CARRY IF NOT ALPHA 
D05A  25EC                      BCS  LB8D2         ;BRANCH IF NOT ALPHA 
D05C  0343                      COM  V43           ;SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA 
D05E  20E8                      BRA  LB8D2         ;PROCESS MORE INPUT CHARACTERS 
D060  0C42            LB8EA     INC  V42           ;INCREMENT TOKEN COUNTER 
D062  4A                        DECA               ;DECR COMMAND COUNTER 
D063  27AE                      BEQ  LB89D         ;GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE 
D065  313F                      LEAY -1,Y          ;MOVE POINTER BACK ONE 
D067  E6A0            LB8F1     LDB  ,Y+           ;* GET TO NEXT 
D069  2AFC                      BPL  LB8F1         ;* RESERVED WORD 
D06B  20AF                      BRA  LB8A6         ;GO SEE IF THIS WORD IS A MATCH 
                                                     
                      * PRINT                        
D06D  2739            PRINT     BEQ  LB958         ;BRANCH IF NO ARGUMENT 
D06F  8D01                      BSR  LB8FE         ;CHECK FOR ALL PRINT OPTIONS 
D071  39                        RTS                  
D072                  LB8FE                          
D072  BDDFD2          LB918     JSR  XVEC9         ;CALL EXTENDED BASIC ADD-IN 
D075  273E            LB91B     BEQ  LB965         ;RETURN IF END OF LINE 
D077  819F            LB91D     CMPA #TOK_TAB      ;TOKEN FOR TAB( ? 
D079  2753                      BEQ  LB97E         ;YES 
D07B  812C                      CMPA #',           ;COMMA? 
D07D  2737                      BEQ  LB966         ;YES - ADVANCE TO NEXT TAB FIELD 
D07F  813B                      CMPA #';           ;SEMICOLON? 
D081  2760                      BEQ  LB997         ;YES - DO NOT ADVANCE CURSOR 
D083  BDC8E2                    JSR  LB156         ;EVALUATE EXPRESSION 
D086  9606                      LDA  VALTYP        ;* GET VARIABLE TYPE AND 
D088  3402                      PSHS A             ;* SAVE IT ON THE STACK 
D08A  2606                      BNE  LB938         ;BRANCH IF STRING VARIABLE 
D08C  BDD525                    JSR  LBDD9         ;CONVERT FP NUMBER TO AN ASCII STRING 
D08F  BDCC9D                    JSR  LB516         ;PARSE A STRING FROM (X-1) AND PUT 
                      *                            ;DESCRIPTOR ON STRING STACK 
D092  8D57            LB938     BSR  LB99F         ;PRINT STRING POINTED TO BY X 
D094  3504                      PULS B             ;GET VARIABLE TYPE BACK 
D096  BDC12E                    JSR  LA35F         ;SET UP TAB WIDTH ZONE, ETC 
D099  5D              LB949     TSTB               ;CHECK CURRENT PRINT POSITION 
D09A  2608                      BNE  LB954         ;BRANCH IF NOT AT START OF LINE 
D09C  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
D09E  812C                      CMPA #',           ;COMMA? 
D0A0  2714                      BEQ  LB966         ;SKIP TO NEXT TAB FIELD 
D0A2  8D54                      BSR  LB9AC         ;SEND A SPACE TO CONSOLE OUT 
D0A4  9D82            LB954     JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
D0A6  26CF                      BNE  LB91D         ;BRANCH IF NOT END OF LINE 
D0A8  860D            LB958     LDA  #CR           ;* SEND A CR TO 
D0AA  2051                      BRA  LB9B1         ;* CONSOLE OUT 
D0AC  BDC12E          LB95C     JSR  LA35F         ;SET UP TAB WIDTH, ZONE ETC 
D0AF  27F7                      BEQ  LB958         ;BRANCH IF WIDTH = ZERO 
D0B1  966C                      LDA  DEVPOS        ;GET PRINT POSITION 
D0B3  26F3                      BNE  LB958         ;BRANCH IF NOT AT START OF LINE 
D0B5  39              LB965     RTS                  
                      * SKIP TO NEXT TAB FIELD                      
D0B6  BDC12E          LB966     JSR  LA35F         ;SET UP TAB WIDTH, ZONE ETC 
D0B9  270A                      BEQ  LB975         ;BRANCH IF LINE WIDTH = 0 (CASSETTE) 
D0BB  D66C                      LDB  DEVPOS        ;GET CURRENT POSITION 
D0BD  D16B                      CMPB DEVLCF        ;COMPARE TO LAST TAB ZONE 
D0BF  2506                      BCS  LB977         ;BRANCH IF < LAST TAB ZONE 
D0C1  8DE5                      BSR  LB958         ;SEND A CARRIAGE RETURN TO CONSOLE OUT 
D0C3  201E                      BRA  LB997         ;GET MORE DATA 
D0C5  D66C            LB975     LDB  DEVPOS        ;* 
D0C7  D06A            LB977     SUBB DEVCFW        ;* SUBTRACT TAB FIELD WIDTH FROM CURRENT 
D0C9  24FC                      BCC  LB977         ;* POSITION UNTIL CARRY SET - NEGATING THE 
D0CB  50                        NEGB               ;* REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT 
                      *              * TAB ZONE IN ACCB  
D0CC  2010                      BRA  LB98E         ;GO ADVANCE TO NEXT TAB ZONE 
                                                     
                      * PRINT TAB(                      
D0CE  BDCE90          LB97E     JSR  LB709         ;EVALUATE EXPRESSION - RETURN VALUE IN B 
D0D1  8129                      CMPA #')           ;* 'SYNTAX' ERROR IF NOT ')' 
D0D3  1026F92C                  LBNE LB277         ;* 
D0D7  BDC12E                    JSR  LA35F         ;SET UP TAB WIDTH, ZONE ETC 
D0DA  D06C                      SUBB DEVPOS        ;GET DIFFERENCE OF PRINT POSITION & TAB POSITION 
D0DC  2305                      BLS  LB997         ;BRANCH IF TAB POSITION < CURRENT POSITION 
D0DE                  LB98E                          
D0DE  8D18            LB992     BSR  LB9AC         ;SEND A SPACE TO CONSOLE OUT 
D0E0  5A                        DECB               ;DECREMENT DIFFERENCE COUNT 
D0E1  26FB                      BNE  LB992         ;BRANCH UNTIL CURRENT POSITION = TAB POSITION 
D0E3  9D7C            LB997     JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
D0E5  7ED075                    JMP  LB91B         ;LOOK FOR MORE PRINT DATA 
                      * COPY A STRING FROM (X) TO CONSOLE OUT                      
D0E8  BDCC9F          LB99C     JSR  LB518         ;PARSE A STRING FROM X AND PUT 
                      *         DESCRIPTOR ON STRING STACK  
D0EB  BDCDDE          LB99F     JSR  LB657         ;GET LENGTH OF STRING AND REMOVE 
                      *         DESCRIPTOR FROM STRING STACK  
D0EE  5C                        INCB               ;COMPENSATE FOR DECB BELOW 
D0EF  5A              LB9A3     DECB               ;DECREMENT COUNTER 
D0F0  27C3                      BEQ  LB965         ;EXIT ROUTINE 
D0F2  A680                      LDA  ,X+           ;GET A CHARACTER FROM X 
D0F4  8D07                      BSR  LB9B1         ;SEND TO CONSOLE OUT 
D0F6  20F7                      BRA  LB9A3         ;KEEP LOOPING 
D0F8  8620            LB9AC     LDA  #SPACE        ;SPACE TO CONSOLE OUT 
D0FA  8C                        FCB  SKP2          ;SKIP NEXT TWO BYTES 
D0FB  863F            LB9AF     LDA  #'?           ;QUESTION MARK TO CONSOLE OUT 
D0FD  7EC017          LB9B1     JMP  PUTCHR        ;JUMP TO CONSOLE OUT 
                                                     
                      * FLOATING POINT MATH PACKAGE                      
                                                     
                      * ADD .5 TO FPA0                      
D100  8ED60C          LB9B4     LDX  #LBEC0        ;FLOATING POINT CONSTANT (.5) 
D103  2009                      BRA  LB9C2         ;ADD .5 TO FPA0 
                      * SUBTRACT FPA0 FROM FP NUMBER POINTED                      
                      * TO BY (X), LEAVE RESULT IN FPA0                      
D105  BDD27B          LB9B9     JSR  LBB2F         ;COPY PACKED FP DATA FROM (X) TO FPA1 
                                                     
                      * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER                      
                      * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)                      
D108  0354            LB9BC     COM  FP0SGN        ;CHANGE MANTISSA SIGN OF FPA0 
D10A  0362                      COM  RESSGN        ;REVERSE RESULT SIGN FLAG 
D10C  2003                      BRA  LB9C5         ;GO ADD FPA1 AND FPA0 
                      * ADD FP NUMBER POINTED TO BY                      
                      * (X) TO FPA0 - LEAVE RESULT IN FPA0                      
D10E  BDD27B          LB9C2     JSR  LBB2F         ;UNPACK PACKED FP DATA FROM (X) TO 
                      *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA  
                                                     
                      * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO                      
                                                     
D111  5D              LB9C5     TSTB               ;CHECK EXPONENT OF FPA0 
D112  10270280                  LBEQ LBC4A         ;COPY FPA1 TO FPA0 IF FPA0 = 
D116  8E005C                    LDX  #FP1EXP       ;POINT X TO FPA1 
D119  1F89            LB9CD     TFR  A,B           ;PUT EXPONENT OF FPA1 INTO ACCB 
D11B  5D                        TSTB               ;CHECK EXPONENT 
D11C  276C                      BEQ  LBA3E         ;RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0) 
D11E  D04F                      SUBB FP0EXP        ;SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1 
D120  2769                      BEQ  LBA3F         ;BRANCH IF EXPONENTS ARE EQUAL 
D122  250A                      BCS  LB9E2         ;BRANCH IF EXPONENT FPA0 > FPA1 
D124  974F                      STA  FP0EXP        ;REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT 
D126  9661                      LDA  FP1SGN        ;* REPLACE FPA0 MANTISSA SIGN 
D128  9754                      STA  FP0SGN        ;* WITH FPA1 MANTISSA SIGN 
D12A  8E004F                    LDX  #FP0EXP       ;POINT X TO FPA0 
D12D  50                        NEGB               ;NEGATE DIFFERENCE OF EXPONENTS 
D12E  C1F8            LB9E2     CMPB #-8           ;TEST DIFFERENCE OF EXPONENTS 
D130  2F59                      BLE  LBA3F         ;BRANCH IF DIFFERENCE OF EXPONENTS <= 8 
D132  4F                        CLRA               ;CLEAR OVERFLOW BYTE 
D133  6401                      LSR  1,X           ;SHIFT MS BYTE OF MANTISSA; BIT 7 = 0 
D135  BDD206                    JSR  LBABA         ;GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES 
D138  D662            LB9EC     LDB  RESSGN        ;GET SIGN FLAG 
D13A  2A0B                      BPL  LB9FB         ;BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME 
D13C  6301                      COM  1,X           ;* COMPLEMENT MANTISSA POINTED 
D13E  6302                      COM  2,X           ;* TO BY (X) THE 
D140  6303                      COM  3,X           ;* ADCA BELOW WILL 
D142  6304                      COM  4,X           ;* CONVERT THIS OPERATION 
D144  43                        COMA               ;* INTO A NEG (MANTISSA) 
D145  8900                      ADCA #0            ;ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG 
                      * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA                      
                      *                              
                      * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0                      
D147  9763            LB9FB     STA  FPSBYT        ;SAVE FPA SUB BYTE 
D149  9653                      LDA  FPA0+3        ;* ADD LS BYTE 
D14B  9960                      ADCA FPA1+3        ;* OF MANTISSA 
D14D  9753                      STA  FPA0+3        ;SAVE IN FPA0 LSB 
D14F  9652                      LDA  FPA0+2        ;* ADD NEXT BYTE 
D151  995F                      ADCA FPA1+2        ;* OF MANTISSA 
D153  9752                      STA  FPA0+2        ;SAVE IN FPA0 
D155  9651                      LDA  FPA0+1        ;* ADD NEXT BYTE 
D157  995E                      ADCA FPA1+1        ;* OF MANTISSA 
D159  9751                      STA  FPA0+1        ;SAVE IN FPA0 
D15B  9650                      LDA  FPA0          ;* ADD MS BYTE 
D15D  995D                      ADCA FPA1          ;* OF MANTISSA 
D15F  9750                      STA  FPA0          ;SAVE IN FPA0 
D161  5D                        TSTB               ;TEST SIGN FLAG  
D162  2A44                      BPL  LBA5C         ;BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE 
D164  2502            LBA18     BCS  LBA1C         ;BRANCH IF POSITIVE MANTISSA 
D166  8D5D                      BSR  LBA79         ;NEGATE FPA0 MANTISSA 
                                                     
                      * NORMALIZE FPA0                      
D168  5F              LBA1C     CLRB               ;CLEAR TEMPORARY EXPONENT ACCUMULATOR 
D169  9650            LBA1D     LDA  FPA0          ;TEST MSB OF MANTISSA 
D16B  262E                      BNE  LBA4F         ;BRANCH IF <> 0 
D16D  9651                      LDA  FPA0+1        ;* IF THE MSB IS 
D16F  9750                      STA  FPA0          ;* 0, THEN SHIFT THE 
D171  9652                      LDA  FPA0+2        ;* MANTISSA A WHOLE BYTE 
D173  9751                      STA  FPA0+1        ;* AT A TIME. THIS 
D175  9653                      LDA  FPA0+3        ;* IS FASTER THAN ONE 
D177  9752                      STA  FPA0+2        ;* BIT AT A TIME 
D179  9663                      LDA  FPSBYT        ;* BUT USES MORE MEMORY. 
D17B  9753                      STA  FPA0+3        ;* FPSBYT, THE CARRY IN 
D17D  0F63                      CLR  FPSBYT        ;* BYTE, REPLACES THE MATISSA LSB. 
D17F  CB08                      ADDB #8            ;SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT 
D181  C128                      CMPB #5*8          ;CHECK FOR 5 SHIFTS 
D183  2DE4                      BLT  LBA1D         ;BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0 
D185  4F              LBA39     CLRA               ;A ZERO EXPONENT = 0 FLOATING POINT 
D186  974F            LBA3A     STA  FP0EXP        ;ZERO OUT THE EXPONENT 
D188  9754                      STA  FP0SGN        ;ZERO OUT THE MANTISSA SIGN 
D18A  39              LBA3E     RTS                  
D18B  8D6D            LBA3F     BSR  LBAAE         ;SHIFT FPA0 MANTISSA TO RIGHT 
D18D  5F                        CLRB               ;CLEAR CARRY FLAG 
D18E  20A8                      BRA  LB9EC           
                      * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7                      
                      * OF MATISSA MS BYTE = 1                      
D190  5C              LBA44     INCB               ;ADD ONE TO EXPONENT ACCUMULATOR 
D191  0863                      ASL  FPSBYT        ;SHIFT SUB BYTE ONE LEFT 
D193  0953                      ROL  FPA0+3        ;SHIFT LS BYTE 
D195  0952                      ROL  FPA0+2        ;SHIFT NS BYTE 
D197  0951                      ROL  FPA0+1        ;SHIFT NS BYTE 
D199  0950                      ROL  FPA0          ;SHIFT MS BYTE 
D19B  2AF3            LBA4F     BPL  LBA44         ;BRANCH IF NOT YET NORMALIZED 
D19D  964F                      LDA  FP0EXP        ;GET CURRENT EXPONENT 
D19F  3404                      PSHS B             ;SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION 
D1A1  A0E0                      SUBA ,S+           ;SUBTRACT ACCUMULATED EXPONENT MODIFIER 
D1A3  974F                      STA  FP0EXP        ;SAVE AS NEW EXPONENT 
D1A5  23DE                      BLS  LBA39         ;SET FPA0 = 0 IF THE NORMALIZATION CAUSED 
                      *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE  
                      *         SIZE OF THE EXPONENT  
D1A7  8C                        FCB  SKP2          ;SKIP 2 BYTES 
D1A8  2508            LBA5C     BCS  LBA66         ;BRANCH IF MANTISSA OVERFLOW 
D1AA  0863                      ASL  FPSBYT        ;SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF 
                      *                            ;FLAG (TRUNCATE THE REST OF SUB BYTE) 
D1AC  8600                      LDA  #0            ;CLRA, BUT DO NOT CHANGE CARRY FLAG 
D1AE  9763                      STA  FPSBYT        ;CLEAR THE SUB BYTE 
D1B0  200C                      BRA  LBA72         ;GO ROUND-OFF RESULT 
D1B2  0C4F            LBA66     INC  FP0EXP        ;INCREMENT EXPONENT - MULTIPLY BY 2 
D1B4  2728                      BEQ  LBA92         ;OVERFLOW ERROR IF CARRY PAST $FF 
D1B6  0650                      ROR  FPA0          ;* SHIFT MANTISSA 
D1B8  0651                      ROR  FPA0+1        ;* ONE TO 
D1BA  0652                      ROR  FPA0+2        ;* THE RIGHT - 
D1BC  0653                      ROR  FPA0+3        ;* DIVIDE BY TWO 
D1BE  2404            LBA72     BCC  LBA78         ;BRANCH IF NO ROUND-OFF NEEDED 
D1C0  8D0D                      BSR  LBA83         ;ADD ONE TO MANTISSA - ROUND OFF 
D1C2  27EE                      BEQ  LBA66         ;BRANCH iF OVERFLOW - MANTISSA = 0 
D1C4  39              LBA78     RTS                  
                      * NEGATE FPA0 MANTISSA                      
D1C5  0354            LBA79     COM  FP0SGN        ;TOGGLE SIGN OF MANTISSA 
D1C7  0350            LBA7B     COM  FPA0          ;* COMPLEMENT ALL 4 MANTISSA BYTES 
D1C9  0351                      COM  FPA0+1        ;* 
D1CB  0352                      COM  FPA0+2        ;* 
D1CD  0353                      COM  FPA0+3        ;* 
                      * ADD ONE TO FPA0 MANTISSA                      
D1CF  9E52            LBA83     LDX  FPA0+2        ;* GET BOTTOM 2 MANTISSA 
D1D1  3001                      LEAX 1,X           ;* BYTES, ADD ONE TO 
D1D3  9F52                      STX  FPA0+2        ;* THEM AND SAVE THEM 
D1D5  2606                      BNE  LBA91         ;BRANCH IF NO OVERFLOW 
D1D7  9E50                      LDX  FPA0          ;* IF OVERFLOW ADD ONE 
D1D9  3001                      LEAX 1,X           ;* TO TOP 2 MANTISSA 
D1DB  9F50                      STX  FPA0          ;* BYTES AND SAVE THEM 
D1DD  39              LBA91     RTS                  
D1DE  C60A            LBA92     LDB  #2*5          ;OV' OVERFLOW ERROR 
D1E0  7EC403                    JMP  LAC46         ;PROCESS AN ERROR 
D1E3  8E0012          LBA97     LDX  #FPA2-1       ;POINT X TO FPA2 
                      * SHIFT FPA POINTED TO BY (X);TO                      
                      * THE RIGHT -(B) TIMES. EXIT WITH                      
                      * ACCA CONTAINING DATA SHIFTED OUT                      
                      * TO THE RIGHT (SUB BYTE) AND;THE DATA                      
                      * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY                      
D1E6  A604            LBA9A     LDA  4,X           ;GET LS BYTE OF MANTISSA (X) 
D1E8  9763                      STA  FPSBYT        ;SAVE IN FPA SUB BYTE 
D1EA  A603                      LDA  3,X           ;* SHIFT THE NEXT THREE BYTES OF THE 
D1EC  A704                      STA  4,X           ;* MANTISSA RIGHT ONE COMPLETE BYTE. 
D1EE  A602                      LDA  2,X           ;* 
D1F0  A703                      STA  3,X           ;* 
D1F2  A601                      LDA  1,X           ;* 
D1F4  A702                      STA  2,X           ;* 
D1F6  965B                      LDA  FPCARY        ;GET THE CARRY IN BYTE 
D1F8  A701                      STA  1,X           ;STORE AS THE MS MANTISSA BYTE OF (X) 
D1FA  CB08            LBAAE     ADDB #8            ;ADD 8 TO DIFFERENCE OF EXPONENTS 
D1FC  2FE8                      BLE  LBA9A         ;BRANCH IF EXPONENT DIFFERENCE < -8 
D1FE  9663                      LDA  FPSBYT        ;GET FPA SUB BYTE 
D200  C008                      SUBB #8            ;CAST OUT THE 8 ADDED IN ABOVE 
D202  270C                      BEQ  LBAC4         ;BRANCH IF EXPONENT DIFFERENCE = 0 
                                                     
                                                     
D204  6701            LBAB8     ASR  1,X           ;* SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT 
D206  6602            LBABA     ROR  2,X           ;* 
D208  6603                      ROR  3,X           ;* 
D20A  6604                      ROR  4,X           ;* 
D20C  46                        RORA               ;* 
D20D  5C                        INCB               ;ADD ONE TO EXPONENT DIFFERENCE 
D20E  26F4                      BNE  LBAB8         ;BRANCH IF EXPONENTS NOT = 
D210  39              LBAC4     RTS                  
D211  8100000000      LBAC5     FCB  $81,$00,$00,$00,$00 ;FLOATING POINT CONSTANT 1.0 
                                                     
                      * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY                      
                      * FPA0 BY (X) - RETURN PRODUCT IN FPA0                      
D216  8D63            LBACA     BSR  LBB2F         ;MOVE PACKED FPA FROM (X) TO FPA1 
D218  2760            LBACC     BEQ  LBB2E         ;BRANCH IF EXPONENT OF FPA0 = 0 
D21A  8D78                      BSR  LBB48         ;CALCULATE EXPONENT OF PRODUCT 
                      * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE                      
                      * HIGH ORDER BYTES OF PRODUCT;IN FPA0. THE                      
                      * LOW ORDER FOUR BYTES OF THE;PRODUCT WILL                      
                      * BE STORED IN VAB-VAE.                      
D21C  8600            LBAD0     LDA  #0            ;* ZERO OUT MANTISSA OF FPA2 
D21E  9713                      STA  FPA2          ;* 
D220  9714                      STA  FPA2+1        ;* 
D222  9715                      STA  FPA2+2        ;* 
D224  9716                      STA  FPA2+3        ;* 
D226  D653                      LDB  FPA0+3        ;GET LS BYTE OF FPA0 
D228  8D22                      BSR  LBB00         ;MULTIPLY BY FPA1 
D22A  D663                      LDB  FPSBYT        ;* TEMPORARILY SAVE SUB BYTE 4 
D22C  D78B                      STB  VAE           ;* 
D22E  D652                      LDB  FPA0+2        ;GET NUMBER 3 MANTISSA BYTE OF FPA0 
D230  8D1A                      BSR  LBB00         ;MULTIPLY BY FPA1 
D232  D663                      LDB  FPSBYT        ;* TEMPORARILY SAVE SUB BYTE 3 
D234  D78A                      STB  VAD           ;* 
D236  D651                      LDB  FPA0+1        ;GET NUMBER 2 MANTISSA BYTE OF FPA0 
D238  8D12                      BSR  LBB00         ;MULTIPLY BY FPA1 
D23A  D663                      LDB  FPSBYT        ;* TEMPORARILY SAVE SUB BYTE 2 
D23C  D789                      STB  VAC           ;* 
D23E  D650                      LDB  FPA0          ;GET MS BYTE OF FPA0 MANTISSA 
D240  8D0C                      BSR  LBB02         ;MULTIPLY BY FPA1 
D242  D663                      LDB  FPSBYT        ;* TEMPORARILY SAVE SUB BYTE 1 
D244  D788                      STB  VAB           ;* 
D246  BDD357                    JSR  LBC0B         ;COPY MANTISSA FROM FPA2 TO FPA0 
D249  7ED168                    JMP  LBA1C         ;NORMALIZE FPA0 
D24C  2795            LBB00     BEQ  LBA97         ;SHIFT FPA2 ONE BYTE TO RIGHT 
D24E  43              LBB02     COMA               ;SET CARRY FLAG 
                      * MULTIPLY FPA1 MANTISSA BY ACCB AND                      
                      * ADD PRODUCT TO FPA2 MANTISSA                      
D24F  9613            LBB03     LDA  FPA2          ;GET FPA2 MS BYTE 
D251  56                        RORB               ;ROTATE CARRY FLAG INTO SHIFT COUNTER;  
                      *         DATA BIT INTO CARRY  
D252  2726                      BEQ  LBB2E         ;BRANCH WHEN 8 SHIFTS DONE 
D254  2416                      BCC  LBB20         ;DO NOT ADD FPA1 IF DATA BIT = 0 
D256  9616                      LDA  FPA2+3        ;* ADD MANTISSA LS BYTE 
D258  9B60                      ADDA FPA1+3        ;* 
D25A  9716                      STA  FPA2+3        ;* 
D25C  9615                      LDA  FPA2+2        ;= ADD MANTISSA NUMBER 3 BYTE 
D25E  995F                      ADCA FPA1+2        ;= 
D260  9715                      STA  FPA2+2        ;= 
D262  9614                      LDA  FPA2+1        ;* ADD MANTISSA NUMBER 2 BYTE 
D264  995E                      ADCA FPA1+1        ;* 
D266  9714                      STA  FPA2+1        ;* 
D268  9613                      LDA  FPA2          ;= ADD MANTISSA MS BYTE 
D26A  995D                      ADCA FPA1          ;= 
D26C  46              LBB20     RORA               ;* ROTATE CARRY;INTO MS BYTE  
D26D  9713                      STA  FPA2          ;* 
D26F  0614                      ROR  FPA2+1        ;= ROTATE FPA2 ONE BIT TO THE RIGHT 
D271  0615                      ROR  FPA2+2        ;= 
D273  0616                      ROR  FPA2+3        ;= 
D275  0663                      ROR  FPSBYT        ;= 
D277  4F                        CLRA               ;CLEAR CARRY FLAG 
D278  20D5                      BRA  LBB03         ;KEEP LOOPING 
D27A  39              LBB2E     RTS                  
                      * UNPACK A FP NUMBER FROM (X);TO FPA1                      
D27B  EC01            LBB2F     LDD  1,X           ;GET TWO MSB BYTES OF MANTISSA FROM 
                      *         FPA  POINTED TO BY X  
D27D  9761                      STA  FP1SGN        ;SAVE PACKED MANTISSA SIGN BYTE 
D27F  8A80                      ORA  #$80          ;FORCE BIT 7 OF MSB MANTISSA = 1 
D281  DD5D                      STD  FPA1          ;SAVE 2 MSB BYTES IN FPA1 
D283  D661                      LDB  FP1SGN        ;* GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0 
D285  D854                      EORB FP0SGN        ;* SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE, 
D287  D762                      STB  RESSGN        ;* NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED 
                      *                            ;* MANTISSA SIGN BYTE 
D289  EC03                      LDD  3,X           ;= GET 2 LSB BYTES OF MANTISSA 
D28B  DD5F                      STD  FPA1+2        ;= AND PUT IN FPA1 
D28D  A684                      LDA  ,X            ;* GET EXPONENT FROM (X) AND 
D28F  975C                      STA  FP1EXP        ;* PUT IN EXPONENT OF FPA1 
D291  D64F                      LDB  FP0EXP        ;GET EXPONENT OF FPA0 
D293  39                        RTS                  
                      * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1                      
                      * ENTER WITH EXPONENT OF FPA1;IN ACCA                      
D294  4D              LBB48     TSTA               ;TEST EXPONENT OF FPA1 
D295  2716                      BEQ  LBB61         ;PURGE RETURN ADDRESS & SET FPA0 = 0 
D297  9B4F                      ADDA FP0EXP        ;ADD FPA1 EXPONENT TO FPA0 EXPONENT 
D299  46                        RORA               ;ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY 
D29A  49                        ROLA               ;SET OVERFLOW FLAG 
D29B  2810                      BVC  LBB61         ;BRANCH IF EXPONENT TOO LARGE OR SMALL 
D29D  8B80                      ADDA #$80          ;ADD $80 BIAS TO EXPONENT 
D29F  974F                      STA  FP0EXP        ;SAVE NEW EXPONENT 
D2A1  270C                      BEQ  LBB63         ;SET FPA0 
D2A3  9662                      LDA  RESSGN        ;GET MANTISSA SIGN 
D2A5  9754                      STA  FP0SGN        ;SAVE AS MANTISSA SIGN OF FPA0 
D2A7  39                        RTS                  
                      * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0                      
                      * = IS NEGATIVE THEN FPA0 = 0                      
D2A8  9654            LBB5C     LDA  FP0SGN        ;GET MANTISSA SIGN OF FPA0 
D2AA  43                        COMA               ;CHANGE SIGN OF FPA0 MANTISSA 
D2AB  2002                      BRA  LBB63           
D2AD  3262            LBB61     LEAS 2,S           ;PURGE RETURN ADDRESS FROM STACK 
D2AF  102AFED2        LBB63     LBPL LBA39         ;ZERO FPA0 MANTISSA SIGN & EXPONENT 
D2B3  7ED1DE          LBB67     JMP  LBA92         ;OV' OVERFLOW ERROR 
                      * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0                      
D2B6  BDD3AB          LBB6A     JSR  LBC5F         ;TRANSFER FPA0 TO FPA1 
D2B9  270D                      BEQ  LBB7C         ;BRANCH IF EXPONENT = 0 
D2BB  8B02                      ADDA #2            ;ADD 2 TO EXPONENT (TIMES 4) 
D2BD  25F4                      BCS  LBB67         ;OV' ERROR IF EXPONENT > $FF 
D2BF  0F62                      CLR  RESSGN        ;CLEAR RESULT SIGN BYTE 
D2C1  BDD119                    JSR  LB9CD         ;ADD FPA1 TO FPA0 (TIMES 5) 
D2C4  0C4F                      INC  FP0EXP        ;ADD ONE TO EXPONENT (TIMES 10) 
D2C6  27EB                      BEQ  LBB67         ;OV' ERROR IF EXPONENT > $FF 
D2C8  39              LBB7C     RTS                  
D2C9  8420000000      LBB7D     FCB  $84,$20,$00,$00,$00 ;FLOATING POINT CONSTANT 10 
                      * DIVIDE FPA0 BY 10                      
D2CE  BDD3AB          LBB82     JSR  LBC5F         ;MOVE FPA0 TO FPA1 
D2D1  8ED2C9                    LDX  #LBB7D        ;POINT TO FLOATING POINT CONSTANT 10 
D2D4  5F                        CLRB               ;ZERO MANTISSA SIGN BYTE 
D2D5  D762            LBB89     STB  RESSGN        ;STORE THE QUOTIENT MANTISSA SIGN BYTE 
D2D7  BDD360                    JSR  LBC14         ;UNPACK AN FP NUMBER FROM (X) INTO FPA0 
D2DA  8C                        FCB  SKP2          ;SKIP TWO BYTES 
                      * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0                      
D2DB  8D9E            LBB8F     BSR  LBB2F         ;GET FP NUMBER FROM (X) TO FPA1 
                                                     
                      * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH                      
                      * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)                      
                                                     
                      * DIVIDE FPA1 BY FPA0                      
D2DD  2773            LBB91     BEQ  LBC06         ;/0' DIVIDE BY ZERO ERROR 
D2DF  004F                      NEG  FP0EXP        ;GET EXPONENT OF RECIPROCAL OF DIVISOR 
D2E1  8DB1                      BSR  LBB48         ;CALCULATE EXPONENT OF QUOTIENT 
D2E3  0C4F                      INC  FP0EXP        ;INCREMENT EXPONENT 
D2E5  27CC                      BEQ  LBB67         ;OV' OVERFLOW ERROR 
D2E7  8E0013                    LDX  #FPA2         ;POINT X TO MANTISSA OF FPA2 - HOLD 
                      *                            ;TEMPORARY QUOTIENT IN FPA2 
D2EA  C604                      LDB  #4            ;5 BYTE DIVIDE 
D2EC  D703                      STB  TMPLOC        ;SAVE BYTE COUNTER 
D2EE  C601                      LDB  #1            ;SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE 
                      * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -                      
                      * SET CARRY FLAG IF FPA1 >= FPA0                      
D2F0  9650            LBBA4     LDA  FPA0          ;* COMPARE THE TWO MS BYTES 
D2F2  915D                      CMPA FPA1          ;* OF FPA0 AND FPA1 AND 
D2F4  2613                      BNE  LBBBD         ;* BRANCH IF <> 
D2F6  9651                      LDA  FPA0+1        ;= COMPARE THE NUMBER 2 
D2F8  915E                      CMPA FPA1+1        ;= BYTES AND 
D2FA  260D                      BNE  LBBBD         ;= BRANCH IF <> 
D2FC  9652                      LDA  FPA0+2        ;* COMPARE THE NUMBER 3 
D2FE  915F                      CMPA FPA1+2        ;* BYTES AND 
D300  2607                      BNE  LBBBD         ;* BRANCH IF <> 
D302  9653                      LDA  FPA0+3        ;= COMPARE THE LS BYTES 
D304  9160                      CMPA FPA1+3        ;= AND BRANCH 
D306  2601                      BNE  LBBBD         ;= IF <> 
D308  43                        COMA               ;SET CARRY FLAG IF FPA0 = FPA1 
D309  1FA8            LBBBD     TFR  CC,A          ;SAVE CARRY FLAG STATUS IN ACCA; CARRY 
                      *         CLEAR IF FPA0 > FPA1  
D30B  59                        ROLB               ;ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE 
D30C  240A                      BCC  LBBCC         ;CARRY WILL BE SET AFTER 8 SHIFTS 
D30E  E780                      STB  ,X+           ;SAVE TEMPORARY QUOTIENT 
D310  0A03                      DEC  TMPLOC        ;DECREMENT BYTE COUNTER 
D312  2B34                      BMI  LBBFC         ;BRANCH IF DONE 
D314  272E                      BEQ  LBBF8         ;BRANCH IF LAST BYTE 
D316  C601                      LDB  #1            ;RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE 
D318  1F8A            LBBCC     TFR  A,CC          ;RESTORE CARRY FLAG AND 
D31A  250E                      BCS  LBBDE         ;BRANCH IF FPA0 =< FPA1 
D31C  0860            LBBD0     ASL  FPA1+3        ;* SHIFT FPA1 MANTISSA 1 BIT TO LEFT 
D31E  095F                      ROL  FPA1+2        ;* 
D320  095E                      ROL  FPA1+1        ;* 
D322  095D                      ROL  FPA1          ;* 
D324  25E3                      BCS  LBBBD         ;BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT 
D326  2BC8                      BMI  LBBA4         ;IF MSB OF HIGH ORDER MANTISSA BYTE IS 
                      *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1  
D328  20DF                      BRA  LBBBD         ;CARRY IS CLEAR, CHECK ANOTHER BIT 
                      * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1                      
D32A  9660            LBBDE     LDA  FPA1+3        ;* SUBTRACT THE LS BYTES OF MANTISSA 
D32C  9053                      SUBA FPA0+3        ;* 
D32E  9760                      STA  FPA1+3        ;* 
D330  965F                      LDA  FPA1+2        ;= THEN THE NEXT BYTE 
D332  9252                      SBCA FPA0+2        ;= 
D334  975F                      STA  FPA1+2        ;= 
D336  965E                      LDA  FPA1+1        ;* AND THE NEXT 
D338  9251                      SBCA FPA0+1        ;* 
D33A  975E                      STA  FPA1+1        ;* 
D33C  965D                      LDA  FPA1          ;= AND FINALLY, THE MS BYTE OF MANTISSA 
D33E  9250                      SBCA FPA0          ;= 
D340  975D                      STA  FPA1          ;= 
D342  20D8                      BRA  LBBD0         ;GO SHIFT FPA1 
D344  C640            LBBF8     LDB  #$40          ;USE ONLY TWO BITS OF THE LAST BYTE (FIFTH) 
D346  20D0                      BRA  LBBCC         ;GO SHIFT THE LAST BYTE 
D348  56              LBBFC     RORB               ;* SHIFT CARRY (ALWAYS SET HERE) INTO  
D349  56                        RORB               ;* BIT 5 AND MOVE  
D34A  56                        RORB               ;* BITS 1,0 TO BITS 7,6  
D34B  D763                      STB  FPSBYT        ;SAVE SUB BYTE 
D34D  8D08                      BSR  LBC0B         ;MOVE MANTISSA OF FPA2 TO FPA0 
D34F  7ED168                    JMP  LBA1C         ;NORMALIZE FPA0 
D352  C614            LBC06     LDB  #2*10         ;/0' ERROR 
D354  7EC403                    JMP  LAC46         ;PROCESS THE ERROR 
                      * COPY MANTISSA FROM FPA2 TO FPA0                      
D357  9E13            LBC0B     LDX  FPA2          ;* MOVE TOP 2 BYTES 
D359  9F50                      STX  FPA0          ;* 
D35B  9E15                      LDX  FPA2+2        ;= MOVE BOTTOM 2 BYTES 
D35D  9F52                      STX  FPA0+2        ;= 
D35F  39                        RTS                  
                      * COPY A PACKED FP NUMBER FROM (X) TO FPA0                      
D360  3402            LBC14     PSHS A             ;SAVE ACCA 
D362  EC01                      LDD  1,X           ;GET TOP TWO MANTISSA BYTES 
D364  9754                      STA  FP0SGN        ;SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN 
D366  8A80                      ORA  #$80          ;UNPACK MS BYTE 
D368  DD50                      STD  FPA0          ;SAVE UNPACKED TOP 2 MANTISSA BYTES 
D36A  0F63                      CLR  FPSBYT        ;CLEAR MANTISSA SUB BYTE 
D36C  E684                      LDB  ,X            ;GET EXPONENT TO ACCB 
D36E  AE03                      LDX  3,X           ;* MOVE LAST 2 
D370  9F52                      STX  FPA0+2        ;* MANTISSA BYTES 
D372  D74F                      STB  FP0EXP        ;SAVE EXPONENT 
D374  3582                      PULS A,PC          ;RESTORE ACCA AND RETURN 
                                                     
D376  8E0045          LBC2A     LDX  #V45          ;POINT X TO MANTISSA OF FPA4 
D379  2006                      BRA  LBC35         ;MOVE FPA0 TO FPA4 
D37B  8E0040          LBC2F     LDX  #V40          ;POINT X TO MANTISSA OF FPA3 
D37E  8C                        FCB  SKP2          ;SKIP TWO BYTES 
D37F  9E3B            LBC33     LDX  VARDES        ;POINT X TO VARIABLE DESCRIPTOR IN VARDES 
                      * PACK FPA0 AND MOVE IT TO ADDRESS IN X                      
D381  964F            LBC35     LDA  FP0EXP        ;* COPY EXPONENT 
D383  A784                      STA  ,X            ;* 
D385  9654                      LDA  FP0SGN        ;GET MANTISSA SIGN BIT 
D387  8A7F                      ORA  #$7F          ;MASK THE BOTTOM 7 BITS 
D389  9450                      ANDA FPA0          ;AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE 
D38B  A701                      STA  1,X           ;SAVE MS BYTE 
D38D  9651                      LDA  FPA0+1        ;* MOVE 2ND MANTISSA BYTE 
D38F  A702                      STA  2,X           ;* 
D391  DE52                      LDU  FPA0+2        ;= MOVE BOTTOM 2 MANTISSA BYTES 
D393  EF03                      STU  3,X           ;= 
D395  39                        RTS                  
                      * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA                      
D396  9661            LBC4A     LDA  FP1SGN        ;* COPY MANTISSA SIGN FROM 
D398  9754            LBC4C     STA  FP0SGN        ;* FPA1 TO FPA0 
D39A  9E5C                      LDX  FP1EXP        ;= COPY EXPONENT + MS BYTE FROM 
D39C  9F4F                      STX  FP0EXP        ;= FPA1 TO FPA0 
D39E  0F63                      CLR  FPSBYT        ;CLEAR MANTISSA SUB BYTE 
D3A0  965E                      LDA  FPA1+1        ;* COPY 2ND MANTISSA BYTE 
D3A2  9751                      STA  FPA0+1        ;* FROM FPA1 TO FPA0 
D3A4  9654                      LDA  FP0SGN        ;GET MANTISSA SIGN 
D3A6  9E5F                      LDX  FPA1+2        ;* COPY 3RD AND 4TH MANTISSA BYTE 
D3A8  9F52                      STX  FPA0+2        ;* FROM FPA1 TO FPA0 
D3AA  39                        RTS                  
                      * TRANSFER FPA0 TO FPA1                      
D3AB  DC4F            LBC5F     LDD  FP0EXP        ;* TRANSFER EXPONENT & MS BYTE 
D3AD  DD5C                      STD  FP1EXP        ;* 
D3AF  9E51                      LDX  FPA0+1        ;= TRANSFER MIDDLE TWO BYTES 
D3B1  9F5E                      STX  FPA1+1        ;= 
D3B3  9E53                      LDX  FPA0+3        ;* TRANSFER BOTTOM TWO BYTES 
D3B5  9F60                      STX  FPA1+3        ;* 
D3B7  4D                        TSTA               ;SET FLAGS ACCORDING TO EXPONENT 
D3B8  39                        RTS                  
                      * CHECK FPA0; RETURN ACCB = 0;IF FPA0 = 0,                      
                      * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE                      
D3B9  D64F            LBC6D     LDB  FP0EXP        ;GET EXPONENT 
D3BB  2708                      BEQ  LBC79         ;BRANCH IF FPA0 = 0 
D3BD  D654            LBC71     LDB  FP0SGN        ;GET SIGN OF MANTISSA 
D3BF  59              LBC73     ROLB               ;BIT 7 TO CARRY 
D3C0  C6FF                      LDB  #$FF          ;NEGATIVE FLAG 
D3C2  2501                      BCS  LBC79         ;BRANCH IF NEGATIVE MANTISSA 
D3C4  50                        NEGB               ;ACCB = 1 IF POSITIVE MANTISSA 
D3C5  39              LBC79     RTS                  
                                                     
                      * SGN                          
D3C6  8DF1            SGN       BSR  LBC6D         ;SET ACCB ACCORDING TO SIGN OF FPA0 
                      * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER                      
D3C8  D750            LBC7C     STB  FPA0          ;SAVE ACCB IN FPA0 
D3CA  0F51                      CLR  FPA0+1        ;CLEAR NUMBER 2 MANTISSA BYTE OF FPA0 
D3CC  C688                      LDB  #$88          ;EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER 
D3CE  9650            LBC82     LDA  FPA0          ;GET MS BYTE OF MANTISSA 
D3D0  8080                      SUBA #$80          ;SET CARRY IF POSITIVE MANTISSA 
D3D2  D74F            LBC86     STB  FP0EXP        ;SAVE EXPONENT 
D3D4  DC74                      LDD  ZERO          ;* ZERO OUT ACCD AND 
D3D6  DD52                      STD  FPA0+2        ;* BOTTOM HALF OF FPA0 
D3D8  9763                      STA  FPSBYT        ;CLEAR SUB BYTE 
D3DA  9754                      STA  FP0SGN        ;CLEAR SIGN OF FPA0 MANTISSA 
D3DC  7ED164                    JMP  LBA18         ;GO NORMALIZE FPA0 
                                                     
                      * ABS                          
D3DF  0F54            ABS       CLR  FP0SGN        ;FORCE MANTISSA SIGN OF FPA0 POSITIVE 
D3E1  39                        RTS                  
                      * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO                      
                      * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN                      
                      * ZERO FLAG SET AND ACCB = 0,;IF EQUAL; ACCB = 1 IF                      
                      * FPA0 > (X); ACCB = $FF IF FPA0 < (X)                      
D3E2  E684            LBC96     LDB  ,X            ;CHECK EXPONENT OF (X) 
D3E4  27D3                      BEQ  LBC6D         ;BRANCH IF FPA = 0 
D3E6  E601                      LDB  1,X           ;GET MS BYTE OF MANTISSA OF (X) 
D3E8  D854                      EORB FP0SGN        ;EOR WITH SIGN OF FPA0 
D3EA  2BD1                      BMI  LBC71         ;BRANCH IF SIGNS NOT = 
                      * COMPARE FPA0 WITH FP NUMBER;POINTED TO BY (X).                      
                      * FPA0 IS NORMALIZED, (X) IS PACKED.                      
D3EC  D64F            LBCA0     LDB  FP0EXP        ;* GET EXPONENT OF 
D3EE  E184                      CMPB ,X            ;* FPA0, COMPARE TO EXPONENT OF 
D3F0  261D                      BNE  LBCC3         ;* (X) AND BRANCH IF <>. 
D3F2  E601                      LDB  1,X           ;* GET MS BYTE OF (X), KEEP ONLY 
D3F4  CA7F                      ORB  #$7F          ;* THE SIGN BIT - 'AND' THE BOTTOM 7 
D3F6  D450                      ANDB FPA0          ;* BITS OF FPA0 INTO ACCB 
D3F8  E101                      CMPB 1,X           ;= COMPARE THE BOTTOM 7 BITS OF THE MANTISSA 
D3FA  2613                      BNE  LBCC3         ;= MS BYTE AND BRANCH IF <> 
D3FC  D651                      LDB  FPA0+1        ;* COMPARE 2ND BYTE 
D3FE  E102                      CMPB 2,X           ;* OF MANTISSA, 
D400  260D                      BNE  LBCC3         ;* BRANCH IF <> 
D402  D652                      LDB  FPA0+2        ;= COMPARE 3RD BYTE 
D404  E103                      CMPB 3,X           ;= OF MANTISSA, 
D406  2607                      BNE  LBCC3         ;= BRANCH IF <> 
D408  D653                      LDB  FPA0+3        ;* SUBTRACT LS BYTE 
D40A  E004                      SUBB 4,X           ;* OF (X) FROM LS BYTE OF 
D40C  2601                      BNE  LBCC3         ;* FPA0, BRANCH IF <> 
D40E  39                        RTS                ;RETURN IF FP (X) = FPA0 
D40F  56              LBCC3     RORB               ;SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X) 
D410  D854                      EORB FP0SGN        ;TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE 
D412  20AB                      BRA  LBC73         ;GO SET ACCB ACCORDING TO COMPARISON 
                      * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT                      
                      * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA                      
D414  D64F            LBCC8     LDB  FP0EXP        ;GET EXPONENT OF FPA0 
D416  273D                      BEQ  LBD09         ;ZERO MANTISSA IF FPA0 = 0 
D418  C0A0                      SUBB #$A0          ;SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD 
                      *                            ;THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN 
                      *                            ;THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT 
                      *                            ;WILL BE TO THE RIGHT OF THE MANTISSA 
D41A  9654                      LDA  FP0SGN        ;TEST SIGN OF FPA0 MANTISSA 
D41C  2A05                      BPL  LBCD7         ;BRANCH IF POSITIVE 
D41E  035B                      COM  FPCARY        ;COMPLEMENT CARRY IN BYTE 
D420  BDD1C7                    JSR  LBA7B         ;NEGATE MANTISSA OF FPA0 
D423  8E004F          LBCD7     LDX  #FP0EXP       ;POINT X TO FPA0 
D426  C1F8                      CMPB #-8           ;EXPONENT DIFFERENCE < -8? 
D428  2E06                      BGT  LBCE4         ;YES 
D42A  BDD1FA                    JSR  LBAAE         ;SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0 
D42D  0F5B                      CLR  FPCARY        ;CLEAR CARRY IN BYTE 
D42F  39                        RTS                  
D430  0F5B            LBCE4     CLR  FPCARY        ;CLEAR CARRY IN BYTE 
D432  9654                      LDA  FP0SGN        ;* GET SIGN OF FPA0 MANTISSA 
D434  49                        ROLA               ;* ROTATE IT INTO THE CARRY FLAG 
D435  0650                      ROR  FPA0          ;ROTATE CARRY (MANTISSA SIGN) INTO BIT 7 
                      *                            ;OF LS BYTE OF MANTISSA 
D437  7ED206                    JMP  LBABA         ;DE-NORMALIZE FPA0 
                                                     
                      * INT                          
                      * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT                      
                      * TO THE EXTREME RIGHT OF THE;MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE                      
                      * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT                      
                      * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION                      
                      * ONLY THE INTEGER PORTION OF;FPA0 WILL REMAIN.                      
                      *                              
D43A  D64F            INT       LDB  FP0EXP        ;GET EXPONENT OF FPA0 
D43C  C1A0                      CMPB #$A0          ;LARGEST POSSIBLE INTEGER EXPONENT 
D43E  241D                      BCC  LBD11         ;RETURN IF FPA0 >= 32768 
D440  8DD2                      BSR  LBCC8         ;SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE 
                      *                            ;LS BYTE OF THE FPA0 MANTISSA 
D442  D763                      STB  FPSBYT        ;ACCB = 0: ZERO OUT THE SUB BYTE 
D444  9654                      LDA  FP0SGN        ;GET MANTISSA SIGN 
D446  D754                      STB  FP0SGN        ;FORCE MANTISSA SIGN TO BE POSITIVE 
D448  8080                      SUBA #$80          ;SET CARRY IF MANTISSA 
D44A  86A0                      LDA  #$A0          ;* GET DENORMALIZED EXPONENT AND 
D44C  974F                      STA  FP0EXP        ;* SAVE IT IN FPA0 EXPONENT 
D44E  9653                      LDA  FPA0+3        ;= GET LS BYTE OF FPA0 AND 
D450  9701                      STA  CHARAC        ;= SAVE IT IN CHARAC 
D452  7ED164                    JMP  LBA18         ;NORMALIZE FPA0 
                                                     
D455  D750            LBD09     STB  FPA0          ;* LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB 
D457  D751                      STB  FPA0+1        ;* 
D459  D752                      STB  FPA0+2        ;* 
D45B  D753                      STB  FPA0+3        ;* 
D45D  39              LBD11     RTS                ;* 
                                                     
                      * CONVERT ASCII STRING TO FLOATING POINT                      
D45E  9E74            LBD12     LDX  ZERO          ;(X) = 0 
D460  9F54                      STX  FP0SGN        ;* ZERO OUT FPA0 & THE SIGN FLAG (COEFCT) 
D462  9F4F                      STX  FP0EXP        ;* 
D464  9F51                      STX  FPA0+1        ;* 
D466  9F52                      STX  FPA0+2        ;* 
D468  9F47                      STX  V47           ;INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO 
D46A  9F45                      STX  V45           ;INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0 
D46C  2564                      BCS  LBD86         ;IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST 
                      *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK  
D46E  BDDB9B                    JSR  XVEC19        ;CALL EXTENDED BASIC ADD-IN 
D471  812D            LBD25     CMPA #'-           ;* CHECK FOR A LEADING MINUS SIGN AND BRANCH 
D473  2604                      BNE  LBD2D         ;* IF NO MINUS SIGN 
D475  0355                      COM  COEFCT        ;TOGGLE SIGN; 0 = +; FF = - 
D477  2004                      BRA  LBD31         ;INTERPRET THE REST OF THE STRING 
D479  812B            LBD2D     CMPA #'+           ;* CHECK FOR LEADING PLUS SlGN AND BRANCH 
D47B  2604                      BNE  LBD35         ;* IF NOT A PLUS SIGN 
D47D  9D7C            LBD31     JSR  GETNCH        ;GET NEXT INPUT CHARACTER FROM BASIC 
D47F  2551                      BCS  LBD86         ;BRANCH IF NUMERIC CHARACTER 
D481  812E            LBD35     CMPA #'.           ;DECIMAL POlNT? 
D483  2728                      BEQ  LBD61         ;YES 
D485  8145                      CMPA #'E           ;"E" SHORTHAND FORM (SCIENTIFIC NOTATION)? 
D487  2628                      BNE  LBD65         ;NO 
                      * EVALUATE EXPONENT OF EXPONENTIAL FORMAT                      
D489  9D7C                      JSR  GETNCH        ;GET NEXT INPUT CHARACTER FROM BASIC 
D48B  2564                      BCS  LBDA5         ;BRANCH IF NUMERIC 
D48D  81A7                      CMPA #TOK_MINUS    ;MINUS TOKEN? 
D48F  270E                      BEQ  LBD53         ;YES 
D491  812D                      CMPA #'-           ;ASCII MINUS? 
D493  270A                      BEQ  LBD53         ;YES 
D495  81A6                      CMPA #TOK_PLUS     ;PLUS TOKEN? 
D497  2708                      BEQ  LBD55         ;YES 
D499  812B                      CMPA #'+           ;ASCII PLUS? 
D49B  2704                      BEQ  LBD55         ;YES 
D49D  2006                      BRA  LBD59         ;BRANCH IF NO SIGN FOUND 
D49F  0348            LBD53     COM  V48           ;SET EXPONENT SIGN FLAG TO NEGATIVE 
                      * STRIP A DECIMAL NUMBER FROM;BASIC LINE, CONVERT IT TO BINARY IN V47                      
D4A1  9D7C            LBD55     JSR  GETNCH        ;GET NEXT INPUT CHARACTER FROM BASIC 
D4A3  254C                      BCS  LBDA5         ;IF NUMERIC CHARACTER, CONVERT TO BINARY 
D4A5  0D48            LBD59     TST  V48           ;* CHECK EXPONENT SIGN FLAG 
D4A7  2708                      BEQ  LBD65         ;* AND BRANCH IF POSITIVE 
D4A9  0047                      NEG  V47           ;NEGATE VALUE OF EXPONENT 
D4AB  2004                      BRA  LBD65           
D4AD  0346            LBD61     COM  V46           ;*TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER 
D4AF  26CC                      BNE  LBD31         ;*CHARACTER IF <> 0 - TERMINATE INTERPRETATION 
                      *         IF   SECOND DECIMAL;POINT  
                      * ADJUST FPA0 FOR THE DECIMAL;EXPONENT IN V47                      
D4B1  9647            LBD65     LDA  V47           ;* GET EXPONENT, SUBTRACT THE NUMBER OF 
D4B3  9045                      SUBA V45           ;* PLACES TO THE RIGHT OF DECIMAL POINT 
D4B5  9747                      STA  V47           ;* AND RESAVE IT. 
D4B7  2712                      BEQ  LBD7F         ;EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO 
D4B9  2A09                      BPL  LBD78         ;BRANCH IF POSITIVE EXPONENT 
D4BB  BDD2CE          LBD6F     JSR  LBB82         ;DIVIDE FPA0 BY 10 
D4BE  0C47                      INC  V47           ;INCREMENT EXPONENT COUNTER (MULTIPLY BY 10) 
D4C0  26F9                      BNE  LBD6F         ;KEEP MULTIPLYING 
D4C2  2007                      BRA  LBD7F         ;EXIT ROUTINE 
D4C4  BDD2B6          LBD78     JSR  LBB6A         ;MULTIPLY FPA0 BY 10 
D4C7  0A47                      DEC  V47           ;DECREMENT EXPONENT COUNTER (DIVIDE BY 10) 
D4C9  26F9                      BNE  LBD78         ;KEEP MULTIPLYING 
D4CB  9655            LBD7F     LDA  COEFCT        ;GET THE SIGN FLAG 
D4CD  2A8E                      BPL  LBD11         ;RETURN IF POSITIVE 
D4CF  7ED635                    JMP  LBEE9         ;TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE 
                      *MULTIPLY FPA0 BY TEN AND ADD;ACCA TO THE RESULT                      
D4D2  D645            LBD86     LDB  V45           ;*GET THE RIGHT DECIMAL COUNTER AND SUBTRACT 
D4D4  D046                      SUBB V46           ;*THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT 
D4D6  D745                      STB  V45           ;*FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS 
                      *                            ;-1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE 
D4D8  3402                      PSHS A             ;SAVE NEW DIGIT ON STACK 
D4DA  BDD2B6                    JSR  LBB6A         ;MULTIPLY FPA0 BY 10 
D4DD  3504                      PULS B             ;GET NEW DIGIT BACK 
D4DF  C030                      SUBB #'0           ;MASK OFF ASCII 
D4E1  8D02                      BSR  LBD99         ;ADD ACCB TO FPA0 
D4E3  2098                      BRA  LBD31         ;GET ANOTHER CHARACTER FROM BASIC 
D4E5  BDD37B          LBD99     JSR  LBC2F         ;PACK FPA0 AND SAVE IT IN FPA3 
D4E8  BDD3C8                    JSR  LBC7C         ;CONVERT ACCB TO FP NUMBER IN FPA0 
D4EB  8E0040                    LDX  #V40          ;* ADD FPA0 TO 
D4EE  7ED10E                    JMP  LB9C2         ;* FPA3 
                                                     
                                                     
D4F1  D647            LBDA5     LDB  V47             
D4F3  58                        ASLB               ;TIMES 2 
D4F4  58                        ASLB               ;TIMES 4 
D4F5  DB47                      ADDB V47           ;ADD 1 = TIMES 5 
D4F7  58                        ASLB               ;TIMES 10 
D4F8  8030                      SUBA #'0           ;*MASK OFF ASCII FROM ACCA, PUSH 
D4FA  3404                      PSHS B             ;*RESULT ONTO THE STACK AND 
D4FC  ABE0                      ADDA ,S+           ;ADD lT TO ACCB 
D4FE  9747                      STA  V47           ;SAVE IN V47 
D500  209F                      BRA  LBD55         ;INTERPRET ANOTHER CHARACTER 
                      *                              
D502  9B3EBC1FFD      LBDB6     FCB  $9B,$3E,$BC,$1F,$FD ;* 99999999.9 
D507  9E6E6B27FD      LBDBB     FCB  $9E,$6E,$6B,$27,$FD ;* 999999999 
D50C  9E6E6B2800      LBDC0     FCB  $9E,$6E,$6B,$28,$00 ;* 1E + 09 
                      *                              
D511  8EC3A4          LBDC5     LDX  #LABE8-1      ;POINT X TO " IN " MESSAGE 
D514  8D0C                      BSR  LBDD6         ;COPY A STRING FROM (X) TO CONSOLE OUT 
D516  DC68                      LDD  CURLIN        ;GET CURRENT BASIC LINE NUMBER TO ACCD 
                      * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER                      
                      * AND PRINT IT TO CONSOLE OUT                      
D518  DD50            LBDCC     STD  FPA0          ;SAVE ACCD IN TOP HALF OF FPA0 
D51A  C690                      LDB  #$90          ;REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
D51C  43                        COMA               ;SET CARRY FLAG - FORCE POSITIVE MANTISSA 
D51D  BDD3D2                    JSR  LBC86         ;ZERO BOTTOM HALF AND SIGN OF FPA0, THEN 
                      *         SAVE EXPONENT AND NORMALIZE IT  
D520  8D03                      BSR  LBDD9         ;CONVERT FP NUMBER TO ASCII STRING 
D522  7ED0E8          LBDD6     JMP  LB99C         ;COPY A STRING FROM (X) TO CONSOLE OUT 
                                                     
                      * CONVERT FP NUMBER TO ASCII STRING                      
D525  CE01F1          LBDD9     LDU  #STRBUF+3     ;POINT U TO BUFFER WHICH WILL NOT CAUSE 
                      *                            ;THE STRING TO BE STORED IN STRING SPACE 
D528  8620            LBDDC     LDA  #SPACE        ;SPACE = DEFAULT SIGN FOR POSITIVE # 
D52A  D654                      LDB  FP0SGN        ;GET SIGN OF FPA0 
D52C  2A02                      BPL  LBDE4         ;BRANCH IF POSITIVE 
D52E  862D                      LDA  #'-           ;ASCII MINUS SIGN 
D530  A7C0            LBDE4     STA  ,U+           ;STORE SIGN OF NUMBER 
D532  DF64                      STU  COEFPT        ;SAVE BUFFER POINTER 
D534  9754                      STA  FP0SGN        ;SAVE SIGN (IN ASCII) 
D536  8630                      LDA  #'0           ;ASCII ZERO IF EXPONENT = 0 
D538  D64F                      LDB  FP0EXP        ;GET FPA0 EXPONENT 
D53A  102700C6                  LBEQ LBEB8         ;BRANCH IF FPA0 = 0 
D53E  4F                        CLRA               ;BASE 10 EXPONENT=0 FOR FP NUMBER > 1 
D53F  C180                      CMPB #$80          ;CHECK EXPONENT 
D541  2208                      BHI  LBDFF         ;BRANCH IF FP NUMBER > 1 
                      * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS                      
D543  8ED50C                    LDX  #LBDC0        ;POINT X TO FP 1E+09 
D546  BDD216                    JSR  LBACA         ;MULTIPLY FPA0 BY (X) 
D549  86F7                      LDA  #-9           ;BASE 10 EXPONENT = -9 
D54B  9745            LBDFF     STA  V45           ;BASE 10 EXPONENT 
                      * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE                      
                      * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST                      
                      * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE                      
                      * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING                      
                      * SCIENTIFIC NOTATION                      
D54D  8ED507          LBE01     LDX  #LBDBB        ;POINT X TO FP 999,999,999 
D550  BDD3EC                    JSR  LBCA0         ;COMPARE FPA0 TO 999,999,999 
D553  2E0F                      BGT  LBE18         ;BRANCH IF > 999,999,999 
D555  8ED502          LBE09     LDX  #LBDB6        ;POINT X TO FP 99,999,999.9 
D558  BDD3EC                    JSR  LBCA0         ;COMPARE FPA0 TO 99,999,999.9 
D55B  2E0E                      BGT  LBE1F         ;BRANCH IF > 99,999,999.9 (IN RANGE) 
D55D  BDD2B6                    JSR  LBB6A         ;MULTIPLY FPA0 BY 10 
D560  0A45                      DEC  V45           ;SUBTRACT ONE FROM DECIMAL OFFSET 
D562  20F1                      BRA  LBE09         ;PSEUDO - NORMALIZE SOME MORE 
D564  BDD2CE          LBE18     JSR  LBB82         ;DIVIDE FPA0 BY 10 
D567  0C45                      INC  V45           ;ADD ONE TO BASE 10 EXPONENT 
D569  20E2                      BRA  LBE01         ;PSEUDO - NORMALIZE SOME MORE 
D56B  BDD100          LBE1F     JSR  LB9B4         ;ADD .5 TO FPA0 (ROUND OFF) 
D56E  BDD414                    JSR  LBCC8         ;CONVERT FPA0 TO AN INTEGER 
D571  C601                      LDB  #1            ;DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT) 
D573  9645                      LDA  V45           ;* GET BASE 10 EXPONENT AND ADD TEN TO IT 
D575  8B0A                      ADDA #9+1          ;* (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
D577  2B09                      BMI  LBE36         ;BRANCH IF NUMBER < 1.0 
D579  810B                      CMPA #9+2          ;NINE PLACES MAY BE DISPLAYED WITHOUT 
                      *         USING SCIENTIFIC NOTATION  
D57B  2405                      BCC  LBE36         ;BRANCH IF SCIENTIFIC NOTATION REQUIRED 
D57D  4A                        DECA               ;* SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR 
D57E  1F89                      TFR  A,B           ;* AND SAVE IT IN ACCB (DECiMAL POINT FLAG) 
D580  8602                      LDA  #2            ;FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION 
D582  4A              LBE36     DECA               ;* SUBTRACT TWO (WITHOUT AFFECTING CARRY) 
D583  4A                        DECA               ;* FROM BASE 10 EXPONENT 
D584  9747                      STA  V47           ;SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY 
                      *         IN   SCIENTIFIC NOTATION  
D586  D745                      STB  V45           ;DECIMAL POINT FLAG - NUMBER OF PLACES TO 
                      *         LEFT OF DECIMAL POINT  
D588  2E0D                      BGT  LBE4B         ;BRANCH IF >= 1 
D58A  DE64                      LDU  COEFPT        ;POINT U TO THE STRING BUFFER 
D58C  862E                      LDA  #'.           ;* STORE A PERIOD 
D58E  A7C0                      STA  ,U+           ;* IN THE BUFFER 
D590  5D                        TSTB               ;CHECK DECIMAL POINT FLAG  
D591  2704                      BEQ  LBE4B         ;BRANCH IF NOTHING TO LEFT OF DECIMAL POINT 
D593  8630                      LDA  #'0           ;* STORE A ZERO 
D595  A7C0                      STA  ,U+           ;* IN THE BUFFER 
                                                     
                      * CONVERT FPA0 INTO A STRING OF ASCII DIGITS                      
D597  8ED611          LBE4B     LDX  #LBEC5        ;POINT X TO FP POWER OF 10 MANTISSA 
D59A  C680                      LDB  #0+$80        ;INITIALIZE DIGIT COUNTER TO 0+$80 
                      * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA                      
                      * IS NEGATIVE. WHEN YOU 'ADD';A NEGATIVE MANTISSA, IT IS                      
                      * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW                      
                      * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.                      
D59C  9653            LBE50     LDA  FPA0+3        ;* ADD MANTISSA LS 
D59E  AB03                      ADDA 3,X           ;* BYTE OF FPA0 
D5A0  9753                      STA  FPA0+3        ;* AND (X) 
D5A2  9652                      LDA  FPA0+2        ;= ADD MANTISSA 
D5A4  A902                      ADCA 2,X           ;= NUMBER 3 BYTE OF 
D5A6  9752                      STA  FPA0+2        ;= FPA0 AND (X) 
D5A8  9651                      LDA  FPA0+1        ;* ADD MANTISSA 
D5AA  A901                      ADCA 1,X           ;* NUMBER 2 BYTE OF 
D5AC  9751                      STA  FPA0+1        ;* FPA0 AND (X) 
D5AE  9650                      LDA  FPA0          ;= ADD MANTISSA 
D5B0  A984                      ADCA ,X            ;= MS BYTE OF 
D5B2  9750                      STA  FPA0          ;= FPA0 AND (X) 
D5B4  5C                        INCB               ;ADD ONE TO DIGIT COUNTER 
D5B5  56                        RORB               ;ROTATE CARRY INTO BIT 7  
D5B6  59                        ROLB               ;*SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND 
D5B7  28E3                      BVC  LBE50         ;*POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA 
D5B9  2403                      BCC  LBE72         ;BRANCH IF NEGATIVE MANTISSA 
D5BB  C00B                      SUBB #10+1         ;* TAKE THE 9'S COMPLEMENT IF
D5BD  50                        NEGB               ;* ADDING MANTISSA 
D5BE  CB2F            LBE72     ADDB #'0-1         ;ADD ASCII OFFSET TO DIGIT 
D5C0  3004                      LEAX 4,X           ;MOVE TO NEXT POWER OF 10 MANTISSA 
D5C2  1F98                      TFR  B,A           ;SAVE DIGIT IN ACCA 
D5C4  847F                      ANDA #$7F          ;MASK OFF BIT 7 (ADD/SUBTRACT FLAG) 
D5C6  A7C0                      STA  ,U+           ;STORE DIGIT IN STRING BUFFER 
D5C8  0A45                      DEC  V45           ;DECREMENT DECIMAL POINT FLAG 
D5CA  2604                      BNE  LBE84         ;BRANCH IF NOT TIME FOR DECIMAL POINT 
D5CC  862E                      LDA  #'.           ;* STORE DECIMAL POINT IN 
D5CE  A7C0                      STA  ,U+           ;* STRING BUFFER 
D5D0  53              LBE84     COMB               ;TOGGLE BIT 7 (ADD/SUBTRACT FLAG) 
D5D1  C480                      ANDB #$80          ;MASK OFF ALL BUT ADD/SUBTRACT FLAG 
D5D3  8CD635                    CMPX #LBEC5+36     ;COMPARE X TO END OF MANTISSA TABLE 
D5D6  26C4                      BNE  LBE50         ;BRANCH IF NOT AT END OF TABLE 
                      * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY                      
D5D8  A6C2            LBE8C     LDA  ,-U           ;GET THE LAST CHARACTER; MOVE POINTER BACK 
D5DA  8130                      CMPA #'0           ;WAS IT A ZERO? 
D5DC  27FA                      BEQ  LBE8C         ;IGNORE TRAILING ZEROS IF SO 
D5DE  812E                      CMPA #'.           ;CHECK FOR DECIMAL POINT 
D5E0  2602                      BNE  LBE98         ;BRANCH IF NOT DECIMAL POINT 
D5E2  335F                      LEAU -1,U          ;STEP OVER THE DECIMAL POINT 
D5E4  862B            LBE98     LDA  #'+           ;ASCII PLUS SIGN 
D5E6  D647                      LDB  V47           ;GET SCIENTIFIC NOTATION EXPONENT 
D5E8  271C                      BEQ  LBEBA         ;BRANCH IF NOT SCIENTIFIC NOTATION 
D5EA  2A03                      BPL  LBEA3         ;BRANCH IF POSITIVE EXPONENT 
D5EC  862D                      LDA  #'-           ;ASCII MINUS SIGN 
D5EE  50                        NEGB               ;NEGATE EXPONENT IF NEGATIVE 
D5EF  A742            LBEA3     STA  2,U           ;STORE EXPONENT SIGN IN STRING 
D5F1  8645                      LDA  #'E           ;* GET ASCII 'E' (SCIENTIFIC NOTATION
D5F3  A741                      STA  1,U           ;* FLAG) AND SAVE IT IN THE STRING 
D5F5  862F                      LDA  #'0-1         ;INITIALIZE ACCA TO ASCII ZERO 
                                                     
                                                     
D5F7  4C              LBEAB     INCA               ;ADD ONE TO 10'S DIGIT OF EXPONENT
D5F8  C00A                      SUBB #10           ;SUBTRACT 10 FROM ACCB 
D5FA  24FB                      BCC  LBEAB         ;ADD 1 TO 10'S DIGIT IF NO CARRY
D5FC  CB3A                      ADDB #'9+1         ;CONVERT UNITS DIGIT TO ASCII 
D5FE  ED43                      STD  3,U           ;SAVE EXPONENT IN STRING 
D600  6F45                      CLR  5,U           ;CLEAR LAST BYTE (TERMINATOR) 
D602  2004                      BRA  LBEBC         ;GO RESET POINTER 
D604  A7C4            LBEB8     STA  ,U            ;STORE LAST CHARACTER 
D606  6F41            LBEBA     CLR  1,U           ;CLEAR LAST BYTE (TERMINATOR - REQUIRED BY 
                      *         PRINT SUBROUTINES)    
D608  8E01F1          LBEBC     LDX  #STRBUF+3     ;RESET POINTER TO START OF BUFFER 
D60B  39                        RTS                  
                      *                              
D60C  8000000000      LBEC0     FCB  $80,$00,$00,$00,$00 ;FLOATING POINT .5 
                      *                              
                      *** TABLE OF UNNORMALIZED POWERS OF 10                      
D611  FA0A1F00        LBEC5     FCB  $FA,$0A,$1F,$00 ;-100000000 
D615  00989680        LBEC9     FCB  $00,$98,$96,$80 ;10000000 
D619  FFF0BDC0        LBECD     FCB  $FF,$F0,$BD,$C0 ;-1000000 
D61D  000186A0        LBED1     FCB  $00,$01,$86,$A0 ;100000 
D621  FFFFD8F0        LBED5     FCB  $FF,$FF,$D8,$F0 ;-10000 
D625  000003E8        LBED9     FCB  $00,$00,$03,$E8 ;1000 
D629  FFFFFF9C        LBEDD     FCB  $FF,$FF,$FF,$9C ;-100 
D62D  0000000A        LBEE1     FCB  $00,$00,$00,$0A ;10 
D631  FFFFFFFF        LBEE5     FCB  $FF,$FF,$FF,$FF ;-1 
                      *                              
                      *                              
D635  964F            LBEE9     LDA  FP0EXP        ;GET EXPONENT OF FPA0 
D637  2702                      BEQ  LBEEF         ;BRANCH IF FPA0 = 0 
D639  0354                      COM  FP0SGN        ;TOGGLE MANTISSA SIGN OF FPA0 
D63B  39              LBEEF     RTS                  
                      * EXPAND A POLYNOMIAL OF THE FORM                      
                      * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0                      
                      * AND THE X REGISTER POINTS TO A TABLE OF                      
                      * COEFFICIENTS A,B,C,D....                      
D63C  9F64            LBEF0     STX  COEFPT        ;SAVE COEFFICIENT TABLE POINTER 
D63E  BDD37B                    JSR  LBC2F         ;MOVE FPA0 TO FPA3 
D641  8D05                      BSR  LBEFC         ;MULTIPLY FPA3 BY FPA0 
D643  8D08                      BSR  LBF01         ;EXPAND POLYNOMIAL 
D645  8E0040                    LDX  #V40          ;POINT X TO FPA3 
D648  7ED216          LBEFC     JMP  LBACA         ;MULTIPLY (X) BY FPA0 
                                                     
                      * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL                      
                      * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE                      
                      * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE                      
                      * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER                      
                      * OF PACKED FLOATING POINT NUMBERS. THE                      
                      * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =                      
                      * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0'YN)
D64B  9F64            LBEFF     STX  COEFPT        ;SAVE COEFFICIENT TABLE POINTER 
D64D  BDD376          LBF01     JSR  LBC2A         ;MOVE FPA0 TO FPA4 
D650  9E64                      LDX  COEFPT        ;GET THE COEFFICIENT POINTER 
D652  E680                      LDB  ,X+           ;GET THE TOP OF COEFFICIENT TABLE TO 
D654  D755                      STB  COEFCT        ;* USE AND STORE IT IN TEMPORARY COUNTER 
D656  9F64                      STX  COEFPT        ;SAVE NEW COEFFICIENT POINTER 
D658  8DEE            LBF0C     BSR  LBEFC         ;MULTIPLY (X) BY FPA0 
D65A  9E64                      LDX  COEFPT        ;*GET COEFFICIENT POINTER 
D65C  3005                      LEAX 5,X           ;*MOVE TO NEXT FP NUMBER 
D65E  9F64                      STX  COEFPT        ;*SAVE NEW COEFFICIENT POINTER 
D660  BDD10E                    JSR  LB9C2         ;ADD (X) AND FPA0 
D663  8E0045                    LDX  #V45          ;POINT (X) TO FPA4 
D666  0A55                      DEC  COEFCT        ;DECREMENT TEMP COUNTER 
D668  26EE                      BNE  LBF0C         ;BRANCH IF MORE COEFFICIENTS LEFT 
D66A  39                        RTS                  
                                                     
                      * RND                          
D66B  BDD3B9          RND       JSR  LBC6D         ;TEST FPA0 
D66E  2B1F                      BMI  LBF45         ;BRANCH IF FPA0 = NEGATIVE 
D670  2715                      BEQ  LBF3B         ;BRANCH IF FPA0 = 0 
D672  8D10                      BSR  LBF38         ;CONVERT FPA0 TO AN INTEGER 
D674  BDD37B                    JSR  LBC2F         ;PACK FPA0 TO FPA3 
D677  8D0E                      BSR  LBF3B         ;GET A RANDOM NUMBER: FPA0 < 1.0 
D679  8E0040                    LDX  #V40          ;POINT (X) TO FPA3 
D67C  8DCA                      BSR  LBEFC         ;MULTIPLY (X) BY FPA0 
D67E  8ED211                    LDX  #LBAC5        ;POINT (X) TO FP VALUE OF 1.0 
D681  BDD10E                    JSR  LB9C2         ;ADD 1.0 TO FPA0 
D684  7ED43A          LBF38     JMP  INT           ;CONVERT FPA0 TO AN INTEGER 
                      * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0                      
D687  9EB1            LBF3B     LDX  RVSEED+1      ;* MOVE VARIABLE 
D689  9F50                      STX  FPA0          ;* RANDOM NUMBER 
D68B  9EB3                      LDX  RVSEED+3      ;* SEED TO 
D68D  9F52                      STX  FPA0+2        ;* FPA0 
D68F  BED6BC          LBF45     LDX  RSEED         ;= MOVE FIXED 
D692  9F5D                      STX  FPA1          ;= RANDOM NUMBER 
D694  BED6BE                    LDX  RSEED+2       ;= SEED TO 
D697  9F5F                      STX  FPA1+2        ;= MANTISSA OF FPA0 
D699  BDD21C                    JSR  LBAD0         ;MULTIPLY FPA0 X FPA1 
D69C  DC8A                      LDD  VAD           ;GET THE TWO LOWEST ORDER PRODUCT BYTES 
D69E  C3658B                    ADDD #$658B        ;ADD A CONSTANT 
D6A1  DDB3                      STD  RVSEED+3      ;SAVE NEW LOW ORDER VARIABLE RANDOM # SEED 
D6A3  DD52                      STD  FPA0+2        ;SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA 
D6A5  DC88                      LDD  VAB           ;GET 2 MORE LOW ORDER PRODUCT BYTES 
D6A7  C9B0                      ADCB #$B0          ;ADD A CONSTANT 
D6A9  8905                      ADCA #5            ;ADD A CONSTANT 
D6AB  DDB1                      STD  RVSEED+1      ;SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED 
D6AD  DD50                      STD  FPA0          ;SAVE NEW HIGH ORDER FPA0 MANTISSA 
D6AF  0F54                      CLR  FP0SGN        ;FORCE FPA0 MANTISSA = POSITIVE 
D6B1  8680                      LDA  #$80          ;* SET FPA0 BIASED EXPONENT 
D6B3  974F                      STA  FP0EXP        ;* TO 0 1 < FPA0 < 0 
D6B5  9615                      LDA  FPA2+2        ;GET A BYTE FROM FPA2 (MORE RANDOMNESS) 
D6B7  9763                      STA  FPSBYT        ;SAVE AS SUB BYTE 
D6B9  7ED168                    JMP  LBA1C         ;NORMALIZE FPA0 
                      *                              
D6BC  40E6            RSEED     FDB  $40E6         ;*CONSTANT RANDOM NUMBER GENERATOR SEED 
D6BE  4DAB                      FDB  $4DAB         ;* 
                                                     
                      * SIN                          
                      * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY                      
                      * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS                      
                      * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE                      
                      * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.                      
                                                     
                      * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:                      
                      * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)                      
D6C0  BDD3AB          SIN       JSR  LBC5F         ;COPY FPA0 TO FPA1 
D6C3  8ED705                    LDX  #LBFBD        ;POINT (X) TO 2*PI 
D6C6  D661                      LDB  FP1SGN        ;*GET MANTISSA SIGN OF FPA1 
D6C8  BDD2D5                    JSR  LBB89         ;*AND DIVIDE FPA0 BY 2*PI 
D6CB  BDD3AB                    JSR  LBC5F         ;COPY FPA0 TO FPA1 
D6CE  8DB4                      BSR  LBF38         ;CONVERT FPA0 TO AN INTEGER 
D6D0  0F62                      CLR  RESSGN        ;SET RESULT SIGN = POSITIVE 
D6D2  965C                      LDA  FP1EXP        ;*GET EXPONENT OF FPA1 
D6D4  D64F                      LDB  FP0EXP        ;*GET EXPONENT OF FPA0 
D6D6  BDD108                    JSR  LB9BC         ;*SUBTRACT FPA0 FROM FPA1 
                      * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI                      
D6D9  8ED70A                    LDX  #LBFC2        ;POINT X TO FP (.25) 
D6DC  BDD105                    JSR  LB9B9         ;SUBTRACT FPA0 FROM .25 (PI/2) 
D6DF  9654                      LDA  FP0SGN        ;GET MANTISSA SIGN OF FPA0 
D6E1  3402                      PSHS A             ;SAVE IT ON STACK 
D6E3  2A09                      BPL  LBFA6         ;BRANCH IF MANTISSA POSITIVE 
D6E5  BDD100                    JSR  LB9B4         ;ADD .5 (PI) TO FPA0 
D6E8  9654                      LDA  FP0SGN        ;GET SIGN OF FPA0 
D6EA  2B05                      BMI  LBFA9         ;BRANCH IF NEGATIVE 
D6EC  030A                      COM  RELFLG        ;COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG) 
D6EE  BDD635          LBFA6     JSR  LBEE9         ;TOGGLE MANTISSA SIGN OF FPA0 
D6F1  8ED70A          LBFA9     LDX  #LBFC2        ;POINT X TO FP (.25) 
D6F4  BDD10E                    JSR  LB9C2         ;ADD .25 (PI/2) TO FPA0 
D6F7  3502                      PULS A             ;GET OLD MANTISSA SIGN 
D6F9  4D                        TSTA               ;* BRANCH IF OLD 
D6FA  2A03                      BPL  LBFB7         ;* SIGN WAS POSITIVE 
D6FC  BDD635                    JSR  LBEE9         ;TOGGLE MANTISSA SIGN 
D6FF  8ED70F          LBFB7     LDX  #LBFC7        ;POINT X TO TABLE OF COEFFICIENTS 
D702  7ED63C                    JMP  LBEF0         ;GO CALCULATE POLYNOMIAL VALUE 
                                                     
D705  83490FDAA2      LBFBD     FCB  $83,$49,$0F,$DA,$A2 ;6.28318531 (2*PI) 
D70A  7F00000000      LBFC2     FCB  $7F,$00,$00,$00,$00 ;.25 
                                                     
                                                     
D70F  05              LBFC7     FCB  6-1                 ;SIX COEFFICIENTS 
D710  84E61A2D1B      LBFC8     FCB  $84,$E6,$1A,$2D,$1B ;* -((2*PI)**11)/11! 
D715  862807FBF8      LBFCD     FCB  $86,$28,$07,$FB,$F8 ;* ((2*PI)**9)/9! 
D71A  8799688901      LBFD2     FCB  $87,$99,$68,$89,$01 ;* -((2*PI)**7)/7! 
D71F  872335DFE1      LBFD7     FCB  $87,$23,$35,$DF,$E1 ;* ((2*PI)**5)/5! 
D724  86A55DE728      LBFDC     FCB  $86,$A5,$5D,$E7,$28 ;* -((2*PI)**3)/3! 
D729  83490FDAA2      LBFE1     FCB  $83,$49,$0F,$DA,$A2 ;* 
                                                     
D72E  A154468F13                FCB  $A1,$54,$46,$8F,$13 ;UNUSED GARBAGE BYTES 
D733  8F524389CD                FCB  $8F,$52,$43,$89,$CD ;UNUSED GARBAGE BYTES 
                      * EXTENDED BASIC                      
                                                     
                      * COS                          
                      * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)                      
D738  8ED76B          COS       LDX  #L83AB        ;POINT X TO FP CONSTANT (P1/2) 
D73B  BDD10E                    JSR  LB9C2         ;ADD FPA0 TO (X) 
D73E  7ED6C0          L837E     JMP  SIN           ;JUMP TO SIN ROUTINE 
                                                     
                      * TAN                          
                      * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)                      
D741  BDD37B          TAN       JSR  LBC2F         ;PACK FPA0 AND MOVE IT TO FPA3 
D744  0F0A                      CLR  RELFLG        ;RESET QUADRANT FLAG 
D746  8DF6                      BSR  L837E         ;CALCULATE SIN OF ARGUMENT 
D748  8E004A                    LDX  #V4A          ;POINT X TO FPA5 
D74B  BDD381                    JSR  LBC35         ;PACK FPA0 AND MOVE IT TO FPA5 
D74E  8E0040                    LDX  #V40          ;POINT X TO FPA3 
D751  BDD360                    JSR  LBC14         ;MOVE FPA3 TO FPA0 
D754  0F54                      CLR  FP0SGN        ;FORCE FPA0 MANTISSA TO BE POSITIVE 
D756  960A                      LDA  RELFLG        ;GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3 
D758  8D0C                      BSR  L83A6         ;CALCULATE VALUE OF COS(FPA0) 
D75A  0D4F                      TST  FP0EXP        ;CHECK EXPONENT OF FPA0 
D75C  1027FA7E                  LBEQ LBA92         ;'OV' ERROR IF COS(X)=0
D760  8E004A                    LDX  #V4A          ;POINT X TO FPA5 
D763  7ED2DB          L83A3     JMP  LBB8F         ;DIVIDE (X) BY FPA0 - SIN(X)/COS(X) 
D766  3402            L83A6     PSHS A             ;SAVE SIGN FLAG ON STACK 
D768  7ED6EE                    JMP  LBFA6         ;EXPAND POLYNOMIAL 
                                                     
D76B  81490FDAA2      L83AB     FCB  $81,$49,$0F,$DA,$A2 ;1.57079633 (PI/2) 
                                                     
                      * ATN                          
                      * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE                      
                      * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED  
                      * TO EVALUATE THE EXPRESSION DEPENDING UPON                      
                      * WHETHER OR NOT THE ARGUMENT;SQUARED IS > OR < 1.0                      
                                                     
                      * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .                      
                      * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)                      
                                                     
D770  9654            ATN       LDA  FP0SGN        ;* GET THE SIGN OF THE MANTISSA AND 
D772  3402                      PSHS A             ;* SAVE IT ON THE STACK 
D774  2A02                      BPL  L83B8         ;BRANCH IF POSITIVE MANTISSA 
D776  8D24                      BSR  L83DC         ;CHANGE SIGN OF FPA0 
D778  964F            L83B8     LDA  FP0EXP        ;* GET EXPONENT OF FPA0 AND 
D77A  3402                      PSHS A             ;* SAVE IT ON THE STACK 
D77C  8181                      CMPA #$81          ;IS FPAO < 1.0? 
D77E  2505                      BLO  L83C5         ;YES 
D780  8ED211                    LDX  #LBAC5        ;POINT X TO FP CONSTANT 1.0 
D783  8DDE                      BSR  L83A3         ;GET RECIPROCAL OF FPA0 
D785  8ED7A0          L83C5     LDX  #L83E0        ;POINT (X) TO TAYLOR SERIES COEFFICIENTS 
D788  BDD63C                    JSR  LBEF0         ;EXPAND POLYNOMIAL 
D78B  3502                      PULS A             ;GET EXPONENT OF ARGUMENT 
D78D  8181                      CMPA #$81          ;WAS ARGUMENT < 1.0? 
D78F  2506                      BLO  L83D7         ;YES 
D791  8ED76B                    LDX  #L83AB        ;POINT (X) TO FP NUMBER (PI/2) 
D794  BDD105                    JSR  LB9B9         ;SUBTRACT FPA0 FROM (PI/2) 
D797  3502            L83D7     PULS A             ;* GET SIGN OF INITIAL ARGUMENT MANTISSA 
D799  4D                        TSTA               ;* AND SET FLAGS ACCORDING TO IT 
D79A  2A03                      BPL  L83DF         ;RETURN IF ARGUMENT WAS POSITIVE 
D79C  7ED635          L83DC     JMP  LBEE9         ;CHANGE MANTISSA SIGN OF FPA0 
D79F  39              L83DF     RTS                  
                      *                              
                      * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT                      
D7A0  0B              L83E0     FCB  $0B           ;TWELVE COEFFICIENTS 
D7A1  76B383BDD3      L83E1     FCB  $76,$B3,$83,$BD,$D3 ;-6.84793912E-04 1/23 
D7A6  791EF4A6F5      L83E6     FCB  $79,$1E,$F4,$A6,$F5 ;+4.85094216E-03 1/21 
D7AB  7B83FCB010      L83EB     FCB  $7B,$83,$FC,$B0,$10 ;-0.0161117018 
D7B0  7C0C1F67CA      L83F0     FCB  $7C,$0C,$1F,$67,$CA ;0.0342096381 
D7B5  7CDE53CBC1      L83F5     FCB  $7C,$DE,$53,$CB,$C1 ;-0.0542791328 
D7BA  7D1464704C      L83FA     FCB  $7D,$14,$64,$70,$4C ;0.0724571965 
D7BF  7DB7EA517A      L83FF     FCB  $7D,$B7,$EA,$51,$7A ;-0.0898023954 
D7C4  7D6330887E      L8404     FCB  $7D,$63,$30,$88,$7E ;0.110932413 
D7C9  7E9244993A      L8409     FCB  $7E,$92,$44,$99,$3A ;-0.142839808 
D7CE  7E4CCC91C7      L840E     FCB  $7E,$4C,$CC,$91,$C7 ;0.199999121 
D7D3  7FAAAAAA13      L8413     FCB  $7F,$AA,$AA,$AA,$13 ;-0.333333316 
D7D8  8100000000      L8418     FCB  $81,$00,$00,$00,$00 ;1 
                      *                              
                      *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)                      
                      *                              
D7DD  03              L841D     FCB  3                   ;FOUR COEFFICIENTS 
D7DE  7F5E56CB79      L841E     FCB  $7F,$5E,$56,$CB,$79 ;0.434255942 
D7E3  80139B0B64      L8423     FCB  $80,$13,$9B,$0B,$64 ;0.576584541 
D7E8  8076389316      L8428     FCB  $80,$76,$38,$93,$16 ;0.961800759 
D7ED  8238AA3B20      L842D     FCB  $82,$38,$AA,$3B,$20 ;2.88539007 
                                                     
D7F2  803504F334      L8432     FCB  $80,$35,$04,$F3,$34 ;1/SQR(2) 
                                                     
D7F7  813504F334      L8437     FCB  $81,$35,$04,$F3,$34 ;SQR(2) 
                                                     
D7FC  8080000000      L843C     FCB  $80,$80,$00,$00,$00 ;-0.5 
                                                     
D801  80317217F8      L8441     FCB  $80,$31,$72,$17,$F8 ;LN(2) 
                      *                              
                      * LOG - NATURAL LOGARITHM (LN)                      
                                                     
                      * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING                      
                      * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC                      
                      * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF                      
                      * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS                      
                      * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF                      
                      * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE                      
                      * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION                      
D806  BDD3B9          LOG       JSR  LBC6D         ;CHECK STATUS OF FPA0 
D809  102FF3C4                  LBLE LB44A         ;'FC' ERROR IF NEGATIVE OR ZERO
D80D  8ED7F2                    LDX  #L8432        ;POINT (X) TO FP NUMBER (1/SQR(2)) 
D810  964F                      LDA  FP0EXP        ;*GET EXPONENT OF ARGUMENT 
D812  8080                      SUBA #$80          ;*SUBTRACT OFF THE BIAS AND 
D814  3402                      PSHS A             ;*SAVE IT ON THE STACK 
D816  8680                      LDA  #$80            
D818  974F                      STA  FP0EXP          
D81A  BDD10E                    JSR  LB9C2         ;ADD FPA0 TO (X) 
D81D  8ED7F7                    LDX  #L8437        ;POINT X TO SQR(2) 
D820  BDD2DB                    JSR  LBB8F         ;DIVIDE SQR(2) BY FPA0 
D823  8ED211                    LDX  #LBAC5        ;POINT X TO FP VALUE OF 1.00 
D826  BDD105                    JSR  LB9B9         ;SUBTRACT FPA0 FROM (X) 
                      *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT  
D829  8ED7DD                    LDX  #L841D        ;POINT X TO TABLE OF COEFFICIENTS 
D82C  BDD63C                    JSR  LBEF0         ;EXPAND POLYNOMIAL 
D82F  8ED7FC                    LDX  #L843C        ;POINT X TO FP VALUE OF (-.5) 
D832  BDD10E                    JSR  LB9C2         ;ADD FPA0 TO X 
D835  3504                      PULS B             ;GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS) 
D837  BDD4E5                    JSR  LBD99         ;ADD ACCB TO FPA0 
D83A  8ED801                    LDX  #L8441        ;POINT X TO LN(2) 
D83D  7ED216                    JMP  LBACA         ;MULTIPLY FPA0 * LN(2) 
                                                     
                      * SQR                          
D840  BDD3AB          SQR       JSR  LBC5F         ;MOVE FPA0 TO FPA1 
D843  8ED60C                    LDX  #LBEC0        ;POINT (X) TO FP NUMBER (.5) 
D846  BDD360                    JSR  LBC14         ;COPY A PACKED NUMBER FROM (X) TO FPA0 
                                                     
                      * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS                      
                      * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION                      
                      * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818                      
D849  2767            L8489     BEQ  EXP           ;DO A NATURAL EXPONENTIATION IF EXPONENT = 0 
D84B  4D                        TSTA               ;*CHECK VALUE BEING EXPONENTIATED 
D84C  2603                      BNE  L8491         ;*AND BRANCH IF IT IS <> 0 
D84E  7ED186                    JMP  LBA3A         ;FPA0=0 IF RAISING ZERO TO A POWER 
D851  8E004A          L8491     LDX  #V4A          ;* PACK FPA0 AND SAVE 
D854  BDD381                    JSR  LBC35         ;* IT IN FPA5 (ARGUMENT'S EXPONENT)
D857  5F                        CLRB               ;ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE 
D858  9661                      LDA  FP1SGN        ;*CHECK THE SIGN OF ARGUMENT 
D85A  2A10                      BPL  L84AC         ;*BRANCH IF POSITIVE 
D85C  BDD43A                    JSR  INT           ;CONVERT EXPONENT INTO AN INTEGER 
D85F  8E004A                    LDX  #V4A          ;POINT X TO FPA5 (ORIGINAL EXPONENT) 
D862  9661                      LDA  FP1SGN        ;GET MANTISSA SIGN OF FPA1 (ARGUMENT) 
D864  BDD3EC                    JSR  LBCA0         ;*COMPARE FPA0 TO (X) AND 
D867  2603                      BNE  L84AC         ;*BRANCH IF NOT EQUAL 
D869  43                        COMA               ;TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE 
D86A  D601                      LDB  CHARAC        ;GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG) 
D86C  BDD398          L84AC     JSR  LBC4C         ;COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN 
D86F  3404                      PSHS B             ;PUT RESULT SIGN FLAG ON THE STACK 
D871  BDD806                    JSR  LOG             
D874  8E004A                    LDX  #V4A          ;POINT (X) TO FPA5 
D877  BDD216                    JSR  LBACA         ;MULTIPLY FPA0 BY FPA5 
D87A  8D36                      BSR  EXP           ;CALCULATE E**(FPA0) 
D87C  3502                      PULS A             ;* GET RESULT SIGN FLAG FROM THE STACK 
D87E  46                        RORA               ;* AND BRANCH IF NEGATIVE  
D87F  1025FDB2                  LBCS LBEE9         ;CHANGE SIGN OF FPA0 MANTISSA 
D883  39                        RTS                  
                                                     
                      * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION                      
D884  8138AA3B29      L84C4     FCB  $81,$38,$AA,$3B,$29 ;1.44269504 ( CF ) 
                      *                              
                      * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X                      
                      *                              
D889  07              L84C9     FCB  7                   ;EIGHT COEFFICIENTS 
D88A  7134583E56      L84CA     FCB  $71,$34,$58,$3E,$56 ;2.14987637E-05: 1/(7!*(CF**7)) 
D88F  74167EB31B      L84CF     FCB  $74,$16,$7E,$B3,$1B ;1.4352314E-04 : 1/(6!*(CF**6)) 
D894  772FEEE385      L84D4     FCB  $77,$2F,$EE,$E3,$85 ;1.34226348E-03: 1/(5!*(CF**5)) 
D899  7A1D841C2A      L84D9     FCB  $7A,$1D,$84,$1C,$2A ;9.61401701E-03: 1/(4!*(CF**4)) 
D89E  7C6359580A      L84DE     FCB  $7C,$63,$59,$58,$0A ;0.0555051269 
D8A3  7E75FDE7C6      L84E3     FCB  $7E,$75,$FD,$E7,$C6 ;0.240226385 
D8A8  8031721810      L84E8     FCB  $80,$31,$72,$18,$10 ;0.693147186 
D8AD  8100000000      L84ED     FCB  $81,$00,$00,$00,$00 ;1 
                      *                              
                      * EXP ( E**X)                      
                      * THE EXPONENTIAL FUNCTION IS;EVALUATED BY FIRST MULTIPLYING THE                      
                      * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN                      
                      * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A                      
                      * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE                      
                      * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT                      
                      * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.                      
                                                     
D8B2  8ED884          EXP       LDX  #L84C4        ;POINT X TO THE CORRECTION FACTOR 
D8B5  BDD216                    JSR  LBACA         ;MULTIPLY FPA0 BY (X) 
D8B8  BDD37B                    JSR  LBC2F         ;PACK FPA0 AND STORE IT IN FPA3 
D8BB  964F                      LDA  FP0EXP        ;*GET EXPONENT OF FPA0 AND 
D8BD  8188                      CMPA #$88          ;*COMPARE TO THE MAXIMUM VALUE 
D8BF  2503                      BLO  L8504         ;BRANCH IF FPA0 < 128 
D8C1  7ED2A8          L8501     JMP  LBB5C         ;SET FPA0 = 0 OR 'OV' ERROR
D8C4  BDD43A          L8504     JSR  INT           ;CONVERT FPA0 TO INTEGER 
D8C7  9601                      LDA  CHARAC        ;GET LS BYTE OF INTEGER 
D8C9  8B81                      ADDA #$81          ;* WAS THE ARGUMENT =127, IF SO 
D8CB  27F4                      BEQ  L8501         ;* THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
                      *              * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW  
D8CD  4A                        DECA               ;DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE 
D8CE  3402                      PSHS A             ;SAVE EXPONENT OF INTEGER PORTION ON STACK 
D8D0  8E0040                    LDX  #V40          ;POINT (X) TO FPA3 
D8D3  BDD105                    JSR  LB9B9         ;SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT 
D8D6  8ED889                    LDX  #L84C9        ;POINT X TO COEFFICIENTS 
D8D9  BDD64B                    JSR  LBEFF         ;EVALUATE POLYNOMIAL FOR FRACTIONAL PART 
D8DC  0F62                      CLR  RESSGN        ;FORCE THE MANTISSA TO BE POSITIVE 
D8DE  3502                      PULS A             ;GET INTEGER EXPONENT FROM STACK 
D8E0  BDD294                    JSR  LBB48         ;* CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE 
                      *              * INTEGER AND FRACTIONAL PARTS  
D8E3  39                        RTS                  
                                                     
                      * FIX                          
D8E4  BDD3B9          FIX       JSR  LBC6D         ;CHECK STATUS OF FPA0 
D8E7  2B03                      BMI  L852C         ;BRANCH IF FPA0 = NEGATIVE 
D8E9  7ED43A          L8529     JMP  INT           ;CONVERT FPA0 TO INTEGER 
D8EC  0354            L852C     COM  FP0SGN        ;TOGGLE SIGN OF FPA0 MANTISSA 
D8EE  8DF9                      BSR  L8529         ;CONVERT FPA0 TO INTEGER 
D8F0  7ED635                    JMP  LBEE9         ;TOGGLE SIGN OF FPA0 
                                                     
                      * EDIT                         
D8F3  BDDD21          EDIT      JSR  L89AE         ;GET LINE NUMBER FROM BASIC 
D8F6  3262                      LEAS $02,S         ;PURGE RETURN ADDRESS OFF OF THE STACK  
D8F8  8601            L8538     LDA  #$01          ;'LIST' FLAG
D8FA  9798                      STA  VD8           ;SET FLAG TO LIST LINE 
D8FC  BDC4A2                    JSR  LAD01         ;GO FIND THE LINE NUMBER IN PROGRAM 
D8FF  1025ED7F                  LBCS LAED2         ;ERROR #7;'UNDEFINED LINE #'
D903  BDCF3E                    JSR  LB7C2         ;GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1 
D906  1F20                      TFR  Y,D           ;PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD 
D908  8300F5                    SUBD #LINBUF+2     ;SUBTRACT OUT THE START OF LINE  
D90B  D797                      STB  VD7           ;SAVE LENGTH OF LINE 
D90D  DC2B            L854D     LDD  BINVAL        ;GET THE HEX VALUE OF LINE NUMBER 
D90F  BDD518                    JSR  LBDCC         ;LIST THE LINE NUMBER ON THE SCREEN 
D912  BDD0F8                    JSR  LB9AC         ;PRINT A SPACE 
D915  8E00F4                    LDX  #LINBUF+1     ;POINT X TO BUFFER 
D918  D698                      LDB  VD8           ;* CHECK TO SEE IF LINE IS TO BE 
D91A  2625                      BNE  L8581         ;* LISTED TO SCREEN - BRANCH IF IT IS 
D91C  5F              L855C     CLRB               ;RESET DIGIT ACCUMULATOR - DEFAULT VALUE 
D91D  BDDA47          L855D     JSR  L8687         ;GET KEY STROKE 
D920  BDE1EC                    JSR  L90AA         ;SET CARRY IF NOT NUMERIC 
D923  250B                      BLO  L8570         ;BRANCH IF NOT NUMERIC 
D925  8030                      SUBA #'0'          ;MASK OFF ASCII  
D927  3402                      PSHS A             ;SAVE IT ON STACK  
D929  860A                      LDA  #10           ;NUMBER BEING CONVERTED IS BASE 10 
D92B  3D                        MUL                ;MULTIPLY ACCUMULATED VALUE BY BASE (10)  
D92C  EBE0                      ADDB ,S+           ;ADD DIGIT TO ACCUMULATED VALUE  
D92E  20ED                      BRA  L855D         ;CHECK FOR ANOTHER DIGIT 
D930  C001            L8570     SUBB #$01          ;* REPEAT PARAMETER IN ACCB; IF IT  
D932  C901                      ADCB #$01          ;*IS 0, THEN MAKE IT '1'
D934  8141                      CMPA #'A'          ;ABORT?          
D936  2605                      BNE  L857D         ;NO 
D938  BDD0A8                    JSR  LB958         ;PRINT CARRIAGE RETURN TO SCREEN 
D93B  20BB                      BRA  L8538         ;RESTART EDIT PROCESS - CANCEL ALL CHANGES 
D93D  814C            L857D     CMPA #'L'          ;LIST?           
D93F  260B                      BNE  L858C         ;NO 
D941  8D31            L8581     BSR  L85B4         ;LIST THE LINE 
D943  0F98                      CLR  VD8           ;RESET THE LIST FLAG TO 'NO LIST'
D945  BDD0A8                    JSR  LB958         ;PRINT CARRIAGE RETURN 
D948  20C3                      BRA  L854D         ;GO INTERPRET ANOTHER EDIT COMMAND 
D94A  3262            L858A     LEAS $02,S         ;PURGE RETURN ADDRESS OFF OF THE STACK  
D94C  810D            L858C     CMPA #CR           ;ENTER KEY?      
D94E  260D                      BNE  L859D         ;NO 
D950  8D22                      BSR  L85B4         ;ECHO THE LINE TO THE SCREEN 
D952  BDD0A8          L8592     JSR  LB958         ;PRINT CARRIAGE RETURN 
D955  8E00F4                    LDX  #LINBUF+1     ;* RESET BASIC'S INPUT POINTER
D958  9F83                      STX  CHARAD        ;* TO THE LINE INPUT BUFFER 
D95A  7EC44B                    JMP  LACA8         ;GO PUT LINE BACK IN PROGRAM 
D95D  8145            L859D     CMPA #'E'          ;EXIT?           
D95F  27F1                      BEQ  L8592         ;YES - SAME AS ENTER EXCEPT NO ECHO 
D961  8151                      CMPA #'Q'          ;QUIT?           
D963  2606                      BNE  L85AB         ;NO 
D965  BDD0A8                    JSR  LB958         ;PRINT CARRIAGE RETURN TO SCREEN 
D968  7EC422                    JMP  LAC73         ;GO TO COMMAND LEVEL - MAKE NO CHANGES 
D96B  8D02            L85AB     BSR  L85AF         ;INTERPRET THE REMAINING COMMANDS AS SUBROUTINES 
D96D  20AD                      BRA  L855C         ;GO INTERPRET ANOTHER EDIT COMMAND 
D96F  8120            L85AF     CMPA #SPACE        ;SPACE BAR?      
D971  2610                      BNE  L85C3         ;NO 
D973  8C              L85B3     FCB  SKP2          ;SKIP TWO BYTES 
                      * DISPLAY THE NEXT ACCB BYTES;OF THE LINE IN THE BUFFER TO THE SCREEN                      
                      *                              
D974  C6F9            L85B4     LDB  #LBUFMX-1     ;250 BYTES MAX IN BUFFER 
D976  A684            L85B6     LDA  ,X            ;GET A CHARACTER FROM BUFFER 
D978  2708                      BEQ  L85C2         ;EXIT IF IT'S A 0
D97A  BDC017                    JSR  PUTCHR        ;SEND CHAR TO CONSOLE OUT 
D97D  3001                      LEAX $01,X         ;MOVE POINTER UP ONE  
D97F  5A                        DECB               ;DECREMENT CHARACTER COUNTER  
D980  26F4                      BNE  L85B6         ;LOOP IF NOT DONE 
D982  39              L85C2     RTS                  
D983  8144            L85C3     CMPA #'D'          ;DELETE?         
D985  2648                      BNE  L860F         ;NO 
D987  6D84            L85C7     TST  ,X            ;* CHECK FOR END OF LINE 
D989  27F7                      BEQ  L85C2         ;* AND BRANCH IF SO 
D98B  8D04                      BSR  L85D1         ;REMOVE A CHARACTER 
D98D  5A                        DECB               ;DECREMENT REPEAT PARAMETER  
D98E  26F7                      BNE  L85C7         ;BRANCH IF NOT DONE 
D990  39                        RTS                  
                      * REMOVE ONE CHARACTER FROM BUFFER                      
D991  0A97            L85D1     DEC  VD7           ;DECREMENT LENGTH OF BUFFER 
D993  311F                      LEAY -1,X        ;POINT Y TO ONE BEFORE CURRENT BUFFER POINTER  
D995  3121            L85D5     LEAY $01,Y         ;INCREMENT TEMPORARY BUFFER POINTER  
D997  A621                      LDA  $01,Y         ;GET NEXT CHARACTER 
D999  A7A4                      STA  ,Y            ;PUT IT IN CURRENT POSITION 
D99B  26F8                      BNE  L85D5         ;BRANCH IF NOT END OF LINE 
D99D  39                        RTS                  
D99E  8149            L85DE     CMPA #'I'          ;INSERT?         
D9A0  2713                      BEQ  L85F5         ;YES 
D9A2  8158                      CMPA #'X'          ;EXTEND?         
D9A4  270D                      BEQ  L85F3         ;YES 
D9A6  8148                      CMPA #'H'          ;HACK?           
D9A8  265C                      BNE  L8646         ;NO 
D9AA  6F84                      CLR  ,X            ;TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG 
D9AC  1F10                      TFR  X,D           ;PUT CURRENT BUFFER POINTER IN ACCD 
D9AE  8300F5                    SUBD #LINBUF+2     ;SUBTRACT INITIAL POINTER POSITION  
D9B1  D797                      STB  VD7           ;SAVE NEW BUFFER LENGTH 
D9B3  8DBF            L85F3     BSR  L85B4         ;DISPLAY THE LINE ON THE SCREEN 
D9B5  BDDA47          L85F5     JSR  L8687         ;GET A KEYSTROKE 
D9B8  810D                      CMPA #CR           ;ENTER KEY?      
D9BA  278E                      BEQ  L858A         ;YES - INTERPRET ANOTHER COMMAND - PRINT LINE 
D9BC  811B                      CMPA #ESC          ;ESCAPE?         
D9BE  2725                      BEQ  L8625         ;YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
D9C0  8108                      CMPA #BS           ;BACK SPACE?     
D9C2  2622                      BNE  L8626         ;NO 
D9C4  8C00F4                    CMPX #LINBUF+1     ;COMPARE POINTER TO START OF BUFFER  
D9C7  27EC                      BEQ  L85F5         ;DO NOT ALLOW BS IF AT START 
D9C9  8D45                      BSR  L8650         ;MOVE POINTER BACK ONE, BS TO SCREEN 
D9CB  8DC4                      BSR  L85D1         ;REMOVE ONE CHARACTER FROM BUFFER 
D9CD  20E6                      BRA  L85F5         ;GET INSERT SUB COMMAND 
D9CF  8143            L860F     CMPA #'C'          ;CHANGE?         
D9D1  26CB                      BNE  L85DE         ;NO 
D9D3  6D84            L8613     TST  ,X            ;CHECK CURRENT BUFFER CHARACTER 
D9D5  270E                      BEQ  L8625         ;BRANCH IF END OF LINE 
D9D7  BDDA47                    JSR  L8687         ;GET A KEYSTROKE 
D9DA  2502                      BLO  L861E         ;BRANCH IF LEGITIMATE KEY 
D9DC  20F5                      BRA  L8613         ;TRY AGAIN IF ILLEGAL KEY 
D9DE  A780            L861E     STA  ,X+           ;INSERT NEW CHARACTER INTO BUFFER 
D9E0  8D37                      BSR  L8659         ;SEND NEW CHARACTER TO SCREEN 
D9E2  5A                        DECB               ;DECREMENT REPEAT PARAMETER  
D9E3  26EE                      BNE  L8613         ;BRANCH IF NOT DONE 
D9E5  39              L8625     RTS                  
D9E6  D697            L8626     LDB  VD7           ;GET LENGTH OF LINE 
D9E8  C1F9                      CMPB #LBUFMX-1     ;COMPARE TO MAXIMUM LENGTH  
D9EA  2602                      BNE  L862E         ;BRANCH IF NOT AT MAXIMUM 
D9EC  20C7                      BRA  L85F5         ;IGNORE INPUT IF LINE AT MAXIMUM LENGTH 
D9EE  3410            L862E     PSHS X             ;SAVE CURRENT BUFFER POINTER  
D9F0  6D80            L8630     TST  ,X+           ;* SCAN THE LINE UNTIL END OF 
D9F2  26FC                      BNE  L8630         ;* LINE (0) IS FOUND 
D9F4  E682            L8634     LDB  ,-X           ;DECR TEMP LINE POINTER AND GET A CHARACTER 
D9F6  E701                      STB  $01,X         ;PUT CHARACTER BACK DOWN ONE SPOT 
D9F8  ACE4                      CMPX ,S            ;HAVE WE REACHED STARTING POINT?  
D9FA  26F8                      BNE  L8634         ;NO - KEEP GOING 
D9FC  3262                      LEAS $02,S         ;PURGE BUFFER POINTER FROM STACK  
D9FE  A780                      STA  ,X+           ;INSERT NEW CHARACTER INTO THE LINE 
DA00  8D17                      BSR  L8659         ;SEND A CHARACTER TO CONSOLE OUT 
DA02  0C97                      INC  VD7           ;ADD ONE TO BUFFER LENGTH 
DA04  20AF                      BRA  L85F5         ;GET INSERT SUB COMMAND 
DA06  8108            L8646     CMPA #BS           ;BACKSPACE?      
DA08  2612                      BNE  L865C         ;NO 
DA0A  8D04            L864A     BSR  L8650         ;MOVE POINTER BACK 1, SEND BS TO SCREEN 
DA0C  5A                        DECB               ;DECREMENT REPEAT PARAMETER  
DA0D  26FB                      BNE  L864A         ;LOOP UNTIL DONE 
DA0F  39                        RTS                  
DA10  8C00F4          L8650     CMPX #LINBUF+1     ;COMPARE POINTER TO START OF BUFFER  
DA13  27D0                      BEQ  L8625         ;DO NOT ALLOW BS IF AT START 
DA15  301F                      LEAX -1,X        ;MOVE POINTER BACK ONE  
DA17  8608                      LDA  #BS           ;BACK SPACE 
DA19  7EC017          L8659     JMP  PUTCHR        ;SEND TO CONSOLE OUT 
DA1C  814B            L865C     CMPA #'K'          ;KILL?           
DA1E  2705                      BEQ  L8665         ;YES 
DA20  8053                      SUBA #'S'          ;SEARCH?         
DA22  2701                      BEQ  L8665         ;YES 
DA24  39                        RTS                  
DA25  3402            L8665     PSHS A             ;SAVE KILL/SEARCH FLAG ON STACK  
DA27  8D1E                      BSR  L8687         ;* GET A KEYSTROKE (TARGET CHARACTER) 
DA29  3402                      PSHS A             ;* AND SAVE IT ON STACK  
DA2B  A684            L866B     LDA  ,X            ;GET CURRENT BUFFER CHARACTER 
DA2D  2716                      BEQ  L8685         ;AND RETURN IF END OF LINE 
DA2F  6D61                      TST  $01,S         ;CHECK KILL/SEARCH FLAG 
DA31  2606                      BNE  L8679         ;BRANCH IF KILL 
DA33  8DE4                      BSR  L8659         ;SEND A CHARACTER TO CONSOLE OUT 
DA35  3001                      LEAX 1,X           ;INCREMENT BUFFER POINTER  
DA37  2003                      BRA  L867C         ;CHECK NEXT INPUT CHARACTER 
DA39  BDD991          L8679     JSR  L85D1         ;REMOVE ONE CHARACTER FROM BUFFER 
DA3C  A684            L867C     LDA  ,X            ;GET CURRENT INPUT CHARACTER 
DA3E  A1E4                      CMPA ,S            ;COMPARE TO TARGET CHARACTER  
DA40  26E9                      BNE  L866B         ;BRANCH IF NO MATCH 
DA42  5A                        DECB               ;DECREMENT REPEAT PARAMETER  
DA43  26E6                      BNE  L866B         ;BRANCH IF NOT DONE 
DA45  35A0            L8685     PULS Y,PC          ;THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A  
                      *                              
                      * GET A KEYSTRKE                      
DA47  BDC003          L8687     JSR  LA171         ;CALL CONSOLE IN : DEV NBR=SCREEN 
DA4A  817F                      CMPA #$7F          ;GRAPHIC CHARACTER?  
DA4C  24F9                      BCC  L8687         ;YES - GET ANOTHER CHAR 
DA4E  815F                      CMPA #$5F          ;SHIFT UP ARROW (QUIT INSERT)  
DA50  2602                      BNE  L8694         ;NO 
DA52  861B                      LDA  #ESC          ;REPLACE W/ESCAPE CODE 
DA54  810D            L8694     CMPA #CR           ;ENTER KEY       
DA56  270E                      BEQ  L86A6         ;YES 
DA58  811B                      CMPA #ESC          ;ESCAPE?         
DA5A  270A                      BEQ  L86A6         ;YES 
DA5C  8108                      CMPA #BS           ;BACKSPACE?      
DA5E  2706                      BEQ  L86A6         ;YES 
DA60  8120                      CMPA #SPACE        ;SPACE           
DA62  25E3                      BLO  L8687         ;GET ANOTHER CHAR IF CONTROL CHAR 
DA64  1A01                      ORCC #$01          ;SET CARRY       
DA66  39              L86A6     RTS                  
                                                     
                      * TRON                         
DA67  86              TRON      FCB  SKP1LD        ;SKIP ONE BYTE AND LDA #$4F 
                                                     
                      * TROFF                        
DA68  4F              TROFF     CLRA               ;TROFF FLAG 
DA69  978C                      STA  TRCFLG        ;TRON/TROFF FLAG:0=TROFF, <> 0=TRON 
DA6B  39                        RTS                  
                                                     
                      * POS                          
                                                     
DA6C  8600            POS       LDA  #0            ;GET DEVICE NUMBER 
DA6E  D679                      LDB  LPTPOS        ;GET PRINT POSITION 
DA70  1D              LA5E8     SEX                ;CONVERT ACCB TO 2 DIGIT SIGNED INTEGER 
DA71  7ECC7B                    JMP  GIVABF        ;CONVERT ACCD TO FLOATING POINT 
                                                     
                                                     
                      * VARPTR                       
DA74  BDC9F6          VARPT     JSR  LB26A         ;SYNTAX CHECK FOR '('
DA77  DC1F                      LDD  ARYEND        ;GET ADDR OF END OF ARRAYS 
DA79  3406                      PSHS B,A           ;SAVE IT ON STACK 
DA7B  BDCADE                    JSR  LB357         ;GET VARIABLE DESCRIPTOR 
DA7E  BDC9F3                    JSR  LB267         ;SYNTAX CHECK FOR ')'
DA81  3506                      PULS A,B           ;GET END OF ARRAYS ADDR BACK 
DA83  1E10                      EXG  X,D           ;SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR 
DA85  9C1F                      CMPX ARYEND        ;COMPARE TO NEW END OF ARRAYS 
DA87  2651                      BNE  L8724         ;'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
DA89  7ECC7B                    JMP  GIVABF        ;CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER 
                                                     
                      * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT                      
DA8C  9D7C            L86D6     JSR  GETNCH        ;GET INPUT CHAR FROM BASIC 
DA8E  BDC9F6                    JSR  LB26A         ;SYNTAX CHECK FOR '('
DA91  BDCADE                    JSR  LB357         ;* GET VARIABLE DESCRIPTOR ADDRESS AND 
DA94  3410                      PSHS X             ;* SAVE IT ON THE STACK 
DA96  EC02                      LDD  $02,X         ;POINT ACCD TO START OF OLDSTRING 
DA98  109321                    CMPD FRETOP        ;COMPARE TO START OF CLEARED SPACE 
DA9B  2304                      BLS  L86EB         ;BRANCH IF <= 
DA9D  9327                      SUBD MEMSIZ        ;SUBTRACT OUT TOP OF CLEARED SPACE 
DA9F  2312                      BLS  L86FD         ;BRANCH IF STRING IN STRING SPACE 
DAA1  E684            L86EB     LDB  ,X            ;GET LENGTH OF OLDSTRING 
DAA3  BDCCF4                    JSR  LB56D         ;RESERVE ACCB BYTES IN STRING SPACE 
DAA6  3410                      PSHS X             ;SAVE RESERVED SPACE STRING ADDRESS ON STACK 
DAA8  AE62                      LDX  $02,S         ;POINT X TO OLDSTRING DESCRIPTOR 
DAAA  BDCDCA                    JSR  LB643         ;MOVE OLDSTRING INTO STRING SPACE 
DAAD  3550                      PULS X,U           ;* GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING 
DAAF  AF42                      STX  $02,U         ;* ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS 
DAB1  3440                      PSHS U             ;SAVE OLDSTRING DESCRIPTOR ADDRESS 
DAB3  BDCEBF          L86FD     JSR  LB738         ;SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION 
DAB6  3404                      PSHS B             ;SAVE POSITION PARAMETER ON STACK 
DAB8  5D                        TSTB               ;* CHECK POSITION PARAMETER AND BRANCH  
DAB9  271F                      BEQ  L8724         ;* IF START OF STRING 
DABB  C6FF                      LDB  #$FF          ;DEFAULT REPLACEMENT LENGTH = $FF 
DABD  8129                      CMPA #')'          ;* CHECK FOR END OF MID$ STATEMENT AND 
DABF  2703                      BEQ  L870E         ;* BRANCH IF AT END OF STATEMENT 
DAC1  BDCEBF                    JSR  LB738         ;SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION 
DAC4  3404            L870E     PSHS B             ;SAVE LENGTH PARAMETER ON STACK 
DAC6  BDC9F3                    JSR  LB267         ;SYNTAX CHECK FOR ')'
DAC9  C6AE                      LDB  #TOK_EQUALS   ;TOKEN FOR = 
DACB  BDC9FB                    JSR  LB26F         ;SYNTAX CHECK FOR '='
DACE  8D2E                      BSR  L8748         ;EVALUATE REPLACEMENT STRING 
DAD0  1F13                      TFR  X,U           ;SAVE REPLACEMENT STRING ADDRESS IN U 
DAD2  AE62                      LDX  $02,S         ;POINT X TO OLOSTRING DESCRIPTOR ADDRESS 
DAD4  A684                      LDA  ,X            ;GET LENGTH OF OLDSTRING 
DAD6  A061                      SUBA $01,S         ;SUBTRACT POSITION PARAMETER 
DAD8  2403                      BCC  L8727         ;INSERT REPLACEMENT STRING INTO OLDSTRING 
DADA  7ECBD1          L8724     JMP  LB44A         ;'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
DADD  4C              L8727     INCA               ;* NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT 
                      *                            ;* (INCLUSIVE) OF THE POSITION PARAMETER 
DADE  A1E4                      CMPA ,S              
DAE0  2402                      BCC  L872E         ;BRANCH IF NEW STRING WILL FIT IN OLDSTRING 
DAE2  A7E4                      STA  ,S            ;IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT 
DAE4  A661            L872E     LDA  $01,S         ;GET POSITION PARAMETER 
DAE6  1E89                      EXG  A,B           ;ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER 
DAE8  AE02                      LDX  $02,X         ;POINT X TO OLDSTRING ADDRESS 
DAEA  5A                        DECB               ;* BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
                      *                            ;* WANTS IT TO START AT ZERO 
DAEB  3A                        ABX                ;POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO 
DAEC  4D                        TSTA               ;* IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO 
DAED  270D                      BEQ  L8746         ;* THEN RETURN 
DAEF  A1E4                      CMPA ,S              
DAF1  2302                      BLS  L873F         ;ADJUSTED LENGTH PARAMETER, THEN BRANCH 
DAF3  A6E4                      LDA  ,S            ;OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE 
DAF5  1F89            L873F     TFR  A,B           ;SAVE NUMBER OF BYTES TO MOVE IN ACCB 
DAF7  1E31                      EXG  U,X           ;SWAP SOURCE AND DESTINATION POINTERS 
DAF9  BDC1AC                    JSR  LA59A         ;MOVE (B) BYTES FROM (X) TO (U) 
DAFC  3596            L8746     PULS A,B,X,PC        
DAFE  BDC8E2          L8748     JSR  LB156         ;EVALUATE EXPRESSION 
DB01  7ECDDB                    JMP  LB654         ;*'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
                      *                            ;*TO STRING, ACCB = LENGTH 
                                                     
                      * STRING                       
DB04  BDC9F6          STRING    JSR  LB26A         ;SYNTAX CHECK FOR '('
DB07  BDCE92                    JSR  LB70B         ;EVALUATE EXPRESSION; ERROR IF > 255 
DB0A  3404                      PSHS B             ;SAVE LENGTH OF STRING 
DB0C  BDC9F9                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DB0F  BDC8E2                    JSR  LB156         ;EVALUATE EXPRESSION 
DB12  BDC9F3                    JSR  LB267         ;SYNTAX CHECK FOR ')'
DB15  9606                      LDA  VALTYP        ;GET VARIABLE TYPE 
DB17  2605                      BNE  L8768         ;BRANCH IF STRING 
DB19  BDCE95                    JSR  LB70E         ;CONVERT FPA0 INTO AN INTEGER IN ACCB 
DB1C  2003                      BRA  L876B         ;SAVE THE STRING IN STRING SPACE 
DB1E  BDCE2B          L8768     JSR  LB6A4         ;GET FIRST BYTE OF STRING 
DB21  3404            L876B     PSHS B             ;SAVE FIRST BYTE OF EXPRESSION 
DB23  E661                      LDB  $01,S         ;GET LENGTH OF STRING 
DB25  BDCC96                    JSR  LB50F         ;RESERVE ACCB BYTES IN STRING SPACE 
DB28  3506                      PULS A,B           ;GET LENGTH OF STRING AND CHARACTER 
DB2A  2705                      BEQ  L877B         ;BRANCH IF NULL STRING 
DB2C  A780            L8776     STA  ,X+           ;SAVE A CHARACTER IN STRING SPACE 
DB2E  5A                        DECB               ;DECREMENT LENGTH 
DB2F  26FB                      BNE  L8776         ;BRANCH IF NOT DONE 
DB31  7ECE22          L877B     JMP  LB69B         ;PUT STRING DESCRIPTOR ONTO STRING STACK 
                                                     
                      * INSTR                        
DB34  BDC9F6          INSTR     JSR  LB26A         ;SYNTAX CHECK FOR '('
DB37  BDC8E2                    JSR  LB156         ;EVALUATE EXPRESSION 
DB3A  C601                      LDB  #$01          ;DEFAULT POSITION = 1 (SEARCH START) 
DB3C  3404                      PSHS B             ;SAVE START 
DB3E  9606                      LDA  VALTYP        ;GET VARIABLE TYPE 
DB40  2610                      BNE  L879C         ;BRANCH IF STRING 
DB42  BDCE95                    JSR  LB70E         ;CONVERT FPA0 TO INTEGER IN ACCB 
DB45  E7E4                      STB  ,S            ;SAVE START SEARCH VALUE 
DB47  2791                      BEQ  L8724         ;BRANCH IF START SEARCH AT ZERO 
DB49  BDC9F9                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DB4C  BDC8E2                    JSR  LB156         ;EVALUATE EXPRESSION - SEARCH STRING 
DB4F  BDC8D2                    JSR  LB146         ;'TM' ERROR IF NUMERIC
DB52  9E52            L879C     LDX  FPA0+2        ;SEARCH STRING DESCRIPTOR ADDRESS 
DB54  3410                      PSHS X             ;SAVE ON THE STACK 
DB56  BDC9F9                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DB59  BDDAFE                    JSR  L8748         ;EVALUATE TARGET STRING EXPRESSION 
DB5C  3414                      PSHS X,B           ;SAVE ADDRESS AND LENGTH ON STACK 
DB5E  BDC9F3                    JSR  LB267         ;SYNTAX CHECK FOR ')' 
DB61  AE63                      LDX  $03,S         ;* LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS 
DB63  BDCDE0                    JSR  LB659         ;* AND GET THE LENGTH ANDADDRESS OF SEARCH STRING 
DB66  3404                      PSHS B             ;SAVE LENGTH ON STACK 
                      *                              
                      * AT THIS POINT THE STACK HAS;THE FOLLOWING INFORMATION                      
                      * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET                      
                      * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION                      
DB68  E166                      CMPB $06,S         ;COMPARE LENGTH OF SEARCH STRING TO START 
DB6A  2523                      BLO  L87D9         ;POSITION; RETURN 0 IF LENGTH < START 
DB6C  A661                      LDA  $01,S         ;GET LENGTH OF TARGET STRING 
DB6E  271C                      BEQ  L87D6         ;BRANCH IF TARGET STRING = NULL 
DB70  E666                      LDB  $06,S         ;GET START POSITION 
DB72  5A                        DECB               ;MOVE BACK ONE 
DB73  3A                        ABX                ;POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START  
DB74  3184            L87BE     LEAY ,X            ;POINT Y TO SEARCH POSITION 
DB76  EE62                      LDU  $02,S         ;POINT U TO START OF TARGET 
DB78  E661                      LDB  $01,S         ;LOAD ACCB WITH LENGTH OF TARGET 
DB7A  A6E4                      LDA  ,S            ;LOAD ACCA WITH LENGTH OF SEARCH 
DB7C  A066                      SUBA $06,S         ;SUBTRACT SEARCH POSITION FROM SEARCH LENGTH 
DB7E  4C                        INCA               ;ADD ONE 
DB7F  A161                      CMPA $01,S         ;COMPARE TO TARGET LENGTH 
DB81  250C                      BLO  L87D9         ;RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
DB83  A680            L87CD     LDA  ,X+           ;GET A CHARACTER FROM SEARCH STRING 
DB85  A1C0                      CMPA ,U+           ;COMPARE IT TO TARGET STRING 
DB87  260C                      BNE  L87DF         ;BRANCH IF NO MATCH 
DB89  5A                        DECB               ;DECREMENT TARGET LENGTH 
DB8A  26F7                      BNE  L87CD         ;CHECK ANOTHER CHARACTER 
DB8C  E666            L87D6     LDB  $06,S         ;GET MATCH POSITION 
DB8E  21              L87D8     FCB  SKP1          ;SKIP NEXT BYTE 
DB8F  5F              L87D9     CLRB               ;MATCH ADDRESS = 0 
DB90  3267                      LEAS $07,S         ;CLEAN UP THE STACK 
DB92  7ECC7A                    JMP  LB4F3         ;CONVERT ACCB TO FP NUMBER 
DB95  6C66            L87DF     INC  $06,S         ;INCREMENT SEARCH POSITION 
DB97  3021                      LEAX 1,Y           ;MOVE X TO NEXT SEARCH POSITION 
DB99  20D9                      BRA  L87BE         ;KEEP LOOKING FOR A MATCH 
                                                     
                      * EXTENDED BASIC RVEC19 HOOK CODE                      
DB9B  8126            XVEC19    CMPA #'&'          ;* 
DB9D  265C                      BNE  L8845         ;* RETURN IF NOT HEX OR OCTAL VARIABLE 
DB9F  3262                      LEAS $02,S         ;PURGE RETURN ADDRESS FROM STACK 
                      * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
DBA1  0F52            L87EB     CLR  FPA0+2        ;* CLEAR BOTTOM TWO 
DBA3  0F53                      CLR  FPA0+3        ;* BYTES OF FPA0 
DBA5  8E0052                    LDX  #FPA0+2       ;BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR) 
DBA8  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DBAA  814F                      CMPA #'O'            
DBAC  2712                      BEQ  L880A         ;YES 
DBAE  8148                      CMPA #'H'            
DBB0  2723                      BEQ  L881F         ;YES 
DBB2  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DBB4  200C                      BRA  L880C         ;DEFAULT TO OCTAL (&O) 
DBB6  8138            L8800     CMPA #'8'            
DBB8  1022EE47                  LBHI LB277           
DBBC  C603                      LDB  #$03          ;BASE 8 MULTIPLIER 
DBBE  8D2A                      BSR  L8834         ;ADD DIGIT TO TEMPORARY ACCUMULATOR 
                      * EVALUATE AN &O VARIABLE                      
DBC0  9D7C            L880A     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DBC2  25F2            L880C     BLO  L8800         ;BRANCH IF NUMERIC 
DBC4  0F50            L880E     CLR  FPA0          ;* CLEAR 2 HIGH ORDER 
DBC6  0F51                      CLR  FPA0+1        ;* BYTES OF FPA0 
DBC8  0F06                      CLR  VALTYP        ;SET VARXABLE TYPE TO NUMERIC 
DBCA  0F63                      CLR  FPSBYT        ;ZERO OUT SUB BYTE OF FPA0 
DBCC  0F54                      CLR  FP0SGN        ;ZERO OUT MANTISSA SIGN OF FPA0 
DBCE  C6A0                      LDB  #$A0          ;* SET EXPONENT OF FPA0 
DBD0  D74F                      STB  FP0EXP        ;* 
DBD2  7ED168                    JMP  LBA1C         ;GO NORMALIZE FPA0 
                      * EVALUATE AN &H VARIABLE                      
DBD5  9D7C            L881F     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DBD7  250B                      BLO  L882E         ;BRANCH IF NUMERIC 
DBD9  BDCB29                    JSR  LB3A2         ;SET CARRY IF NOT ALPHA 
DBDC  25E6                      BLO  L880E         ;BRANCH IF NOT ALPHA OR NUMERIC 
DBDE  8147                      CMPA #'G'          ;CHECK FOR LETTERS A-F 
DBE0  24E2                      BCC  L880E         ;BRANCH IF >= G (ILLEGAL HEX LETTER) 
DBE2  8007                      SUBA #7            ;SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9 
DBE4  C604            L882E     LDB  #$04          ;BASE 16 DIGIT MULTIPLIER = 2**4 
DBE6  8D02                      BSR  L8834         ;ADD DIGIT TO TEMPORARY ACCUMULATOR 
DBE8  20EB                      BRA  L881F         ;KEEP EVALUATING VARIABLE 
DBEA  6801            L8834     ASL  $01,X         ;* MULTIPLY TEMPORARY 
DBEC  6984                      ROL  ,X            ;* ACCUMULATOR BY TWO 
DBEE  1025F5EC                  LBCS LBA92         ;'OV' OVERFLOW ERROR
DBF2  5A                        DECB               ;DECREMENT SHIFT COUNTER 
DBF3  26F5                      BNE  L8834         ;MULTIPLY TEMPORARY ACCUMULATOR AGAIN 
DBF5  8030                      SUBA #'0'          ;MASK OFF ASCII 
DBF7  AB01                      ADDA $01,X         ;* ADD DIGIT TO TEMPORARY 
DBF9  A701                      STA  $01,X         ;* ACCUMULATOR AND SAVE IT 
DBFB  39              L8845     RTS                  
                                                     
DBFC  3540            XVEC15    PULS U             ;PULL RETURN ADDRESS AND SAVE IN U REGISTER 
DBFE  0F06                      CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
DC00  9E83                      LDX  CHARAD        ;CURRENT INPUT POINTER TO X 
DC02  9D7C                      JSR  GETNCH        ;GET CHARACTER FROM BASIC 
DC04  8126                      CMPA #'&'          ;HEX AND OCTAL VARIABLES ARE PRECEEDED BY & 
DC06  2799                      BEQ  L87EB         ;PROCESS A '&' VARIABLE
DC08  81B0                      CMPA #TOK_FN       ;TOKEN FOR FN 
DC0A  275E                      BEQ  L88B4         ;PROCESS FN CALL 
DC0C  81FF                      CMPA #$FF          ;CHECK FOR SECONDARY TOKEN 
DC0E  2608                      BNE  L8862         ;NOT SECONDARY 
DC10  9D7C                      JSR  GETNCH        ;GET CHARACTER FROM BASIC 
DC12  8183                      CMPA #TOK_USR      ;TOKEN FOR USR 
DC14  102700AB                  LBEQ L892C         ;PROCESS USR CALL 
DC18  9F83            L8862     STX  CHARAD        ;RESTORE BASIC'S INPUT POINTER
DC1A  6EC4                      JMP  ,U            ;RETURN TO CALLING ROUTINE 
DC1C  9E68            L8866     LDX  CURLIN        ;GET CURRENT LINE NUMBER 
DC1E  3001                      LEAX 1,X           ;IN DIRECT MODE? 
DC20  26D9                      BNE  L8845         ;RETURN IF NOT IN DIRECT MODE 
DC22  C616                      LDB  #2*11         ;'ILLEGAL DIRECT STATEMENT' ERROR
DC24  7EC403          L886E     JMP  LAC46         ;PROCESS ERROR 
                                                     
DC27  AE9F0083        DEF       LDX  [CHARAD]      ;GET TWO INPUT CHARS 
DC2B  8CFF83                    CMPX #TOK_FF_USR   ;TOKEN FOR USR 
DC2E  10270074                  LBEQ L890F         ;BRANCH IF DEF USR 
DC32  8D23                      BSR  L88A1         ;GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME 
DC34  8DE6                      BSR  L8866         ;DON'T ALLOW DEF FN IF IN DIRECT MODE
DC36  BDC9F6                    JSR  LB26A         ;SYNTAX CHECK FOR '('
DC39  C680                      LDB  #$80          ;* GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE 
DC3B  D708                      STB  ARYDIS        ;* AND SAVE IT IN THE ARRAY DISABLE FLAG 
DC3D  BDCADE                    JSR  LB357         ;GET VARIABLE DESCRIPTOR 
DC40  8D25                      BSR  L88B1         ;'TM' ERROR IF STRING
DC42  BDC9F3                    JSR  LB267         ;SYNTAX CHECK FOR ')'
DC45  C6AE                      LDB  #TOK_EQUALS   ;TOKEN FOR '='
DC47  BDC9FB                    JSR  LB26F         ;DO A SYNTAX CHECK FOR = 
DC4A  9E4B                      LDX  V4B           ;GET THE ADDRESS OF THE FN NAME DESCRIPTOR 
DC4C  DC83                      LDD  CHARAD        ;* GET THE CURRENT INPUT POINTER ADDRESS AND 
DC4E  ED84                      STD  ,X            ;* SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR 
DC50  DC39                      LDD  VARPTR        ;= GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT 
DC52  ED02                      STD  $02,X         ;= VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME 
DC54  7EC690                    JMP  DATA          ;MOVE INPUT POINTER TO END OF LINE OR SUBLINE 
DC57  C6B0            L88A1     LDB  #TOK_FN       ;TOKEN FOR FN 
DC59  BDC9FB                    JSR  LB26F         ;DO A SYNTAX CHECK FOR FN 
DC5C  C680                      LDB  #$80          ;* GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG 
DC5E  D708                      STB  ARYDIS        ;* AND SAVE IT IN ARRAY VARIABLE FLAG 
DC60  8A80                      ORA  #$80          ;SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE 
DC62  BDCAE3                    JSR  LB35C         ;* GET THE DESCRIPTOR ADDRESS OF THIS 
DC65  9F4B                      STX  V4B           ;* VARIABLE AND SAVE IT IN V4B 
DC67  7EC8CF          L88B1     JMP  LB143         ;'TM' ERROR IF STRING VARIABLE
                      * EVALUATE AN FN CALL                      
DC6A  8DEB            L88B4     BSR  L88A1         ;* GET THE DESCRIPTOR OF THE FN NAME 
DC6C  3410                      PSHS X             ;* VARIABLE AND SAVE IT ON THE STACK 
DC6E  BDC9EE                    JSR  LB262         ;SYNTAX CHECK FOR '(' & EVALUATE EXPR
DC71  8DF4                      BSR  L88B1         ;'TM' ERROR IF STRING VARIABLE
DC73  3540                      PULS U             ;POINT U TO FN NAME DESCRIPTOR 
DC75  C632                      LDB  #2*25         ;'UNDEFINED FUNCTION CALL' ERROR
DC77  AE42                      LDX  $02,U         ;POINT X TO ARGUMENT VARIABLE DESCRIPTOR 
DC79  27A9                      BEQ  L886E         ;BRANCH TO ERROR HANDLER 
DC7B  109E83                    LDY  CHARAD        ;SAVE CURRENT INPUT POINTER IN Y 
DC7E  EEC4                      LDU  ,U            ;* POINT U TO START OF FN FORMULA AND 
DC80  DF83                      STU  CHARAD        ;* SAVE IT IN INPUT POINTER 
DC82  A604                      LDA  $04,X         ;= GET FP VALUE OF 
DC84  3402                      PSHS A             ;= ARGUMENT VARIABLE, CURRENT INPUT 
DC86  EC84                      LDD  ,X            ;= POINTER, AND ADDRESS OF START 
DC88  EE02                      LDU  $02,X         ;= OF FN FORMULA AND SAVE 
DC8A  3476                      PSHS U,Y,X,B,A     ;= THEM ON THE STACK 
DC8C  BDD381                    JSR  LBC35         ;PACK FPA0 AND SAVE IT IN (X) 
DC8F  BDC8CD          L88D9     JSR  LB141         ;EVALUATE FN EXPRESSION 
DC92  3576                      PULS A,B,X,Y,U     ;RESTORE REGISTERS 
DC94  ED84                      STD  ,X            ;* GET THE FP 
DC96  EF02                      STU  $02,X         ;* VALUE OF THE ARGUMENT 
DC98  3502                      PULS A             ;* VARIABLE OFF OF THE 
DC9A  A704                      STA  $04,X         ;* STACK AND RE-SAVE IT 
DC9C  9D82                      JSR  GETCCH        ;GET FINAL CHARACTER OF THE FN FORMULA 
DC9E  1026ED61                  LBNE LB277         ;'SYNTAX' ERROR IF NOT END OF LINE
DCA2  109F83                    STY  CHARAD        ;RESTORE INPUT POINTER 
DCA5  39              L88EF     RTS                  
                                                     
                                                     
                                                     
                      * DEF USR                      
DCA6  9D7C            L890F     JSR  GETNCH        ;SKIP PAST SECOND BYTE OF DEF USR TOKEN 
DCA8  8D09                      BSR  L891C         ;GET FN NUMBER 
DCAA  3410                      PSHS X             ;SAVE FN EXEC ADDRESS STORAGE LOC 
DCAC  8D2D                      BSR  L8944         ;CALCULATE EXEC ADDRESS 
DCAE  3540                      PULS U             ;GET FN EXEC ADDRESS STORAGE LOC 
DCB0  AFC4                      STX  ,U            ;SAVE EXEC ADDRESS 
DCB2  39                        RTS                  
DCB3  5F              L891C     CLRB               ;DEFAULT TO USR0 IF NO ARGUMENT 
DCB4  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DCB6  2406                      BCC  L8927         ;BRANCH IF NOT NUMERIC 
DCB8  8030                      SUBA #'0'          ;MASK OFF ASCII 
DCBA  1F89                      TFR  A,B           ;SAVE USR NUMBER IN ACCB 
DCBC  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DCBE  9E8D            L8927     LDX  USRADR        ;GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS 
DCC0  58                        ASLB               ;X2 - 2 BYTES/USR ADDRESS 
DCC1  3A                        ABX                ;ADD OFFSET TO START ADDRESS OF STORAGE LOCs 
DCC2  39                        RTS                  
                      * PROCESS A USR CALL                      
DCC3  8DEE            L892C     BSR  L891C         ;GET STORAGE LOC OF EXEC ADDRESS FOR USR N 
DCC5  AE84                      LDX  ,X            ;* GET EXEC ADDRESS AND 
DCC7  3410                      PSHS X             ;* PUSH IT ONTO STACK 
DCC9  BDC9EE                    JSR  LB262         ;SYNTAX CHECK FOR '(' & EVALUATE EXPR
DCCC  8E004F                    LDX  #FP0EXP       ;POINT X TO FPA0 
DCCF  9606                      LDA  VALTYP        ;GET VARIABLE TYPE 
DCD1  2707                      BEQ  L8943         ;BRANCH IF NUMERIC, STRING IF <> 0 
DCD3  BDCDDE                    JSR  LB657         ;GET LENGTH & ADDRESS OF STRING VARIABLE 
DCD6  9E52                      LDX  FPA0+2        ;GET POINTER TO STRING DESCRIPTOR 
DCD8  9606                      LDA  VALTYP        ;GET VARIABLE TYPE 
DCDA  39              L8943     RTS                ;JUMP TO USR ROUTINE (PSHS X ABOVE) 
DCDB  C6AE            L8944     LDB  #TOK_EQUALS   ;TOKEN FOR '='
DCDD  BDC9FB                    JSR  LB26F         ;DO A SYNTAX CHECK FOR = 
DCE0  7ECEC4                    JMP  LB73D         ;EVALUATE EXPRESSION, RETURN VALUE IN X 
                                                     
                                                     
                                                     
                      * DEL                          
DCE3  1027EEEA        DEL       LBEQ LB44A         ;FC' ERROR IF NO ARGUMENT
DCE7  BDC717                    JSR  LAF67         ;CONVERT A DECIMAL BASiC NUMBER TO BINARY 
DCEA  BDC4A2                    JSR  LAD01         ;FIND RAM ADDRESS OF START OF A BASIC LINE 
DCED  9F93                      STX  VD3           ;SAVE RAM ADDRESS OF STARTING LINE NUMBER 
DCEF  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DCF1  2710                      BEQ  L8990         ;BRANCH IF END OF LINE 
DCF3  81A7                      CMPA #TOK_MINUS    ;TOKEN FOR '-'
DCF5  263B                      BNE  L89BF         ;TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
DCF7  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DCF9  2704                      BEQ  L898C         ;IF END OF LINE, USE DEFAULT ENDING LINE NUMBER 
DCFB  8D24                      BSR  L89AE         ;* CONVERT ENDING LINE NUMBER TO BINARY 
DCFD  2004                      BRA  L8990         ;* AND SAVE IT IN BINVAL 
DCFF  86FF            L898C     LDA  #$FF          ;= USE $FFXX AS DEFAULT ENDING 
DD01  972B                      STA  BINVAL        ;= LINE NUMBER - SAVE IT IN BINVAL 
DD03  DE93            L8990     LDU  VD3           ;POINT U TO STARTING LINE NUMBER ADDRESS 
DD05  8C              L8992     FCB  SKP2          ;SKIP TWO BYTES 
DD06  EEC4            L8993     LDU  ,U            ;POINT U TO START OF NEXT LINE 
DD08  ECC4                      LDD  ,U            ;CHECK FOR END OF PROGRAM 
DD0A  2706                      BEQ  L899F         ;BRANCH IF END OF PROGRAM 
DD0C  EC42                      LDD  $02,U         ;LOAD ACCD WITH THIS LINE'S NUMBER
DD0E  932B                      SUBD BINVAL        ;SUBTRACT ENDING LINE NUMBER ADDRESS 
DD10  23F4                      BLS  L8993         ;BRANCH IF = < ENDING LINE NUMBER 
DD12  9E93            L899F     LDX  VD3           ;GET STARTING LINE NUMBER 
DD14  8D15                      BSR  L89B8         ;MOVE (U) TO (X) UNTIL END OF PROGRAM 
DD16  BDC4C2                    JSR  LAD21         ;RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
DD19  9E93                      LDX  VD3           ;GET STARTING LINE NUMBER ADDRESS 
DD1B  BDC492                    JSR  LACF1         ;RECOMPUTE START OF NEXT LINE ADDRESSES 
DD1E  7EC422                    JMP  LAC73         ;JUMP TO BASIC'S MAIN COMMAND LOOP
DD21  BDC717          L89AE     JSR  LAF67         ;GO GET LINE NUMBER CONVERTED TO BINARY 
DD24  7EC1B5                    JMP  LA5C7         ;MAKE SURE THERE'S NO MORE ON THIS LINE
DD27  A6C0            L89B4     LDA  ,U+           ;GET A BYTE FROM (U) 
DD29  A780                      STA  ,X+           ;MOVE THE BYTE TO (X) 
DD2B  11931B          L89B8     CMPU VARTAB        ;COMPARE TO END OF BASIC 
DD2E  26F7                      BNE  L89B4         ;BRANCH IF NOT AT END 
DD30  9F1B                      STX  VARTAB        ;SAVE (X) AS NEW END OF BASIC 
DD32  39              L89BF     RTS                  
                                                     
                                                     
DD33  BDDC1C          L89C0     JSR  L8866         ;'BS' ERROR IF IN DIRECT MODE
DD36  9D7C                      JSR  GETNCH        ;GET A CHAR FROM BASIC 
DD38  8122            L89D2     CMPA #'"'          ;CHECK FOR PROMPT STRING 
DD3A  260B                      BNE  L89E1         ;BRANCH IF NO PROMPT STRING 
DD3C  BDC9D0                    JSR  LB244         ;STRIP OFF PROMPT STRING & PUT IT ON STRING STACK 
DD3F  C63B                      LDB  #';'          ;* 
DD41  BDC9FB                    JSR  LB26F         ;* DO A SYNTAX CHECK FOR; 
DD44  BDD0EB                    JSR  LB99F         ;REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT 
DD47  327E            L89E1     LEAS -2,S        ;RESERVE TWO STORAGE SLOTS ON STACK 
DD49  BDC7CC                    JSR  LB035         ;INPUT A LINE FROM CURRENT INPUT DEVICE 
DD4C  3262                      LEAS 2,S         ;CLEAN UP THE STACK 
DD4E  BDCADE                    JSR  LB357         ;SEARCH FOR A VARIABLE 
DD51  9F3B                      STX  VARDES        ;SAVE POINTER TO VARIABLE DESCRIPTOR 
DD53  BDC8D2                    JSR  LB146         ;'TM' ERROR IF VARIABLE TYPE = NUMERIC
DD56  8E00F3                    LDX  #LINBUF       ;POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED 
DD59  4F                        CLRA               ;TERMINATOR CHARACTER 0 (END OF LINE) 
DD5A  BDCCA3                    JSR  LB51A         ;PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE 
DD5D  7EC754                    JMP  LAFA4         ;REMOVE DESCRIPTOR FROM STRING STACK 
DD60  BDC717          L89FC     JSR  LAF67         ;STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE 
DD63  9E2B                      LDX  BINVAL        ;GET BINARY VALUE 
DD65  39                        RTS                  
DD66  9E91            L8A02     LDX  VD1           ;GET CURRENT OLD NUMBER BEING RENUMBERED 
DD68  9F2B            L8A04     STX  BINVAL        ;SAVE THE LINE NUMBER BEING SEARCHED FOR 
DD6A  7EC4A2                    JMP  LAD01         ;GO FIND THE LINE NUMBER IN BASIC PROGRAM 
                                                     
                      * RENUM                        
DD6D  BDC4C7          RENUM     JSR  LAD26         ;ERASE VARIABLES 
DD70  CC000A                    LDD  #10           ;DEFAULT LINE NUMBER INTERVAL 
DD73  DD95                      STD  VD5           ;SAVE DEFAULT RENUMBER START LINE NUMBER 
DD75  DD8F                      STD  VCF           ;SAVE DEFAULT INTERVAL 
DD77  5F                        CLRB               ;NOW ACCD = 0 
DD78  DD91                      STD  VD1           ;DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING 
DD7A  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DD7C  2406                      BCC  L8A20         ;BRANCH IF NOT NUMERIC 
DD7E  8DE0                      BSR  L89FC         ;CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY 
DD80  9F95                      STX  VD5           ;SAVE LINE NUMBER WHERE RENUMBERING STARTS 
DD82  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DD84  271B            L8A20     BEQ  L8A3D         ;BRANCH IF END OF LINE 
DD86  BDC9F9                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DD89  2406                      BCC  L8A2D         ;BRANCH IF NEXT CHARACTER NOT NUMERIC 
DD8B  8DD3                      BSR  L89FC         ;CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY 
DD8D  9F91                      STX  VD1           ;SAVE NEW RENUMBER LINE 
DD8F  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DD91  270E            L8A2D     BEQ  L8A3D         ;BRANCH IF END OF LINE 
DD93  BDC9F9                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DD96  2406                      BCC  L8A3A         ;BRANCH IF NEXT CHARACTER NOT NUMERIC 
DD98  8DC6                      BSR  L89FC         ;CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY 
DD9A  9F8F                      STX  VCF           ;SAVE NEW INTERVAL 
DD9C  2749                      BEQ  L8A83         ;'FC' ERROR
DD9E  BDC1B5          L8A3A     JSR  LA5C7         ;CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
DDA1  8DC3            L8A3D     BSR  L8A02         ;GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED 
DDA3  9F93                      STX  VD3           ;SAVE ADDRESS 
DDA5  9E95                      LDX  VD5           ;GET NEXT RENUMBERED LINE NUMBER TO USE 
DDA7  8DBF                      BSR  L8A04         ;FIND THE LINE NUMBER IN THE BASIC PROGRAM 
DDA9  9C93                      CMPX VD3           ;COMPARE TO ADDRESS OF OLD LINE NUMBER 
DDAB  253A                      BLO  L8A83         ;'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
DDAD  8D1C                      BSR  L8A67         ;MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE 
DDAF  BDDE41                    JSR  L8ADD         ;CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
DDB2  BDC490                    JSR  LACEF         ;RECALCULATE NEXT LINE RAM ADDRESSES 
DDB5  8DAF                      BSR  L8A02         ;GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED 
DDB7  9F93                      STX  VD3           ;SAVE IT 
DDB9  8D3A                      BSR  L8A91         ;MAKE SURE LINE NUMBERS EXIST 
DDBB  8D0F                      BSR  L8A68         ;INSERT NEW LINE NUMBERS IN LINE HEADERS 
DDBD  8D36                      BSR  L8A91         ;INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS 
DDBF  BDDEDC                    JSR  L8B7B         ;CONVERT PACKED BINARY LINE NUMBERS TO ASCII 
DDC2  BDC4C7                    JSR  LAD26         ;ERASE VARIABLES 
DDC5  BDC490                    JSR  LACEF         ;RECALCULATE NEXT LINE RAM ADDRESS 
DDC8  7EC422                    JMP  LAC73         ;GO BACK TO BASIC'S MAIN LOOP
DDCB  86              L8A67     FCB  SKP1LD        ;SKIP ONE BYTE - LDA #$4F 
DDCC  4F              L8A68     CLRA               ;NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS 
DDCD  9798                      STA  VD8           ;SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS 
DDCF  9E93                      LDX  VD3           ;GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED 
DDD1  DC95                      LDD  VD5           ;GET THE CURRENT RENUMBERED LINE NUMBER 
DDD3  8D15                      BSR  L8A86         ;RETURN IF END OF PROGRAM 
DDD5  0D98            L8A71     TST  VD8           ;CHECK NEW LINE NUMBER FLAG 
DDD7  2602                      BNE  L8A77         ;BRANCH IF NOT INSERTING NEW LINE NUMBERS 
DDD9  ED02                      STD  $02,X         ;STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM 
DDDB  AE84            L8A77     LDX  ,X            ;POINT X TO THE NEXT LINE IN BASIC 
DDDD  8D0B                      BSR  L8A86         ;RETURN IF END OF PROGRAM 
DDDF  D38F                      ADDD VCF           ;ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER 
DDE1  2504                      BLO  L8A83         ;'FC' ERROR IF LINE NUMBER > $FFFF
DDE3  81FA                      CMPA #MAXLIN       ;LARGEST LINE NUMBER = $F9FF 
DDE5  25EE                      BLO  L8A71         ;BRANCH IF LEGAL LINE NUMBER 
DDE7  7ECBD1          L8A83     JMP  LB44A         ;'FC' ERROR IF LINE NUMBER MS BYTE > $F9
                      * TEST THE TWO BYTES POINTED TO BY (X).                      
                      * NORMAL RETURN IF <> 0. IF =;0 (END OF                      
                      * PROGRAM) RETURN IS PULLED OFF STACK AND                      
                      * YOU RETURN TO PREVIOUS SUBROUTINE CALL.                      
DDEA  3406            L8A86     PSHS B,A           ;SAVE ACCD 
DDEC  EC84                      LDD  ,X            ;TEST THE 2 BYTES POINTED TO BY X 
DDEE  3506                      PULS A,B           ;RESTORE ACCD 
DDF0  2602                      BNE  L8A90         ;BRANCH IF NOT END OF PROGRAM 
DDF2  3262                      LEAS $02,S         ;PURGE RETURN ADDRESS FROM STACK 
DDF4  39              L8A90     RTS                  
DDF5  9E19            L8A91     LDX  TXTTAB        ;GET START OF BASIC PROGRAM 
DDF7  301F                      LEAX -1,X        ;MOVE POINTER BACK ONE 
DDF9  3001            L8A95     LEAX 1,X         ;MOVE POINTER UP ONE 
DDFB  8DED                      BSR  L8A86         ;RETURN IF END OF PROGRAM 
DDFD  3003            L8A99     LEAX 3,X         ;SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER 
DDFF  3001            L8A9B     LEAX 1,X         ;MOVE POINTER TO NEXT CHARACTER 
DE01  A684                      LDA  ,X            ;CHECK CURRENT CHARACTER 
DE03  27F4                      BEQ  L8A95         ;BRANCH IF END OF LINE 
DE05  9F0F                      STX  TEMPTR        ;SAVE CURRENT POINTER 
DE07  4A                        DECA               ;= 
DE08  270C                      BEQ  L8AB2         ;=BRANCH IF START OF PACKED NUMERIC LINE 
DE0A  4A                        DECA               ;* 
DE0B  272A                      BEQ  L8AD3         ;*BRANCH IF LINE NUMBER EXISTS 
DE0D  4A                        DECA               ;= 
DE0E  26EF                      BNE  L8A9B         ;=MOVE TO NEXT CHARACTER IF > 3 
DE10  8603            L8AAC     LDA  #$03          ;* SET 1ST BYTE = 3 TO INDICATE LINE 
DE12  A780                      STA  ,X+           ;* NUMBER DOESN'T CURRENTLY EXIST
DE14  20E7                      BRA  L8A99         ;GO GET ANOTHER CHARACTER 
DE16  EC01            L8AB2     LDD  $01,X         ;GET MS BYTE OF LINE NUMBER 
DE18  6A02                      DEC  $02,X         ;DECREMENT ZERO CHECK BYTE 
DE1A  2701                      BEQ  L8AB9         ;BRANCH IF MS BYTE <> 0 
DE1C  4F                        CLRA               ;CLEAR MS BYTE 
DE1D  E603            L8AB9     LDB  $03,X         ;GET LS BYTE OF LINE NUMBER 
DE1F  6A04                      DEC  $04,X         ;DECREMENT ZERO CHECK FLAG 
DE21  2701                      BEQ  L8AC0         ;BRANCH IF IS BYTE <> 0 
DE23  5F                        CLRB               ;CLEAR LS BYTE 
DE24  ED01            L8AC0     STD  $01,X         ;SAVE BINARY LINE NUMBER 
DE26  DD2B                      STD  BINVAL        ;SAVE TRIAL LINE NUMBER 
DE28  BDC4A2                    JSR  LAD01         ;FIND RAM ADDRESS OF A BASIC LINE NUMBER 
DE2B  9E0F            L8AC7     LDX  TEMPTR        ;GET BACK POINTER TO START OF PACKED LINE NUMBER 
DE2D  25E1                      BLO  L8AAC         ;BRANCH IF NO LINE NUMBER MATCH FOUND 
DE2F  DC47                      LDD  V47           ;GET START ADDRESS OF LINE NUMBER 
DE31  6C80                      INC  ,X+           ;* SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR 
                      *              * EXISTENCE OF;LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS  
                                                     
DE33  ED84                      STD  ,X            ;SAVE RAM ADDRESS OF CORRECT LINE NUMBER 
DE35  20C6                      BRA  L8A99         ;GO GET ANOTHER CHARACTER 
DE37  6F84            L8AD3     CLR  ,X            ;CLEAR CARRY FLAG AND 1ST BYTE 
DE39  AE01                      LDX  $01,X         ;POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER 
DE3B  AE02                      LDX  $02,X         ;PUT CORRECT LINE NUMBER INTO (X) 
DE3D  9F47                      STX  V47           ;SAVE IT TEMPORARILY 
DE3F  20EA                      BRA  L8AC7         ;GO INSERT IT INTO BASIC LINE 
DE41  9E19            L8ADD     LDX  TXTTAB        ;GET BEGINNING OF BASIC PROGRAM 
DE43  2004                      BRA  L8AE5           
DE45  9E83            L8AE1     LDX  CHARAD        ;*GET CURRENT INPUT POINTER 
DE47  3001                      LEAX 1,X         ;*AND BUMP IT ONE 
DE49  8D9F            L8AE5     BSR  L8A86         ;RETURN IF END OF PROGRAM 
DE4B  3002                      LEAX 2,X         ;SKIP PAST NEXT LINE ADDRESS 
DE4D  3001            L8AE9     LEAX 1,X         ;ADVANCE POINTER BY ONE 
DE4F  9F83            L8AEB     STX  CHARAD        ;SAVE NEW BASIC INPUT POINTER 
DE51  9D7C            L8AED     JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
DE53  4D              L8AEF     TSTA               ;CHECK THE CHARACTER 
DE54  27EF                      BEQ  L8AE1         ;BRANCH IF END OF LINE 
DE56  2AF9                      BPL  L8AED         ;BRANCH IF NOT A TOKEN 
DE58  9E83                      LDX  CHARAD        ;GET CURRENT INPUT POINTER 
DE5A  81FF                      CMPA #$FF          ;IS THIS A SECONDARY TOKEN? 
DE5C  27EF                      BEQ  L8AE9         ;YES - IGNORE IT 
DE5E  81A2                      CMPA #TOK_THEN     ;TOKEN FOR THEN? 
DE60  2712                      BEQ  L8B13         ;YES 
DE62  8184                      CMPA #TOK_ELSE     ;TOKEN FOR ELSE? 
DE64  270E                      BEQ  L8B13         ;YES 
DE66  8181                      CMPA #TOK_GO       ;TOKEN FOR GO? 
DE68  26E7                      BNE  L8AED         ;NO 
DE6A  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DE6C  81A0                      CMPA #TOK_TO       ;TOKEN FOR TO? 
DE6E  2704                      BEQ  L8B13         ;YES 
DE70  81A1                      CMPA #TOK_SUB      ;TOKEN FOR SUB? 
DE72  26DB                      BNE  L8AEB         ;NO 
DE74  9D7C            L8B13     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DE76  2504                      BLO  L8B1B         ;BRANCH IF NUMERIC 
DE78  9D82            L8B17     JSR  GETCCH        ;GET CURRENT BASIC INPUT CHARRACTER 
DE7A  20D7                      BRA  L8AEF         ;KEEP CHECKING THE LINE 
DE7C  9E83            L8B1B     LDX  CHARAD        ;GET CURRENT INPUT ADDRESS 
DE7E  3410                      PSHS X             ;SAVE IT ON THE STACK 
DE80  BDC717                    JSR  LAF67         ;CONVERT DECIMAL BASIC NUMBER TO BINARY 
DE83  9E83                      LDX  CHARAD        ;GET CURRENT INPUT POINTER 
DE85  A682            L8B24     LDA  ,-X           ;GET PREVIOUS INPUT CHARACTER 
DE87  BDE1EC                    JSR  L90AA         ;CLEAR CARRY IF NUMERIC INPUT VALUE 
DE8A  25F9                      BLO  L8B24         ;BRANCH IF NON-NUMERIC 
DE8C  3001                      LEAX 1,X         ;MOVE POINTER UP ONE 
DE8E  1F10                      TFR  X,D           ;NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER 
DE90  E061                      SUBB 1,S         ;SUBTRACT PRE-NUMERIC POINTER LS BYTE 
DE92  C005                      SUBB #$05          ;MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE 
                      *                              
DE94  2720                      BEQ  L8B55         ;BRANCH IF EXACTLY 5 
DE96  250A                      BLO  L8B41         ;BRANCH IF < 5 
DE98  3384                      LEAU ,X            ;TRANSFER X TO U 
DE9A  50                        NEGB               ;NEGATE B 
DE9B  3085                      LEAX B,X           ;MOVE X BACK B BYTES 
DE9D  BDDD2B                    JSR  L89B8         ;*MOVE BYTES FROM (U) TO (X) UNTIL 
                      *         *U   = END OF BASIC; (I) = NEW END OF BASIC  
DEA0  2014                      BRA  L8B55           
                      * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER                      
DEA2  9F47            L8B41     STX  V47           ;SAVE END OF NUMERIC VALUE 
DEA4  9E1B                      LDX  VARTAB        ;GET END OF BASIC PROGRAM 
DEA6  9F43                      STX  V43           ;SAVE IT 
DEA8  50                        NEGB               ;NEGATE B 
DEA9  3085                      LEAX B,X           ;ADD IT TO END OF NUMERIC POiNTER 
DEAB  9F41                      STX  V41           ;SAVE POINTER 
DEAD  9F1B                      STX  VARTAB        ;STORE END OF BASIC PROGRAM 
DEAF  BDC3DB                    JSR  LAC1E         ;ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM 
DEB2  9E45                      LDX  V45           ;* GET AND SAVE THE 
DEB4  9F83                      STX  CHARAD        ;* NEW CURRENT INPUT POINTER 
DEB6  3510            L8B55     PULS X             ;RESTORE POINTER TO START OF NUMERIC VALUE 
DEB8  8601                      LDA  #$01          ;NEW LINE NUMBER FLAG 
DEBA  A784                      STA  ,X            ;* SAVE NEW LINE FLAG 
DEBC  A702                      STA  $02,X         ;* 
DEBE  A704                      STA  $04,X         ;* 
DEC0  D62B                      LDB  BINVAL        ;GET MS BYTE OF BINARY LINE NUMBER 
DEC2  2604                      BNE  L8B67         ;BRANCH IF IT IS NOT ZERO 
DEC4  C601                      LDB  #$01          ;SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL 
                      *              THINK IT IS THE END OF A LINE  
DEC6  6C02                      INC  $02,X         ;IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO 
DEC8  E701            L8B67     STB  $01,X         ;SAVE MS BYTE OF BINARY LINE NUMBER 
DECA  D62C                      LDB  BINVAL+1      ;GET IS BYTE OF BINARY LINE NUMBER 
DECC  2604                      BNE  L8B71         ;BRANCH IF NOT A ZERO BYTE 
DECE  C601                      LDB  #$01          ;SAVE A 1 IF BYTE IS A 0 
DED0  6C04                      INC  $04,X         ;IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0 
DED2  E703            L8B71     STB  $03,X         ;SAVE LS BYTE OF BINARY LINE NUMBER 
DED4  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DED6  812C                      CMPA #','          ;IS IT A COMMA? 
DED8  279A                      BEQ  L8B13         ;YES - PROCESS ANOTHER NUMERIC VALUE 
DEDA  209C                      BRA  L8B17         ;NO - GO GET AND PROCESS AN INPUT CHARACTER 
DEDC  9E19            L8B7B     LDX  TXTTAB        ;POINT X TO START OF BASIC PROGRAM 
DEDE  301F                      LEAX -1,X        ;MOVE POINTER BACK ONE 
DEE0  3001            L8B7F     LEAX 1,X         ;MOVE POINTER UP ONE 
DEE2  EC02                      LDD  2,X         ;GET ADDRESS OF NEXT LINE 
DEE4  DD68                      STD  CURLIN        ;SAVE IT IN CURLIN 
DEE6  BDDDEA                    JSR  L8A86         ;RETURN IF END OF PROGRAM 
DEE9  3003                      LEAX 3,X         ;SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER 
DEEB  3001            L8B8A     LEAX 1,X         ;MOVE POINTER UP ONE 
DEED  A684            L8B8C     LDA  ,X            ;GET CURRENT CHARACTER 
DEEF  27EF                      BEQ  L8B7F         ;BRANCH IF END OF LINE 
DEF1  4A                        DECA               ;INPUT CHARACTER = 1? - VALID LINE NUMBER 
DEF2  271B                      BEQ  L8BAE         ;YES 
DEF4  8002                      SUBA #$02          ;INPUT CHARACTER 3? - UL LINE NUMBER 
DEF6  26F3                      BNE  L8B8A         ;NO 
DEF8  3410                      PSHS X             ;SAVE CURRENT POSITION OF INPUT POINTER 
DEFA  8EDF39                    LDX  #L8BD9-1      ;POINT X TO 'UL' MESSAGE
DEFD  BDD0E8                    JSR  LB99C         ;PRINT STRING TO THE SCREEN 
DF00  AEE4                      LDX  ,S            ;GET INPUT POINTER 
DF02  EC01                      LDD  $01,X         ;GET THE UNDEFINED LINE NUMBER 
DF04  BDD518                    JSR  LBDCC         ;CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT 
DF07  BDD511                    JSR  LBDC5         ;PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
DF0A  BDD0A8                    JSR  LB958         ;SEND A CR TO CONSOLE OUT 
DF0D  3510                      PULS X             ;GET INPUT POINTER BACK 
DF0F  3410            L8BAE     PSHS X             ;SAVE CURRENT POSITION OF INPUT POINTER 
DF11  EC01                      LDD  $01,X         ;LOAD ACCD WITH BINARY VALUE OF LINE NUMBER 
DF13  DD52                      STD  FPA0+2        ;SAVE IN BOTTOM 2 BYTES OF FPA0 
DF15  BDDBC4                    JSR  L880E         ;ADJUST REST OF FPA0 AS AN INTEGER 
DF18  BDD525                    JSR  LBDD9         ;CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER 
DF1B  3540                      PULS U             ;LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER 
DF1D  C605                      LDB  #$05          ;EACH EXPANDED LINE NUMBER USES 5 BYTES 
DF1F  3001            L8BBE     LEAX $01,X         ;MOVE POINTER FORWARD ONE 
DF21  A684                      LDA  ,X            ;GET AN ASCII BYTE 
DF23  2705                      BEQ  L8BC9         ;BRANCH IF END OF NUMBER 
DF25  5A                        DECB               ;DECREMENT BYTE COUNTER 
DF26  A7C0                      STA  ,U+           ;STORE ASCII NUMBER IN BASIC LINE 
DF28  20F5                      BRA  L8BBE         ;CHECK FOR ANOTHER DIGIT 
DF2A  30C4            L8BC9     LEAX ,U            ;TRANSFER NEW LINE POINTER TO (X) 
DF2C  5D                        TSTB               ;DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?  
DF2D  27BE                      BEQ  L8B8C         ;YES - GO GET ANOTHER INPUT CHARACTER 
DF2F  31C4                      LEAY ,U            ;SAVE NEW LINE POINTER IN Y 
DF31  33C5                      LEAU B,U           ;POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK 
DF33  BDDD2B                    JSR  L89B8         ;MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM 
DF36  30A4                      LEAX ,Y            ;LOAD (X) WITH NEW LINE POINTER 
DF38  20B3                      BRA  L8B8C         ;GO GET ANOTHER INPUT CHARACTER 
                                                     
DF3A  554C20          L8BD9     FCC  "UL "         ;UNKNOWN LINE NUMBER MESSAGE 
DF3D  00                        FCB  0               
                                                     
                                                     
DF3E  BDCEC7          HEXDOL    JSR  LB740         ;CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER 
DF41  8E01F0                    LDX  #STRBUF+2     ;POINT TO TEMPORARY BUFFER 
DF44  C604                      LDB  #$04          ;CONVERT 4 NIBBLES 
DF46  3404            L8BE5     PSHS B             ;SAVE NIBBLE COUNTER 
DF48  5F                        CLRB               ;CLEAR CARRY FLAG 
DF49  8604                      LDA  #$04          ;4 SHIFTS 
DF4B  0853            L8BEA     ASL  FPA0+3        ;* SHIFT BOTTOM TWO BYTES OF 
DF4D  0952                      ROL  FPA0+2        ;* FPA0 LEFT ONE BIT (X2) 
DF4F  59                        ROLB               ;IF OVERFLOW, ACCB <> 0 
DF50  4A                        DECA               ;* DECREMENT SHIFT COUNTER AND 
DF51  26F8                      BNE  L8BEA         ;* BRANCH IF NOT DONE 
DF53  5D                        TSTB               ;CHECK FOR OVERFLOW  
DF54  260A                      BNE  L8BFF         ;BRANCH IF OVERFLOW 
DF56  A6E4                      LDA  ,S            ;* GET NIBBLE COUNTER, 
DF58  4A                        DECA               ;* DECREMENT IT AND 
DF59  2705                      BEQ  L8BFF         ;* BRANCH IF DONE 
DF5B  8C01F0                    CMPX #STRBUF+2     ;DO NOT DO A CONVERSION UNTIL A NON-ZERO 
DF5E  270C                      BEQ  L8C0B         ;BYTE IS FOUND - LEADING ZERO SUPPRESSION 
DF60  CB30            L8BFF     ADDB #'0'          ;ADD IN ASCII ZERO 
DF62  C139                      CMPB #'9'          ;COMPARE TO ASCII 9 
DF64  2302                      BLS  L8C07         ;BRANCH IF < 9 
DF66  CB07                      ADDB #7            ;ADD ASCII OFFSET IF HEX LETTER 
DF68  E780            L8C07     STB  ,X+           ;STORE HEX VALUE AND ADVANCE POINTER 
DF6A  6F84                      CLR  ,X            ;CLEAR NEXT BYTE - END OF STRING FLAG 
DF6C  3504            L8C0B     PULS B             ;* GET NIBBLE COUNTER, 
DF6E  5A                        DECB               ;* DECREMENT IT AND 
DF6F  26D5                      BNE  L8BE5         ;* BRANCH IF NOT DONE 
DF71  3262                      LEAS $02,S         ;PURGE RETURN ADDRESS OFF OF STACK 
DF73  8E01EF                    LDX  #STRBUF+1     ;RESET POINTER 
DF76  7ECC9F                    JMP  LB518         ;SAVE STRING ON STRING STACK 
                      * PROCESS EXCLAMATION POINT                      
DF79  8601            L8E37     LDA  #$01          ;* SET SPACES 
DF7B  9799                      STA  VD9           ;* COUNTER = 1 
                      * PROCESS STRING ITEM - LIST                      
DF7D  5A              L8E3B     DECB               ;DECREMENT FORMAT STRING LENGTH COUNTER 
DF7E  BDE11A                    JSR  L8FD8         ;SEND A '+' TO CONSOLE OUT IF VDA <>0 
DF81  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DF83  10270093                  LBEQ L8ED8         ;EXIT PRINT USING IF END OF LINE 
DF87  D793                      STB  VD3           ;SAVE REMAINDER FORMAT STRING LENGTH 
DF89  BDC8E2                    JSR  LB156         ;EVALUATE EXPRESSION 
DF8C  BDC8D2                    JSR  LB146         ;'TM' ERROR IF NUMERIC VARIABLE
DF8F  9E52                      LDX  FPA0+2        ;* GET ITEM - LIST DESCRIPTOR ADDRESS 
DF91  9F4D                      STX  V4D           ;* AND SAVE IT IN V4D 
DF93  D699                      LDB  VD9           ;GET SPACES COUNTER 
DF95  BDCE34                    JSR  LB6AD         ;PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK 
DF98  BDD0EB                    JSR  LB99F         ;PRINT THE FORMATTED STRING TO CONSOLE OUT 
                      * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH                      
DF9B  9E52                      LDX  FPA0+2        ;POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS 
DF9D  D699                      LDB  VD9           ;GET SPACES COUNTER 
DF9F  E084                      SUBB ,X            ;SUBTRACT LENGTH OF FORMATTED STRING 
DFA1  5A              L8E5F     DECB               ;DECREMENT DIFFERENCE 
DFA2  102B014F                  LBMI L8FB3         ;GO INTERPRET ANOTHER ITEM - LIST 
DFA6  BDD0F8                    JSR  LB9AC         ;PAD FORMAT STRING WITH A SPACE 
DFA9  20F6                      BRA  L8E5F         ;KEEP PADDING 
                      * PERCENT SIGN - PROCESS A %SPACES% COMMAND                      
DFAB  D793            L8E69     STB  VD3           ;* SAVE THE CURRENT FORMAT STRING 
DFAD  9F0F                      STX  TEMPTR        ;* COUNTER AND POINTER 
DFAF  8602                      LDA  #$02          ;INITIAL SPACES COUNTER = 2 
DFB1  9799                      STA  VD9           ;SAVE IN SPACES COUNTER 
DFB3  A684            L8E71     LDA  ,X            ;GET A CHARACTER FROM FORMAT STRING 
DFB5  8125                      CMPA #'%'          ;COMPARE TO TERMINATOR CHARACTER 
DFB7  27C4                      BEQ  L8E3B         ;BRANCH IF END OF SPACES COMMAND 
DFB9  8120                      CMPA #' '          ;BLANK 
DFBB  2607                      BNE  L8E82         ;BRANCH IF ILLEGAL CHARACTER 
DFBD  0C99                      INC  VD9           ;ADD ONE TO SPACES COUNTER 
DFBF  3001                      LEAX $01,X         ;MOVE FORMAT POINTER UP ONE 
DFC1  5A                        DECB               ;DECREMENT LENGTH COUNTER 
DFC2  26EF                      BNE  L8E71         ;BRANCH IF NOT END OF FORMAT STRING 
DFC4  9E0F            L8E82     LDX  TEMPTR        ;* RESTORE CURRENT FORMAT STRING COUNTER 
DFC6  D693                      LDB  VD3           ;* AND POINTER TO POSITION BEFORE SPACES COMMAND 
DFC8  8625                      LDA  #'%'          ;SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
                      * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING                      
DFCA  BDE11A          L8E88     JSR  L8FD8         ;SEND A '+' TO CONSOLE OUT IF VDA <> 0
DFCD  BDC017                    JSR  PUTCHR        ;SEND CHARACTER TO CONSOLE OUT 
DFD0  2029                      BRA  L8EB9         ;GET NEXT CHARACTER IN FORMAT STRING 
                                                     
                      * PRINT RAM HOOK                      
DFD2  81B1            XVEC9     CMPA #TOK_USING    ;USING TOKEN 
DFD4  2701                      BEQ  L8E95         ;BRANCH IF PRINT USING 
DFD6  39                        RTS                  
                                                     
                      * PRINT USING                      
                      * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE                      
                      * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE                      
                      * BIT 3 = PRE SIGN FORCE; BIT;2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE                      
DFD7  3262            L8E95     LEAS $02,S         ;PURGE RETURN ADDRESS OFF THE STACK 
DFD9  BDC8E4                    JSR  LB158         ;EVALUATE FORMAT STRING 
DFDC  BDC8D2                    JSR  LB146         ;'TM' ERROR IF VARIABLE TYPE = NUMERIC
DFDF  C63B                      LDB  #';'          ;CHECK FOR ITEM LIST SEPARATOR 
DFE1  BDC9FB                    JSR  LB26F         ;SYNTAX CHECK FOR ; 
DFE4  9E52                      LDX  FPA0+2        ;* GET FORMAT STRING DESCRIPTOR ADDRESS 
DFE6  9F95                      STX  VD5           ;* AND SAVE IT IN VD5 
DFE8  2006                      BRA  L8EAE         ;GO PROCESS FORMAT STRING 
DFEA  9697            L8EA8     LDA  VD7           ;*CHECK NEXT PRINT ITEM FLAG AND 
DFEC  2708                      BEQ  L8EB4         ;*'FC' ERROR IF NO FURTHER PRINT ITEMS
DFEE  9E95                      LDX  VD5           ;RESET FORMAT STRING POINTER TO START OF STRING 
DFF0  0F97            L8EAE     CLR  VD7           ;RESET NEXT PRINT ITEM FLAG 
DFF2  E684                      LDB  ,X            ;GET LENGTH OF FORMAT STRING 
DFF4  2603                      BNE  L8EB7         ;INTERPRET FORMAT STRING IF LENGTH > 0 
DFF6  7ECBD1          L8EB4     JMP  LB44A         ;'FC' ERROR IF FORMAT STRING = NULL
DFF9  AE02            L8EB7     LDX  $02,X         ;POINT X TO START OF FORMAT STRING 
                      * INTERPRET THE FORMAT STRING                      
DFFB  0F9A            L8EB9     CLR  VDA           ;CLEAR THE STATUS BYTE 
DFFD  0F99            L8EBB     CLR  VD9           ;CLEAR LEFT DIGIT COUNTER 
DFFF  A680                      LDA  ,X+           ;GET A CHARACTER FROM FORMAT STRING 
E001  8121                      CMPA #'!'          ;EXCLAMATION POINT? 
E003  1027FF72                  LBEQ L8E37         ;YES - STRING TYPE FORMAT 
E007  8123                      CMPA #'#'          ;NUMBER SIGN? (DIGIT LOCATOR) 
E009  275B                      BEQ  L8F24         ;YES - NUMERIC TYPE FORMAT 
E00B  5A                        DECB               ;DECREMENT FORMAT STRING LENGTH 
E00C  2616                      BNE  L8EE2         ;BRANCH IF NOT DONE 
E00E  BDE11A                    JSR  L8FD8         ;SEND A '+' TO CONSOLE OUT IF VDA <> 0
E011  BDC017                    JSR  PUTCHR        ;SEND CHARACTER TO CONSOLE OUT 
E014  9D82            L8ED2     JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
E016  26D2                      BNE  L8EA8         ;BRANCH IF NOT END OF LINE 
E018  9697                      LDA  VD7           ;GET NEXT PRINT ITEM FLAG 
E01A  2603            L8ED8     BNE  L8EDD         ;BRANCH IF MORE PRINT ITEMS 
E01C  BDD0A8                    JSR  LB958         ;SEND A CARRIAGE RETURN TO CONSOLE OUT 
E01F  9E95            L8EDD     LDX  VD5           ;POINT X TO FORMAT STRING DESCRIPTOR 
E021  7ECDE0                    JMP  LB659         ;RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING 
E024  812B            L8EE2     CMPA #'+'          ;CHECK FOR '+' (PRE-SIGN FORCE)
E026  2609                      BNE  L8EEF         ;NO PLUS 
E028  BDE11A                    JSR  L8FD8         ;SEND A '+' TO CONSOLE OUT IF VDA <> 0
E02B  8608                      LDA  #$08          ;* LOAD THE STATUS BYTE WITH 8; 
E02D  979A                      STA  VDA           ;* PRE-SIGN FORCE FLAG 
E02F  20CC                      BRA  L8EBB         ;INTERPRET THE REST OF THE FORMAT STRING 
E031  812E            L8EEF     CMPA #'.'          ;DECIMAL POINT? 
E033  274E                      BEQ  L8F41         ;YES 
E035  8125                      CMPA #'%'          ;PERCENT SIGN? 
E037  1027FF70                  LBEQ L8E69         ;YES 
E03B  A184                      CMPA ,X            ;COMPARE THE PRESENT FORMAT STRING INPUT 
                      *              CHARACTER TO THE NEXT ONE IN THE STRING  
E03D  268B            L8EFB     BNE  L8E88         ;NO MATCH - ILLEGAL CHARACTER 
                      * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING                      
E03F  8124                      CMPA #'$'          ;DOLLAR SIGN? 
E041  2719                      BEQ  L8F1A         ;YES - MAKE THE DOLLAR SIGN FLOAT 
E043  812A                      CMPA #'*'          ;ASTERISK? 
E045  26F6                      BNE  L8EFB         ;NO - ILLEGAL CHARACTER 
E047  969A                      LDA  VDA           ;* GRAB THE STATUS BYTE AND BET BIT 5 
E049  8A20                      ORA  #$20          ;* TO INDICATE THAT THE OUTPUT WILL 
E04B  979A                      STA  VDA           ;* BE LEFT PADDED WITH ASTERISKS 
E04D  C102                      CMPB #2            ;* CHECK TO SEE IF THE $$ ARE THE LAST TWO 
E04F  2511                      BLO  L8F20         ;* CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO 
E051  A601                      LDA  $01,X         ;GET THE NEXT CHARACTER AFTER ** 
E053  8124                      CMPA #'$'          ;CHECK FOR **$ 
E055  260B                      BNE  L8F20         ;CHECK FOR MORE CHARACTERS 
E057  5A                        DECB               ;DECREMENT STRING LENGTH COUNTER 
E058  3001                      LEAX $01,X         ;MOVE FORMAT STRING POINTER UP ONE 
E05A  0C99                      INC  VD9           ;ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND 
                      *              FLOATING DOLLAR SIGN COMBINATION  
E05C  969A            L8F1A     LDA  VDA           ;* GET THE STATUS BYTE AND SET 
E05E  8A10                      ORA  #$10          ;* BIT 4 TO INDICATE A 
E060  979A                      STA  VDA           ;* FLOATING DOLLAR SIGN 
E062  3001            L8F20     LEAX $01,X         ;MOVE FORMAT STRING POINTER UP ONE 
E064  0C99                      INC  VD9           ;ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD) 
                      * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING                      
E066  0F98            L8F24     CLR  VD8           ;CLEAR THE RIGHT DIGIT COUNTER 
E068  0C99            L8F26     INC  VD9           ;ADD ONE TO LEFT DIGIT COUNTER 
E06A  5A                        DECB               ;DECREMENT FORMAT STRING LENGTH COUNTER 
E06B  2749                      BEQ  L8F74         ;BRANCH IF END OF FORMAT STRING 
E06D  A680                      LDA  ,X+           ;GET THE NEXT FORMAT CHARACTER 
E06F  812E                      CMPA #'.'          ;DECIMAL POINT? 
E071  271E                      BEQ  L8F4F         ;YES 
E073  8123                      CMPA #'#'          ;NUMBER SIGN? 
E075  27F1                      BEQ  L8F26         ;YES 
E077  812C                      CMPA #','          ;COMMA? 
E079  2621                      BNE  L8F5A         ;NO 
E07B  969A                      LDA  VDA           ;* GET THE STATUS BYTE 
E07D  8A40                      ORA  #$40          ;* AND SET BIT 6 WHICH IS THE 
E07F  979A                      STA  VDA           ;* COMMA SEPARATOR FLAG 
E081  20E5                      BRA  L8F26         ;PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT 
                      * PROCESS DECIMAL POINT IF NO;DIGITS TO LEFT OF IT                      
E083  A684            L8F41     LDA  ,X            ;GET NEXT FORMAT CHARACTER 
E085  8123                      CMPA #'#'          ;IS IT A NUMBER SIGN? 
E087  1026FF3F                  LBNE L8E88         ;NO 
E08B  8601                      LDA  #1            ;* SET THE RIGHT DIGIT COUNTER TO 1 - 
E08D  9798                      STA  VD8           ;* ALLOW ONE SPOT FOR DECIMAL POINT 
E08F  3001                      LEAX $01,X         ;MOVE FORMAT POINTER UP ONE 
                      * PROCESS DIGITS TO RIGHT OF DECIMAL POINT                      
E091  0C98            L8F4F     INC  VD8           ;ADD ONE TO RIGHT DIGIT COUNTER 
E093  5A                        DECB               ;DECREMENT FORMAT LENGTH COUNTER 
E094  2720                      BEQ  L8F74         ;BRANCH IF END OF FORMAT STRING 
E096  A680                      LDA  ,X+           ;GET A CHARACTER FROM FORMAT STRING 
E098  8123                      CMPA #'#'          ;IS IT NUMBER SIGN? 
E09A  27F5                      BEQ  L8F4F         ;YES - KEEP CHECKING 
                      * CHECK FOR EXPONENTIAL FORCE                      
E09C  815E            L8F5A     CMPA #$5E          ;CHECK FOR UP ARROW 
E09E  2616                      BNE  L8F74         ;NO UP ARROW 
E0A0  A184                      CMPA ,X            ;IS THE NEXT CHARACTER AN UP ARROW? 
E0A2  2612                      BNE  L8F74         ;NO 
E0A4  A101                      CMPA $01,X         ;AND THE NEXT CHARACTER? 
E0A6  260E                      BNE  L8F74         ;NO 
E0A8  A102                      CMPA $02,X         ;HOW ABOUT THE 4TH CHARACTER? 
E0AA  260A                      BNE  L8F74         ;NO, ALSO 
E0AC  C104                      CMPB #4            ;* CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE 
E0AE  2506                      BLO  L8F74         ;* FORMAT STRING AND BRANCH IF NOT 
E0B0  C004                      SUBB #4            ;* MOVE POINTER UP 4 AND SUBTRACT 
E0B2  3004                      LEAX $04,X         ;* FOUR FROM LENGTH 
E0B4  0C9A                      INC  VDA           ;INCREMENT STATUS BYTE - EXPONENTIAL FORM  
                                                     
                      * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING                      
E0B6  301F            L8F74     LEAX -1,X        ;MOVE POINTER BACK ONE 
E0B8  0C99                      INC  VD9           ;ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE 
E0BA  969A                      LDA  VDA           ;* PRE-SIGN 
E0BC  8508                      BITA #$08          ;* FORCE AND 
E0BE  2618                      BNE  L8F96         ;* BRANCH IF SET 
E0C0  0A99                      DEC  VD9           ;DECREMENT LEFT DIGIT ' NO PRE-SIGN FORCE
E0C2  5D                        TSTB               ;* CHECK LENGTH;COUNTER AND BRANCH  
E0C3  2713                      BEQ  L8F96         ;* IF END OF FORMAT STRING 
E0C5  A684                      LDA  ,X            ;GET NEXT FORMAT STRING CHARACTER 
E0C7  802D                      SUBA #'-'          ;CHECK FOR MINUS SIGN 
E0C9  2706                      BEQ  L8F8F         ;BRANCH IF MINUS SIGN 
E0CB  81FE                      CMPA #$FE          ;* WAS CMPA #('+')-('-') 
E0CD  2609                      BNE  L8F96         ;BRANCH IF NO PLUS SIGN 
E0CF  8608                      LDA  #$08          ;GET THE PRE-SIGN FORCE FLAG 
E0D1  8A04            L8F8F     ORA  #$04          ;'OR' IN POST-SIGN FORCE FLAG
E0D3  9A9A                      ORA  VDA           ;'OR' IN THE STATUS BYTE
E0D5  979A                      STA  VDA           ;SAVE THE STATUS BYTE 
E0D7  5A                        DECB               ;DECREMENT FORMAT STRING LENGTH 
                                                     
                      * EVALUATE NUMERIC ITEM-LIST                      
E0D8  9D82            L8F96     JSR  GETCCH        ;GET CURRENT CHARACTER 
E0DA  1027FF3C                  LBEQ L8ED8         ;BRANCH IF END OF LINE 
E0DE  D793                      STB  VD3           ;SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED 
E0E0  BDC8CD                    JSR  LB141         ;EVALUATE EXPRESSION 
E0E3  9699                      LDA  VD9           ;GET THE LEFT DIGIT COUNTER 
E0E5  9B98                      ADDA VD8           ;ADD IT TO THE RIGHT DIGIT COUNTER 
E0E7  8111                      CMPA #17           ;* 
E0E9  1022EAE4                  LBHI LB44A         ;*'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
E0ED  BDE127                    JSR  L8FE5         ;CONVERT ITEM-LIST TO FORMATTED ASCII STRING 
E0F0  301F                      LEAX -1,X        ;MOVE BUFFER POINTER BACK ONE 
E0F2  BDD0E8                    JSR  LB99C         ;DISPLAY THE FORMATTED STRING TO CONSOLE OUT 
E0F5  0F97            L8FB3     CLR  VD7           ;RESET NEXT PRINT ITEM FLAG 
E0F7  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
E0F9  270D                      BEQ  L8FC6         ;BRANCH IF END OF LINE 
E0FB  9797                      STA  VD7           ;SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG 
E0FD  813B                      CMPA #';'          ;* CHECK FOR ; - ITEM-LIST SEPARATOR AND 
E0FF  2705                      BEQ  L8FC4         ;* BRANCH IF SEMICOLON 
E101  BDC9F9                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
E104  2002                      BRA  L8FC6         ;PROCESS NEXT PRINT ITEM 
E106  9D7C            L8FC4     JSR  GETNCH        ;GET NEXT INPUT CHARACTER 
E108  9E95            L8FC6     LDX  VD5           ;GET FORMAT STRING DESCRIPTOR ADDRESS 
E10A  E684                      LDB  ,X            ;GET LENGTH OF FORMAT STRING 
E10C  D093                      SUBB VD3           ;SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM 
E10E  AE02                      LDX  $02,X         ;*GET FORMAT STRING START ADDRESS AND ADVANCE 
E110  3A                        ABX                ;*POINTER TO START OF UNUSED FORMAT STRING  
E111  D693                      LDB  VD3           ;* GET AMOUNT OF UNUSED FORMAT STRING 
E113  1026FEE4                  LBNE L8EB9         ;* REINTERPRET FORMAT STRING FROM THAT POINT 
E117  7EE014                    JMP  L8ED2         ;REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY 
                      *         USED ON LAST PRINT ITEM  
                                                     
                      * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
E11A  3402            L8FD8     PSHS A             ;RESTORE ACCA AND RETURN 
E11C  862B                      LDA  #'+'          ;GET ASCII PLUS SIGN 
E11E  0D9A                      TST  VDA           ;* CHECK THE STATUS BYTE AND 
E120  2703                      BEQ  L8FE3         ;* RETURN IF = 0 
E122  BDC017                    JSR  PUTCHR        ;SEND A CHARACTER TO CONSOLE OUT 
E125  3582            L8FE3     PULS A,PC          ;RETURN ACCA AND RETURN 
                                                     
                      * CONVERT ITEM-LIST TO DECIMAL ASCII STRING                      
E127  CE01F2          L8FE5     LDU  #STRBUF+4     ;POINT U TO STRING BUFFER 
E12A  C620                      LDB  #SPACE        ;BLANK 
E12C  969A                      LDA  VDA           ;* GET THE STATUS FLAG AND 
E12E  8508                      BITA #$08          ;* CHECK FOR A PRE-SIGN FORCE 
E130  2702                      BEQ  L8FF2         ;* BRANCH IF NO PRE-SIGN FORCE 
E132  C62B                      LDB  #'+'          ;PLUS SIGN 
E134  0D54            L8FF2     TST  FP0SGN        ;CHECK THE SIGN OF FPA0 
E136  2A04                      BPL  L8FFA         ;BRANCH IF POSITIVE 
E138  0F54                      CLR  FP0SGN        ;FORCE FPA0 SIGN TO BE POSITIVE 
E13A  C62D                      LDB  #'-'          ;MINUS SIGN 
E13C  E7C0            L8FFA     STB  ,U+           ;SAVE THE SIGN IN BUFFER 
E13E  C630                      LDB  #'0'          ;* PUT A ZERO INTO THE BUFFER 
E140  E7C0                      STB  ,U+           ;* 
E142  8401                      ANDA #$01          ;* CHECK THE EXPONENTIAL FORCE FLAG IN 
E144  10260107                  LBNE L910D         ;* THE STATUS BYTE - BRANCH IF ACTIVE 
E148  8ED50C                    LDX  #LBDC0        ;POINT X TO FLOATING POINT 1E + 09 
E14B  BDD3EC                    JSR  LBCA0         ;COMPARE FPA0 TO (X) 
E14E  2B15                      BMI  L9023         ;BRANCH IF FPA0 < 1E+09 
E150  BDD525                    JSR  LBDD9         ;CONVERT FP NUMBER TO ASCII STRING 
E153  A680            L9011     LDA  ,X+           ;* ADVANCE POINTER TO END OF 
E155  26FC                      BNE  L9011         ;* ASCII STRING (ZERO BYTE) 
E157  A682            L9015     LDA  ,-X           ;MOVE THE 
E159  A701                      STA  $01,X         ;ENTIRE STRING 
E15B  8C01F1                    CMPX #STRBUF+3     ;UP ONE 
E15E  26F7                      BNE  L9015         ;BYTE 
E160  8625                      LDA  #'%'          ;* INSERT A % SIGN AT START OF 
E162  A784                      STA  ,X            ;* STRING - OVERFLOW ERROR 
E164  39                        RTS                  
                                                     
E165  964F            L9023     LDA  FP0EXP        ;GET EXPONENT OF FPA0 
E167  9747                      STA  V47           ;AND SAVE IT IN V74 
E169  2703                      BEQ  L902C         ;BRANCH IF FPA0 = 0 
E16B  BDE30F                    JSR  L91CD         ;CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT 
                      *              PLACES TO LEFT;OF DECIMAL POINT  
E16E  9647            L902C     LDA  V47           ;GET BASE 10 EXPONENT OFFSET 
E170  102B0081                  LBMI L90B3         ;BRANCH IF FPA0 < 100,000,000 
E174  40                        NEGA               ;* CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT - 
E175  9B99                      ADDA VD9           ;* SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS 
E177  8009                      SUBA #$09          ;* 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER 
E179  BDE22C                    JSR  L90EA         ;PUT ACCA ZEROES IN STRING BUFFER 
E17C  BDE3A5                    JSR  L9263         ;INITIALIZE DECIMAL POINT AND COMMA COUNTERS 
E17F  BDE344                    JSR  L9202         ;CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER 
E182  9647                      LDA  V47           ;* GET BASE 10 EXPONENT AND PUT THAT MANY 
E184  BDE3C3                    JSR  L9281         ;* ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT 
E187  9647                      LDA  V47           ;WASTED INSTRUCTION - SERVES NO PURPOSE 
E189  BDE38B                    JSR  L9249         ;CHECK FOR DECIMAL POINT 
E18C  9698                      LDA  VD8           ;GET THE RIGHT DIGIT COUNTER 
E18E  2602                      BNE  L9050         ;BRANCH IF RIGHT DIGlT COUNTER <> 0 
E190  335F                      LEAU -1,U          ;MOVE BUFFER POINTER BACK ONE - DELETE 
                      *                            ;DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED  
E192  4A              L9050     DECA               ;SUBTRACT ONE (DECIMAL POINT) 
E193  BDE22C                    JSR  L90EA         ;PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES) 
E196  BDE2C7          L9054     JSR  L9185         ;INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN 
E199  4D                        TSTA               ;WAS THERE A POST-SIGN? 
E19A  2706                      BEQ  L9060         ;NO 
E19C  C12A                      CMPB #'*'          ;IS THE FIRST CHARACTER AN $? 
E19E  2702                      BEQ  L9060         ;YES 
E1A0  E7C0                      STB  ,U+           ;STORE THE POST-SIGN 
E1A2  6FC4            L9060     CLR  ,U            ;CLEAR THE LAST CHARACTER IN THE BUFFER 
                      *                              
                      * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE                      
                      * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT                      
E1A4  8E01F1                    LDX  #STRBUF+3     ;POINT X TO THE START OF THE BUFFER  
E1A7  3001            L9065     LEAX $01,X         ;MOVE BUFFER POINTER UP ONE 
E1A9  9F0F                      STX  TEMPTR        ;SAVE BUFFER POINTER IN TEMPTR 
E1AB  963A                      LDA  VARPTR+1      ;* GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT 
E1AD  9010                      SUBA TEMPTR+1      ;* CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER - 
E1AF  9099                      SUBA VD9           ;* THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING 
                      *              * TO THE FIRST;DIGIT OF THE FORMAT STRING  
E1B1  2738                      BEQ  L90A9         ;RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT 
E1B3  A684                      LDA  ,X            ;GET THE CURRENT BUFFER CHARACTER 
E1B5  8120                      CMPA #SPACE        ;SPACE? 
E1B7  27EE                      BEQ  L9065         ;YES - ADVANCE POINTER 
E1B9  812A                      CMPA #'*'          ;ASTERISK? 
E1BB  27EA                      BEQ  L9065         ;YES - ADVANCE POINTER 
E1BD  4F                        CLRA               ;A ZERO ON THE STACK IS END OF DATA POINTER 
E1BE  3402            L907C     PSHS A             ;PUSH A CHARACTER ONTO THE STACK 
E1C0  A680                      LDA  ,X+           ;GET NEXT CHARACTER FROM BUFFER 
E1C2  812D                      CMPA #'-'          ;MINUS SIGN? 
E1C4  27F8                      BEQ  L907C         ;YES 
E1C6  812B                      CMPA #'+'          ;PLUS SIGN? 
E1C8  27F4                      BEQ  L907C         ;YES 
E1CA  8124                      CMPA #'$'          ;DOLLAR SIGN? 
E1CC  27F0                      BEQ  L907C         ;YES 
E1CE  8130                      CMPA #'0'          ;ZERO? 
E1D0  260E                      BNE  L909E         ;NO - ERROR 
E1D2  A601                      LDA  $01,X         ;GET CHARACTER FOLLOWING ZERO 
E1D4  8D16                      BSR  L90AA         ;CLEAR CARRY IF NUMERIC 
E1D6  2508                      BLO  L909E         ;BRANCH IF NOT A NUMERIC CHARACTER - ERROR 
E1D8  3502            L9096     PULS A             ;* PULL A CHARACTER OFF OF THE STACK 
E1DA  A782                      STA  ,-X           ;* AND PUT IT BACK IN THE STRING BUFFER 
E1DC  26FA                      BNE  L9096         ;* KEEP GOING UNTIL ZERO FLAG 
E1DE  20C7                      BRA  L9065         ;KEEP CLEANING UP THE INPUT BUFFER 
E1E0  3502            L909E     PULS A               
E1E2  4D                        TSTA               ;* THE STACK AND EXIT WHEN 
E1E3  26FB                      BNE  L909E         ;* ZERO FLAG FOUND 
E1E5  9E0F                      LDX  TEMPTR        ;GET THE STRING BUFFER START POINTER 
E1E7  8625                      LDA  #'%'          ;* PUT A % SIGN BEFORE THE ERROR POSITION TO 
E1E9  A782                      STA  ,-X           ;* INDICATE AN ERROR 
E1EB  39              L90A9     RTS                  
                      *                              
                      * CLEAR CARRY IF NUMERIC                      
E1EC  8130            L90AA     CMPA #'0'          ;ASCII ZERO 
E1EE  2504                      BLO  L90B2         ;RETURN IF ACCA < ASCII 0 
E1F0  803A                      SUBA #$3A          ;*  #'9'+1 
E1F2  80C6                      SUBA #$C6          ;* #-('9'+1)  CARRY CLEAR IF NUMERIC 
E1F4  39              L90B2     RTS                  
                      *                              
                      * PROCESS AN ITEM-LIST WHICH IS < 100,000,000                      
E1F5  9698            L90B3     LDA  VD8           ;GET RIGHT DIGIT COUNTER 
E1F7  2701                      BEQ  L90B8         ;BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT 
E1F9  4A                        DECA               ;SUBTRACT ONE FOR DECIMAL POINT 
E1FA  9B47            L90B8     ADDA V47           ;*ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE 
                      *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED  
                      *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT  
E1FC  2B01                      BMI  L90BD         ;IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED 
E1FE  4F                        CLRA               ;FORCE SHIFT COUNTER = 0 
E1FF  3402            L90BD     PSHS A             ;SAVE INITIAL SHIFT COUNTER ON THE STACK 
E201  2A0A            L90BF     BPL  L90CB         ;EXIT ROUTINE IF POSITIVE 
E203  3402                      PSHS A             ;SAVE SHIFT COUNTER ON STACK 
E205  BDD2CE                    JSR  LBB82         ;DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT 
E208  3502                      PULS A             ;GET SHIFT COUNTER FROM THE STACK 
E20A  4C                        INCA               ;BUMP SHIFT COUNTER UP BY ONE 
E20B  20F4                      BRA  L90BF         ;CHECK FOR FURTHER DIVISION 
E20D  9647            L90CB     LDA  V47           ;* GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER 
E20F  A0E0                      SUBA ,S+           ;* AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE 
E211  9747                      STA  V47           ;* FPA0 WAS SHIFTED ABOVE 
E213  8B09                      ADDA #$09          ;* ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO 
E215  2B19                      BMI  L90EE         ;* ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM 
E217  9699                      LDA  VD9           ;*DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL 
E219  8009                      SUBA #$09          ;*POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL 
E21B  9047                      SUBA V47           ;*POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9 
E21D  8D0D                      BSR  L90EA         ;*(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER 
E21F  BDE3A5                    JSR  L9263         ;INITIALIZE DECIMAL POINT AND COMMA COUNTERS 
E222  201D                      BRA  L90FF         ;PROCESS THE REMAINDER OF THE PRINT ITEM 
                      *                              
                      * PUT (ACCA+1) ASCII ZEROES IN BUFFER                      
E224  3402            L90E2     PSHS A             ;SAVE ZERO COUNTER 
E226  8630                      LDA  #'0'          ;* INSERT A ZERO INTO 
E228  A7C0                      STA  ,U+           ;* THE BUFFER 
E22A  3502                      PULS A             ;RESTORE ZERO COUNTER 
                                                     
                      * PUT ACCA ASCII ZEROES INTO THE BUFFER                      
E22C  4A              L90EA     DECA               ;DECREMENT ZERO COUNTER 
E22D  2AF5                      BPL  L90E2         ;BRANCH IF NOT DONE 
E22F  39                        RTS                  
                                                     
E230  9699            L90EE     LDA  VD9           ;* GET THE LEFT DIGIT COUNTER AND PUT 
E232  8DF8                      BSR  L90EA         ;* THAT MANY ZEROES IN THE STRiNG BUFFER 
E234  BDE38F                    JSR  L924D         ;PUT THE DECIMAL POINT IN THE STRING BUFFER 
E237  86F7                      LDA  #-9           ;*DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT 
E239  9047                      SUBA V47           ;*AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9 
E23B  8DEF                      BSR  L90EA         ;*(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER 
E23D  0F45                      CLR  V45           ;CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT 
E23F  0F97                      CLR  VD7           ;CLEAR THE COMMA COUNTER - SUPPRESS COMMAS 
E241  BDE344          L90FF     JSR  L9202         ;DECODE FPA0 INTO A DECIMAL ASCII STRING 
E244  9698                      LDA  VD8           ;GET THE RIGHT DIGIT COUNTER 
E246  2602                      BNE  L9108         ;BRANCH IF RIGHT DIGIT COUNTER <> 0 
E248  DE39                      LDU  VARPTR        ;RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT 
E24A  9B47            L9108     ADDA V47           ;*ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY 
                      * *FILLER ZEROES TO BE OUTPUT;TO THE RIGHT OF LAST SIGNIFICANT DATA                      
                      *         *SIGNIFICANT DATA            
E24C  16FF43                    LBRA L9050         ;INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC 
                      *                              
                      * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT                      
E24F  964F            L910D     LDA  FP0EXP        ;* GET EXPONENT OF FPA0 AND 
E251  3402                      PSHS A             ;* SAVE IT ON THE STACK 
E253  2703                      BEQ  L9116         ;BRANCH IF FPA0 = 0 
E255  BDE30F                    JSR  L91CD         ;*CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT 
                      *         *DIGITS TO THE LEFT;OF THE DECIMAL POINT  
E258  9698            L9116     LDA  VD8           ;GET THE RIGHT DIGIT COUNTER 
E25A  2701                      BEQ  L911B         ;BRANCH IF NO FORMATTED DIGITS TO THE RIGHT 
E25C  4A                        DECA               ;SUBTRACT ONE FOR THE DECIMAL POINT 
E25D  9B99            L911B     ADDA VD9           ;ADD TO THE LEFT DIGIT COUNTER 
E25F  7F01F1                    CLR  STRBUF+3      ;CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION 
E262  D69A                      LDB  VDA           ;* GET THE STATUS BYTE FOR A 
E264  C404                      ANDB #$04          ;* POST-BYTE FORCE; BRANCH IF 
E266  2603                      BNE  L9129         ;* A POST-BYTE FORCE 
E268  7301F1                    COM  STRBUF+3      ;TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE 
E26B  BB01F1          L9129     ADDA STRBUF+3      ;SUBTRACT 1 IF NO POST BYTE FORCE 
E26E  8009                      SUBA #$09          ;*SUBTRACT 9 (DUE TO THE CONVERSION TO 9 
                      *         *SIGNIFICANT DIGITS;TO LEFT OF DECIMAL POINT)  
E270  3402                      PSHS A             ;* SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER 
                      *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF  
                      *         FORMATTED PLACES TO;THE RIGHT OF THE DECIMAL POINT.  
E272  2A0A            L9130     BPL  L913C         ;NO MORE SHIFTS WHEN ACCA >= 0 
E274  3402                      PSHS A             ;SAVE SHIFT COUNTER 
E276  BDD2CE                    JSR  LBB82         ;DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE 
E279  3502                      PULS A             ;RESTORE THE SHIFT COUNTER 
E27B  4C                        INCA               ;ADD 1 TO SHIFT COUNTER 
E27C  20F4                      BRA  L9130         ;CHECK FOR FURTHER SHIFTING (DIVISION) 
E27E  A6E4            L913C     LDA  ,S            ;*GET THE INITIAL VALUE OF THE SHIFT COUNTER 
E280  2B01                      BMI  L9141         ;*AND BRANCH IF SHIFTING HAS TAKEN PLACE 
E282  4F                        CLRA               ;RESET ACCA IF NO SHIFTING HAS TAKEN PLACE 
E283  40              L9141     NEGA               ;*CALCULATE THE POSITION OF THE DECIMAL POINT BY 
E284  9B99                      ADDA VD9           ;*NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER 
E286  4C                        INCA               ;*PLUS ONE AND THE POST-BYTE POSlTION, IF USED 
E287  BB01F1                    ADDA STRBUF+3      ;* 
E28A  9745                      STA  V45           ;SAVE DECIMAL POINT COUNTER 
E28C  0F97                      CLR  VD7           ;CLEAR COMMA COUNTER - NO COMMAS INSERTED 
E28E  BDE344                    JSR  L9202         ;CONVERT FPA0 INTO ASCII DECIMAL STRING 
E291  3502                      PULS A             ;* GET THE INITIAL VALUE OF SHIFT COUNTER AND 
E293  BDE3C3                    JSR  L9281         ;* INSERT THAT MANY ZEROES INTO THE BUFFER 
E296  9698                      LDA  VD8           ;*GET THE RIGHT DIGIT COUNTER AND BRANCH 
E298  2602                      BNE  L915A         ;*IF NOT ZERO 
E29A  335F                      LEAU -1,U        ;MOVE BUFFER POINTER BACK ONE 
                                                     
                      * CALCULATE VALUE OF EXPONENT;AND PUT IN STRING BUFFER                      
E29C  E6E0            L915A     LDB  ,S+           ;GET ORIGINAL EXPONENT OF FPA0 
E29E  2709                      BEQ  L9167         ;BRANCH IF EXPONENT = 0 
E2A0  D647                      LDB  V47           ;GET BASE 10 EXPONENT 
E2A2  CB09                      ADDB #$09          ;ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION 
E2A4  D099                      SUBB VD9           ;SUBTRACT LEFT DIGIT COUNTER 
E2A6  F001F1                    SUBB STRBUF+3      ;ADD ONE TO EXPONENT IF POST-SIGN FORCE 
E2A9  862B            L9167     LDA  #'+'          ;PLUS SIGN 
E2AB  5D                        TSTB               ;TEST EXPONENT   
E2AC  2A03                      BPL  L916F         ;BRANCH IF POSITIVE EXPONENT 
E2AE  862D                      LDA  #'-'          ;MINUS SIGN 
E2B0  50                        NEGB               ;CONVERT EXPONENT TO POSITIVE NUMBER 
E2B1  A741            L916F     STA  $01,U         ;PUT SIGN OF EXPONENT IN STRING BUFFER 
E2B3  8645                      LDA  #'E'          ;* PUT AN 'E' (EXPONENTIATION FLAG) IN
E2B5  A7C1                      STA  ,U++          ;* BUFFER AND SKIP OVER THE SIGN 
E2B7  862F                      LDA  #$2F          ;* WAS LDA #'0'-1 
                      *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA                      
E2B9  4C              L9177     INCA               ;ADD ONE TO TENS DIGIT COUNTER 
E2BA  C00A                      SUBB #10           ;*SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS 
E2BC  24FB                      BCC  L9177         ;* DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY 
E2BE  CB3A                      ADDB #$3A          ;WAS ADDB #'9'+1 
E2C0  EDC1                      STD  ,U++          ;SAVE EXPONENT IN BUFFER 
E2C2  6FC4                      CLR  ,U            ;CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR 
E2C4  7EE196                    JMP  L9054         ;INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC. 
                                                     
                      * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN                      
E2C7  8E01F2          L9185     LDX  #STRBUF+4     ;POINT X TO START OF PRINT ITEM BUFFER 
E2CA  E684                      LDB  ,X            ;* GET SIGN BYTE OF ITEM-LIST BUFFER 
E2CC  3404                      PSHS B             ;* AND SAVE IT ON THE STACK 
E2CE  8620                      LDA  #SPACE        ;DEFAULT PAD WITH BLANKS 
E2D0  D69A                      LDB  VDA           ;* GET STATUS BYTE AND CHECK FOR 
E2D2  C520                      BITB #$20          ;* ASTERISK LEFT PADDING 
E2D4  3504                      PULS B             ;GET SIGN BYTE AGAIN 
E2D6  2708                      BEQ  L919E         ;BRANCH IF NO PADDING 
E2D8  862A                      LDA  #'*'          ;PAD WITH ASTERISK 
E2DA  C120                      CMPB #SPACE        ;WAS THE FIRST BYTE A BLANK (POSITIVE)? 
E2DC  2602                      BNE  L919E         ;NO 
E2DE  1F89                      TFR  A,B           ;TRANSFER PAD CHARACTER TO ACCB 
E2E0  3404            L919E     PSHS B             ;SAVE FIRST CHARACTER ON STACK 
E2E2  A780            L91A0     STA  ,X+           ;STORE PAD CHARACTER IN BUFFER 
E2E4  E684                      LDB  ,X            ;GET NEXT CHARACTER IN BUFFER 
E2E6  2710                      BEQ  L91B6         ;INSERT A ZERO IF END OF BUFFER 
E2E8  C145                      CMPB #'E'          ;* CHECK FOR AN 'E' AND
E2EA  270C                      BEQ  L91B6         ;* PUT A ZERO BEFORE IT 
E2EC  C130                      CMPB #'0'          ;* REPLACE LEADING ZEROES WITH 
E2EE  27F2                      BEQ  L91A0         ;* PAD CHARACTERS 
E2F0  C12C                      CMPB #','          ;* REPLACE LEADING COMMAS 
E2F2  27EE                      BEQ  L91A0         ;* WITH PAD CHARACTERS 
E2F4  C12E                      CMPB #'.'          ;* CHECK FOR DECIMAL POINT 
E2F6  2604                      BNE  L91BA         ;* AND DON'T PUT A ZERO BEFORE IT
E2F8  8630            L91B6     LDA  #'0'          ;* REPLACE PREVIOUS CHARACTER 
E2FA  A782                      STA  ,-X           ;* WITH A ZERO 
E2FC  969A            L91BA     LDA  VDA           ;* GET STATUS BYTE, CHECK 
E2FE  8510                      BITA #$10          ;* FOR FLOATING $ 
E300  2704                      BEQ  L91C4         ;* BRANCH IF NO FLOATING $ 
E302  C624                      LDB  #'$'          ;* STORE A $ IN 
E304  E782                      STB  ,-X           ;* BUFFER 
E306  8404            L91C4     ANDA #$04          ;CHECK PRE-SIGN FLAG 
E308  3504                      PULS B             ;GET SIGN CHARACTER 
E30A  2602                      BNE  L91CC         ;RETURN IF POST-SIGN REQUIRED 
E30C  E782                      STB  ,-X           ;STORE FIRST CHARACTER 
E30E  39              L91CC     RTS                  
                      *                              
                      * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.                      
                      * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).                      
E30F  3440            L91CD     PSHS U             ;SAVE BUFFER POINTER 
E311  4F                        CLRA               ;INITIAL EXPONENT OFFSET = 0 
E312  9747            L91D0     STA  V47           ;SAVE EXPONENT OFFSET 
E314  D64F                      LDB  FP0EXP        ;GET EXPONENT OF FPA0 
E316  C180                      CMPB #$80          ;* COMPARE TO EXPONENT OF .5 
E318  2211                      BHI  L91E9         ;* AND BRANCH IF FPA0 > = 1.0 
                                                     
                      * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1                      
E31A  8ED50C                    LDX  #LBDC0        ;POINT X TO FP NUMBER (1E+09) 
E31D  BDD216                    JSR  LBACA         ;MULTIPLY FPA0 BY 1E+09 
E320  9647                      LDA  V47           ;GET EXPONENT OFFSET 
E322  8009                      SUBA #$09          ;SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE) 
E324  20EC                      BRA  L91D0         ;CHECK TO SEE IF > 1.0 
E326  BDD2CE          L91E4     JSR  LBB82         ;DIVIDE FPA0 BY 10 
E329  0C47                      INC  V47           ;INCREMENT EXPONENT OFFSET 
E32B  8ED507          L91E9     LDX  #LBDBB        ;POINT X TO FP NUMBER (999,999,999) 
E32E  BDD3EC                    JSR  LBCA0         ;COMPARE FPA0 TO X 
E331  2EF3                      BGT  L91E4         ;BRANCH IF FPA0 > 999,999,999 
E333  8ED502          L91F1     LDX  #LBDB6        ;POINT X TO FP NUMBER (99,999,999.9) 
E336  BDD3EC                    JSR  LBCA0         ;COMPARE FPA0 TO X 
E339  2E07                      BGT  L9200         ;RETURN IF 999,999,999 > FPA0 > 99,999,999.9 
E33B  BDD2B6                    JSR  LBB6A         ;MULTIPLY FPA0 BY 10 
E33E  0A47                      DEC  V47           ;DECREMENT EXPONENT OFFSET 
E340  20F1                      BRA  L91F1         ;KEEP UNNORMALIZING 
E342  35C0            L9200     PULS U,PC          ;RESTORE BUFFER POINTER AND RETURN 
                      *                              
                      * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT                      
                      * INTO A DECIMAL ASCII STRING;IN THE BUFFER                      
E344  3440            L9202     PSHS U             ;SAVE BUFFER POINTER 
E346  BDD100                    JSR  LB9B4         ;ADD .5 TO FPA0 (ROUND OFF) 
E349  BDD414                    JSR  LBCC8         ;CONVERT FPA0 TO INTEGER FORMAT 
E34C  3540                      PULS U             ;RESTORE BUFFER POINTER 
                      *                              
                      * CONVERT FPA0 INTO A DECIMAL;ASCII STRING                      
E34E  8ED611                    LDX  #LBEC5        ;POINT X TO UNNORMALIZED POWERS OF 10 
E351  C680                      LDB  #$80          ;INITIALIZE DIGIT COUNTER TO 0 + $80. 
                      * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA                      
                      * IS NEGATIVE. WHEN YOU 'ADD';A NEGATIVE MANTISSA, IT IS
                      * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB                      
                      * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
E353  8D36            L9211     BSR  L9249         ;CHECK FOR COMMA INSERTION 
E355  9653            L9213     LDA  FPA0+3        ;* 'ADD' A POWER OF 10 MANTISSA TO FPA0.
E357  AB03                      ADDA $03,X         ;* IF THE MANTISSA IS NEGATIVE, A SUBTRACTION 
E359  9753                      STA  FPA0+3        ;* WILL BE WHAT REALLY TAKES PLACE. 
E35B  9652                      LDA  FPA0+2        ;* 
E35D  A902                      ADCA $02,X         ;* 
E35F  9752                      STA  FPA0+2        ;* 
E361  9651                      LDA  FPA0+1        ;* 
E363  A901                      ADCA $01,X         ;* 
E365  9751                      STA  FPA0+1        ;* 
E367  9650                      LDA  FPA0          ;* 
E369  A984                      ADCA ,X            ;* 
E36B  9750                      STA  FPA0          ;* 
E36D  5C                        INCB               ;ADD ONE TO DIGIT COUNTER 
E36E  56                        RORB               ;ROTATE CARRY INTO BIT 7  
E36F  59                        ROLB               ;* SET OVERFLOW FLAG - BRANCH IF CARRY SET AND 
E370  28E3                      BVC  L9213         ;* ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA 
E372  2403                      BCC  L9235         ;BRANCH IF SUBTRACTING MANTISSA 
E374  C00B                      SUBB #10+1         ;WAS SUBB #10+1 
E376  50                        NEGB               ;* IF ADDING MANTISSA 
E377  CB2F            L9235     ADDB #$2F          ;WAS ADDB #'0'-1 
E379  3004                      LEAX $04,X         ;MOVE TO NEXT POWER OF 10 MANTISSA 
E37B  1F98                      TFR  B,A           ;SAVE DIGIT IN ACCA 
E37D  847F                      ANDA #$7F          ;MASK OFF ADD/SUBTRACT FLAG (BIT 7) 
E37F  A7C0                      STA  ,U+           ;STORE DIGIT IN BUFFER 
E381  53                        COMB               ;TOGGLE ADD/SUBTRACT FLAG 
E382  C480                      ANDB #$80          ;MASK OFF EVERYTHING BUT ADD/SUB FLAG 
E384  8CD635                    CMPX #LBEE9        ;COMPARE TO END OF UNNORMALIZED POWERS OF 10 
E387  26CA                      BNE  L9211         ;BRANCH IF NOT DONE 
E389  6FC4                      CLR  ,U            ;PUT A ZERO AT END OF INTEGER 
                                                     
                      * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION                      
E38B  0A45            L9249     DEC  V45           ;DECREMENT DECIMAL POINT COUNTER 
E38D  2609                      BNE  L9256         ;NOT TIME FOR DECIMAL POINT 
E38F  DF39            L924D     STU  VARPTR        ;SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT 
E391  862E                      LDA  #'.'          ;* STORE A DECIMAL 
E393  A7C0                      STA  ,U+           ;* POINT IN THE OUTPUT BUFFER 
E395  0F97                      CLR  VD7           ;* CLEAR COMMA COUNTER - NOW IT WILL TAKE 255 
                      *                            ;* DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED 
E397  39                        RTS                  
E398  0A97            L9256     DEC  VD7           ;DECREMENT COMMA COUNTER 
E39A  2608                      BNE  L9262         ;RETURN IF NOT TIME FOR COMMA 
E39C  8603                      LDA  #$03          ;* RESET COMMA COUNTER TO 3; THREE 
E39E  9797                      STA  VD7           ;* DIGITS BETWEEN COMMAS 
E3A0  862C                      LDA  #','          ;* PUT A COMMA INTO 
E3A2  A7C0                      STA  ,U+           ;* THE BUFFER 
E3A4  39              L9262     RTS                  
                                                     
                      * INITIALIZE DECIMAL POINT AND COMMA COUNTERS                      
E3A5  9647            L9263     LDA  V47           ;GET THE BASE 10 EXPONENT OFFSET 
E3A7  8B0A                      ADDA #10           ;* ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
E3A9  9745                      STA  V45           ;* OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER 
E3AB  4C                        INCA               ;ADD ONE FOR THE DECIMAL POINT 
E3AC  8003            L926A     SUBA #$03          ;* DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE 
E3AE  24FC                      BCC  L926A         ;* THE REMAINDER IN ACCA 
E3B0  8B05                      ADDA #$05          ;CONVERT REMAINDER INTO A NUMBER FROM 1-3 
E3B2  9797                      STA  VD7           ;SAVE COMMA COUNTER 
E3B4  969A                      LDA  VDA           ;GET STATUS BYTE 
E3B6  8440                      ANDA #$40          ;CHECK FOR COMMA FLAG 
E3B8  2602                      BNE  L927A         ;BRANCH IF COMMA FLAG ACTIVE 
E3BA  9797                      STA  VD7           ;CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA 
E3BC  39              L927A     RTS                  
                      *                              
                      * INSERT ACCA ZEROES INTO THE;BUFFER                      
E3BD  3402            L927B     PSHS A             ;SAVE ZEROES COUNTER 
E3BF  8DCA                      BSR  L9249         ;CHECK FOR DECIMAL POINT 
E3C1  3502                      PULS A             ;RESTORE ZEROES COUNTER 
E3C3  4A              L9281     DECA               ;* DECREMENT ZEROES COUNTER AND 
E3C4  2B0A                      BMI  L928E         ;* RETURN IF < 0 
E3C6  3402                      PSHS A             ;SAVE ZEROES COUNTER 
E3C8  8630                      LDA  #'0'          ;* PUT A ZERO INTO 
E3CA  A7C0                      STA  ,U+           ;* THE BUFFER 
E3CC  A6E0                      LDA  ,S+           ;RESTORE THE ZEROES COUNTER 
E3CE  26ED                      BNE  L927B         ;BRANCH IF NOT DONE 
E3D0  39              L928E     RTS                  
                                                     
                                                     
                      * LINE                         
E3D1  8189            LINE      CMPA #TOK_INPUT    ;'INPUT' TOKEN
E3D3  1027F95C                  LBEQ L89C0         ;GO DO 'LINE INPUT' COMMAND
E3D7  7ECA03                    JMP  LB277         ;'SYNTAX ERROR' IF NOT "LINE INPUT"
                                                     
                       IF MON09
                       ELSE
                                FILL $FF,$FFF0-*  ;FILL ROM TO RSV WITH FF's
                       ENDIF
                      
                       IF MON09
                       ELSE
                      
                      * END OF EXTENDED BASIC                      
                      * INTERRUPT VECTORS                      
                                ORG  $FFF0           
                      LBFF0     FDB  $0000         ;RESERVED 
                      LBFF2     FDB  SW3VEC        ;SWI3 
                      LBFF4     FDB  SW2VEC        ;SWI2 
                      LBFF6     FDB  FRQVEC        ;FIRQ 
                      LBFF8     FDB  IRQVEC        ;IRQ 
                      LBFFA     FDB  SWIVEC        ;SWI 
                      LBFFC     FDB  NMIVEC        ;NMI 
                      LBFFE     FDB  RESVEC        ;RESET 
                       ENDIF
