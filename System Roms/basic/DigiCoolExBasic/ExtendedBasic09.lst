                      ;       Extended Basic for 6809
                      ;       =======================
                      ; FOR HB63C09 USE, WITH 16K ROM (SPACE FOR SD IO BELOW, AND MON09 FROM JQ'S SBC ROM )
                      ;
                      ;       MODIFICATIONS FOR HB63C09M:
                      ;       ==========================
                      ;       - v1.2
                      ;       - CHANGED UART ADDRESS TO $A000 (AS IT IS BACK THERE)
                      ;       - CHANGED BIN START TO $C000 
                      ;       - ADDED SUPPORT TO THE SCRIPTING TOOLCHAIN TO USE AS LANGUAGE MODULE FOR
                      ;         JQ's MON09 IMPLIMENTATION https://6809sbc.wordpress.com/
                      ;       - NEAR AS I CAN TELL, JQ's ROM IS BUGGED WITH STRING HANDLEING HOWEVER GREGS'S
                      ;         ISN'T. THIS MAY BE DUE TO THE AGE OF THE CODE AND HOW ASM6809 HANDLES CERTAIN
                      ;         DIRECTIVES, AS WELL AS PERAMITERS.  THIS IS WHY I SWITCHED TO THIS ASSEMBLER FOR
                      ;         THIS MODULE.
                      ;       - I ADDED THE QUALITY OF LIFE UPDATES FROM THE JQ ROM BUT LEFT THE OLD RAM DETECTION
                      ;         UTILITY, AS IT WILL ENCOUNTER THE IO RANGE AND STOP ON MY BUILD, JUST LIKE ON
                      ;         GRANT SEARLE / JEFF TRANTER'S DESIGNS. ALSO WHEN COMPILED AS A MODULE IT WILL
                      ;         RESPOND TO 'BYE' TO RETURN TO THE MONITOR. (LIFTED FROM THE JQ SOURCE)
                      ;       - REMOVED ACIA INIT - THE AVR HANDLES INIT OF THE USART, THE PROTOCOL IS
                      ;         THE SAME AS THE ORIGINAL 68B50 ACIA (REGISTER LOCATION) AND MIMICS ENOUGH OF
                      ;         THE CHIP FOR THIS TO WORK.    
                      ;       - BELOW IS THE LEAD IN FROM GREG'S SOURCE (DigiCoolThings) From his repo: 
                      ;         https://github.com/DigicoolThings/MECB
                      ;       
                      ;        z80dad@gmail.com        MAR, 2024
                      
                      ;Based on Grant Searle's published AS9 compatible Assembler source code.
                      ;       Refer: http://searle.x10host.com/6809/Simple6809.html
                      ;
                      ;       I've reformatted and modified, to enable assembly with the asm6809 Assembler.
                      ;       Including:
                      ;       - Added semi-colon end-of-line comment seperators.
                      ;       - Added braces to expressions for correct expression evaluation operator order. 
                      ;       - Added SETDP directive for correct addressing mode for Zero Page references.
                      ;
                      ;       For MECB 6809 CPU Card use, with 48K RAM, 16K ROM and I/O page at $C0xx
                      ;       - Changed UART EQUate for $C008 ACIA location.
                      ;       - Changed RTS_LOW EQUate for 8 bits + 2 Stop, RTS Low, Disable Interrupts ($11).
                      ;
                      ;       Greg@DigicoolThings.com         Oct 2023
                      ;
                      ;  
                      ;
                      
                      
0000                            SETDP $00              ; Tell asm6809 Assembler Direct Page is det for Zero Page.
                      
0001                  MON09     SET  1            ; SET TO '1' TO INCLUDE AS PART OF MON09
C000                  ROMSTART  EQU  $C000        ; START OF ROM
                      
                       IF MON09                   ; USE WITH MON09
0000                      INCLUDE "../../mon09/V37/mon09v37_API.inc"
                      ; MON09 ROM ENTRY POINTS FOR USER PROGRAMS
E44C                  MON09_CHKCHR    EQU     $E44C
E46D                  MON09_DISASS    EQU     $E46D
E476                  MON09_DISREG    EQU     $E476
E467                  MON09_DLOAD     EQU     $E467
FD59                  MON09_FIRQADR   EQU     $FD59
E446                  MON09_GETADR    EQU     $E446
E443                  MON09_GETBYT    EQU     $E443
E43A                  MON09_GETCHR    EQU     $E43A
E43D                  MON09_GETECH    EQU     $E43D
E440                  MON09_GETNIB    EQU     $E440
E449                  MON09_GETRNG    EQU     $E449
E45B                  MON09_HEXOUT    EQU     $E45B
E458                  MON09_HOUT      EQU     $E458
FD61                  MON09_ILOPADR   EQU     $FD61
FD5D                  MON09_IRQADR    EQU     $FD5D
E455                  MON09_LFCR      EQU     $E455
E46A                  MON09_LOAD      EQU     $E46A
E479                  MON09_MONITOR   EQU     $E479
E44F                  MON09_PUTCHR    EQU     $E44F
E47C                  MON09_RESET     EQU     $E47C
E452                  MON09_SPACE     EQU     $E452
E473                  MON09_STEPDI    EQU     $E473
E470                  MON09_STEP      EQU     $E470
FD51                  MON09_SWI2ADR   EQU     $FD51
FD55                  MON09_SWI3ADR   EQU     $FD55
FD4D                  MON09_SWIADR    EQU     $FD4D
E45E                  MON09_WRDOUT    EQU     $E45E
E461                  MON09_WRLIN     EQU     $E461
E464                  MON09_WRMSG     EQU     $E464
                       ENDIF
                      
A000                  UART      EQU  $A000            ; MC6850 ACIA (UART) base address (Originally $A000)
A001                  RECEV     EQU  UART+1          
A001                  TRANS     EQU  UART+1          
A000                  USTAT     EQU  UART            
A000                  UCTRL     EQU  UART            
                                                     
0008                  BS        EQU  8             ;BACKSPACE 
000D                  CR        EQU  $D            ;ENTER KEY 
001B                  ESC       EQU  $1B           ;ESCAPE CODE 
0020                  SPACE     EQU  $20           ;SPACE (BLANK) 
003A                  STKBUF    EQU  58            ;STACK BUFFER ROOM 
00FA                  LBUFMX    EQU  250           ;MAX NUMBER OF CHARS IN A BASIC LINE 
00FA                  MAXLIN    EQU  $FA           ;MAXIMUM MS BYTE OF LINE NUMBER 
                      * PSEUDO OPS                      
0021                  SKP1      EQU  $21           ;OP CODE OF BRN ' SKIP ONE BYTE
008C                  SKP2      EQU  $8C           ;OP CODE OF CMPX # - SKIP TWO BYTES 
0086                  SKP1LD    EQU  $86           ;OP CODE OF LDA # - SKIP THE NEXT BYTE 
                      *                            ;AND LOAD THE VALUE OF THAT BYTE INTO ACCA ' THIS
                      *                            ;IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE 
                      
                      
                      
0015                  RTS_LOW   EQU  $15      ; Originally $95 (8 bits + 1 Stop, RTS Low, Enabled Interrupts)
                                              ; Use $11 for 8 bits + 2 Stop, RTS Low, Disable Interrupts
                                              ; Or $15 for 8 bits + 1 Stop, RTS Low, Disable Interrupts
                      
0000                            ORG  0               
                      
0000                  ENDFLG    RMB  1             ;STOP/END FLAG: POSITIVE=STOP, NEG=END 
0001                  CHARAC    RMB  1             ;TERMINATOR FLAG 1 
0002                  ENDCHR    RMB  1             ;TERMINATOR FLAG 2 
0003                  TMPLOC    RMB  1             ;SCRATCH VARIABLE 
0004                  IFCTR     RMB  1             ;IF COUNTER - HOW MANY IF STATEMENTS IN A LINE 
0005                  DIMFLG    RMB  1             ;*DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING 
0006                  VALTYP    RMB  1             ;*DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING 
0007                  GARBFL    RMB  1             ;*TV STRING SPACE HOUSEKEEPING FLAG 
0008                  ARYDIS    RMB  1             ;DISABLE ARRAY SEARCH: 00=ALLOW SEARCH 
0009                  INPFLG    RMB  1             ;*TV INPUT FLAG: READ=0, INPUT<>0 
000A                  RELFLG    RMB  1             ;*TV RELATIONAL OPERATOR FLAG 
000B                  TEMPPT    RMB  2             ;*PV TEMPORARY STRING STACK POINTER 
000D                  LASTPT    RMB  2             ;*PV ADDR OF LAST USED STRING STACK ADDRESS 
000F                  TEMPTR    RMB  2             ;TEMPORARY POINTER 
0011                  TMPTR1    RMB  2             ;TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH) 
0013                  FPA2      RMB  4             ;FLOATING POINT ACCUMULATOR #2 MANTISSA 
0017                  BOTSTK    RMB  2             ;BOTTOM OF STACK AT LAST CHECK 
0019                  TXTTAB    RMB  2             ;*PV BEGINNING OF BASIC PROGRAM 
001B                  VARTAB    RMB  2             ;*PV START OF VARIABLES 
001D                  ARYTAB    RMB  2             ;*PV START OF ARRAYS 
001F                  ARYEND    RMB  2             ;*PV END OF ARRAYS (+1) 
0021                  FRETOP    RMB  2             ;*PV START OF STRING STORAGE (TOP OF FREE RAM) 
0023                  STRTAB    RMB  2             ;*PV START OF STRING VARIABLES 
0025                  FRESPC    RMB  2             ;UTILITY STRING POINTER 
0027                  MEMSIZ    RMB  2             ;*PV TOP OF STRING SPACE 
0029                  OLDTXT    RMB  2             ;SAVED LINE NUMBER DURING A "STOP" 
002B                  BINVAL    RMB  2             ;BINARY VALUE OF A CONVERTED LINE NUMBER 
002D                  OLDPTR    RMB  2             ;SAVED INPUT PTR DURING A "STOP" 
002F                  TINPTR    RMB  2             ;TEMPORARY INPUT POINTER STORAGE 
0031                  DATTXT    RMB  2             ;*PV 'DATA' STATEMENT LINE NUMBER POINTER 
0033                  DATPTR    RMB  2             ;*PV 'DATA' STATEMENT ADDRESS POINTER 
0035                  DATTMP    RMB  2             ;DATA POINTER FOR 'INPUT' & 'READ' 
0037                  VARNAM    RMB  2             ;*TV TEMP STORAGE FOR A VARIABLE NAME 
0039                  VARPTR    RMB  2             ;*TV POINTER TO A VARIABLE DESCRIPTOR 
003B                  VARDES    RMB  2             ;TEMP POINTER TO A VARIABLE DESCRIPTOR 
003D                  RELPTR    RMB  2             ;POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE 
003F                  TRELFL    RMB  1             ;TEMPORARY RELATIONAL OPERATOR FLAG BYTE 
                      * FLOATING POINT ACCUMULATORS;#3,4 & 5 ARE MOSTLY                      
                      * USED AS SCRATCH PAD VARIABLES.                      
                      ** FLOATING POINT ACCUMULATOR;#3 :PACKED: ($40-$44)                      
0040                  V40       RMB  1               
0041                  V41       RMB  1               
0042                  V42       RMB  1               
0043                  V43       RMB  1               
0044                  V44       RMB  1               
                      ** FLOATING POINT ACCUMULATOR;#4 :PACKED: ($45-$49)                      
0045                  V45       RMB  1               
0046                  V46       RMB  1               
0047                  V47       RMB  1               
0048                  V48       RMB  2               
                      ** FLOATING POINT ACCUMULATOR;#5 :PACKED: ($4A'$4E)
004A                  V4A       RMB  1               
004B                  V4B       RMB  2               
004D                  V4D       RMB  2               
                      ** FLOATING POINT ACCUMULATOR;#0                      
004F                  FP0EXP    RMB  1             ;*PV FLOATING POINT ACCUMULATOR #0 EXPONENT 
0050                  FPA0      RMB  4             ;*PV FLOATING POINT ACCUMULATOR #0 MANTISSA 
0054                  FP0SGN    RMB  1             ;*PV FLOATING POINT ACCUMULATOR #0 SIGN 
0055                  COEFCT    RMB  1             ;POLYNOMIAL COEFFICIENT COUNTER 
0056                  STRDES    RMB  5             ;TEMPORARY STRING DESCRIPTOR 
005B                  FPCARY    RMB  1             ;FLOATING POINT CARRY BYTE 
                      ** FLOATING POINT ACCUMULATOR;#1                      
005C                  FP1EXP    RMB  1             ;*PV FLOATING POINT ACCUMULATOR #1 EXPONENT 
005D                  FPA1      RMB  4             ;*PV FLOATING POINT ACCUMULATOR #1 MANTISSA 
0061                  FP1SGN    RMB  1             ;*PV FLOATING POINT ACCUMULATOR #1 SIGN 
0062                  RESSGN    RMB  1             ;SIGN OF RESULT OF FLOATING POINT OPERATION 
0063                  FPSBYT    RMB  1             ;FLOATING POINT SUB BYTE (FIFTH BYTE) 
0064                  COEFPT    RMB  2             ;POLYNOMIAL COEFFICIENT POINTER 
0066                  LSTTXT    RMB  2             ;CURRENT LINE POINTER DURING LIST 
0068                  CURLIN    RMB  2             ;*PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT 
006A                  DEVCFW    RMB  1             ;*TV TAB FIELD WIDTH 
006B                  DEVLCF    RMB  1             ;*TV TAB ZONE 
006C                  DEVPOS    RMB  1             ;*TV PRINT POSITION 
006D                  DEVWID    RMB  1             ;*TV PRINT WIDTH 
006E                  RSTFLG    RMB  1             ;*PV WARM START FLAG: $55=WARM, OTHER=COLD 
006F                  RSTVEC    RMB  2             ;*PV WARM START VECTOR - JUMP ADDRESS FOR WARM START 
0071                  TOPRAM    RMB  2             ;*PV TOP OF RAM 
0073                  IKEYIM    RMB  1             ;*TV INKEY$ RAM IMAGE 
0074                  ZERO      RMB  2             ;*PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO 
                      * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM                      
0076                  LPTCFW    RMB  1             ;16 
0077                  LPTLCF    RMB  1             ;112 
0078                  LPTWID    RMB  1             ;132 
0079                  LPTPOS    RMB  1             ;0 
007A                  EXECJP    RMB  2             ;LB4AA 
                                                     
                      * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM                      
                      * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE                      
                      * INTERPRETED IS STORED AT CHARAD.                      
007C  0C84            GETNCH    INC  <CHARAD+1     ;*PV INCREMENT LS BYTE OF INPUT POINTER 
007E  2602                      BNE  GETCCH        ;*PV BRANCH IF NOT ZERO (NO CARRY) 
0080  0C83                      INC  <CHARAD       ;*PV INCREMENT MS BYTE OF INPUT POINTER 
0082  B6              GETCCH    FCB  $B6           ;*PV OP CODE OF LDA EXTENDED 
0083                  CHARAD    RMB  2             ;*PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT 
                      *         *    CHARACTER WHICH THE BASIC INTERPRETER IS  
                      *         *    PROCESSING      
0085  7EC1C2                    JMP  BROMHK        ;JUMP BACK INTO THE BASIC ROM
                                                     
0088                  VAB       RMB  1             ;= LOW ORDER FOUR BYTES OF THE PRODUCT 
0089                  VAC       RMB  1             ;= OF A FLOATING POINT MULTIPLICATION 
008A                  VAD       RMB  1             ;= THESE BYTES ARE USE AS RANDOM DATA 
008B                  VAE       RMB  1             ;= BY THE RND STATEMENT 
                                                     
                      * EXTENDED BASIC VARIABLES                      
008C                  TRCFLG    RMB  1             ;*PV TRACE FLAG 0=OFF ELSE=ON 
008D                  USRADR    RMB  2             ;*PV ADDRESS OF THE START OF USR VECTORS 
                                                     
                      * EXTENDED BASIC SCRATCH PAD VARIABLES                      
008F                  VCF       RMB  2               
0091                  VD1       RMB  2               
0093                  VD3       RMB  2               
0095                  VD5       RMB  2               
0097                  VD7       RMB  1               
0098                  VD8       RMB  1               
0099                  VD9       RMB  1               
009A                  VDA       RMB  1               
009B                  SW3VEC    RMB  3               
009E                  SW2VEC    RMB  3               
00A1                  SWIVEC    RMB  3               
00A4                  NMIVEC    RMB  3               
00A7                  IRQVEC    RMB  3               
00AA                  FRQVEC    RMB  3               
00AD                  USRJMP    RMB  3             ;JUMP ADDRESS FOR BASIC'S USR FUNCTION 
00B0                  RVSEED    RMB  1             ;* FLOATING POINT RANDOM NUMBER SEED EXPONENT 
00B1                            RMB  4             ;* MANTISSA: INITIALLY SET TO $804FC75259 
                                                     
                      **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)                      
00B5                  USR0      RMB  2             ;USR 0 VECTOR 
00B7                            RMB  2             ;USR 1 
00B9                            RMB  2             ;USR 2 
00BB                            RMB  2             ;USR 3 
00BD                            RMB  2             ;USR 4 
00BF                            RMB  2             ;USR 5 
00C1                            RMB  2             ;USR 6 
00C3                            RMB  2             ;USR 7 
00C5                            RMB  2             ;USR 8 
00C7                            RMB  2             ;USR 9 
                                                     
00C9                  STRSTK    RMB  8*5           ;STRING DESCRIPTOR STACK 
00F1                  LINHDR    RMB  2             ;LINE INPUT BUFFER HEADER 
00F3                  LINBUF    RMB  LBUFMX+1      ;BASIC LINE INPUT BUFFER 
01EE                  STRBUF    RMB  41            ;STRING BUFFER 
                                                     
0217                  PROGST    RMB  1             ;START OF PROGRAM SPACE 
                      *         INTERRUPT VECTORS                 
FFF2                            ORG  $FFF2           
FFF2                  SWI3      RMB  2               
FFF4                  SWI2      RMB  2               
FFF6                  FIRQ      RMB  2               
FFF8                  IRQ       RMB  2               
FFFA                  SWI       RMB  2               
FFFC                  NMI       RMB  2               
FFFE                  RESETV    RMB  2               
                                                     
                      
C000                            ORG  ROMSTART
                       IF MON09
C000                  MON09_ENTRY
C000  7EC049                    JMP  RESVEC
                       ENDIF
                                                     
                      * CONSOLE IN                      
C003  8D03            LA171     BSR  KEYIN         ;GET A CHARACTER FROM CONSOLE IN 
C005  27FC                      BEQ  LA171         ;LOOP IF NO KEY DOWN 
C007  39                        RTS                  
                                                     
                      *                              
                      * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY                      
                      * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.                      
                      *                              
                      *                              
C008                  LA1C1                          
C008  B6A000          KEYIN     LDA  USTAT           
C00B  8501                      BITA #1              
C00D  2706                      BEQ  NOCHAR          
C00F  B6A001                    LDA  RECEV           
C012  847F                      ANDA #$7F            
C014  39                        RTS                  
C015  4F              NOCHAR    CLRA                 
C016  39                        RTS                  
                                                     
                                                     
                                                     
                      * CONSOLE OUT                      
C017  8D24            PUTCHR    BSR  WAITACIA        
C019  3402                      PSHS A               
C01B  810D                      CMPA #CR           ;IS IT CARRIAGE RETURN? 
C01D  270B                      BEQ  NEWLINE       ;YES 
C01F  B7A001                    STA  TRANS           
C022  0C79                      INC  LPTPOS        ;INCREMENT CHARACTER COUNTER 
C024  9679                      LDA  LPTPOS        ;CHECK FOR END OF LINE PRINTER LINE 
C026  9178                      CMPA LPTWID        ;AT END OF LINE PRINTER LINE? 
C028  2510                      BLO  PUTEND        ;NO 
C02A  0F79            NEWLINE   CLR  LPTPOS        ;RESET CHARACTER COUNTER 
C02C  8D0F                      BSR  WAITACIA        
C02E  860D                      LDA  #13             
C030  B7A001                    STA  TRANS           
C033  8D08                      BSR  WAITACIA        
C035  860A                      LDA  #10           ;DO LINEFEED AFTER CR 
C037  B7A001                    STA  TRANS           
C03A  3502            PUTEND    PULS A               
C03C  39                        RTS                  
                                                     
C03D  3402            WAITACIA  PSHS A               
C03F  B6A000          WRWAIT    LDA  USTAT           
C042  8502                      BITA #2              
C044  27F9                      BEQ  WRWAIT          
C046  3502                      PULS A               
C048  39                        RTS                  
                                                     
                      *                              
C049                  RESVEC                         
C049  10CE01EE        LA00E     LDS  #LINBUF+LBUFMX+1 ;SET STACK TO TOP OF LINE INPUT BUFFER 
C04D  966E                      LDA  RSTFLG        ;GET WARM START FLAG 
C04F  8155                      CMPA #$55          ;IS IT A WARM START? 
C051  260A                      BNE  BACDST        ;NO - D0 A COLD START 
C053  9E6F                      LDX  RSTVEC        ;WARM START VECTOR 
C055  A684                      LDA  ,X            ;GET FIRST BYTE OF WARM START ADDR 
C057  8112                      CMPA #$12          ;IS IT NOP? 
C059  2602                      BNE  BACDST        ;NO - DO A COLD START 
C05B  6E84                      JMP  ,X            ;YES, G0 THERE 
                                                     
                      * COLD START ENTRY                      
                                                     
C05D  8E0218          BACDST    LDX  #PROGST+1     ;POINT X TO CLEAR 1ST 1K OF RAM 
C060  6F83            LA077     CLR  ,--X          ;MOVE POINTER DOWN TWO-CLEAR BYTE 
C062  3001                      LEAX 1,X           ;ADVANCE POINTER ONE 
C064  26FA                      BNE  LA077         ;KEEP GOING IF NOT AT BOTTOM OF PAGE 0 
C066  8E0217                    LDX  #PROGST       ;SET TO START OF PROGRAM SPACE 
C069  6F80                      CLR  ,X+           ;CLEAR 1ST BYTE OF BASIC PROGRAM 
C06B  9F19                      STX  TXTTAB        ;BEGINNING OF BASIC PROGRAM 
C06D  A602            LA084     LDA  2,X           ;LOOK FOR END OF MEMORY 
C06F  43                        COMA               ;* COMPLEMENT IT AND PUT IT BACK 
C070  A702                      STA  2,X           ;* INTO SYSTEM MEMORY 
C072  A102                      CMPA 2,X           ;IS IT RAM? 
C074  2606                      BNE  LA093         ;BRANCH IF NOT (ROM, BAD RAM OR NO RAM) 
C076  3001                      LEAX 1,X           ;MOVE POINTER UP ONE 
C078  6301                      COM  1,X           ;RE-COMPLEMENT TO RESTORE BYTE 
C07A  20F1                      BRA  LA084         ;KEEP LOOKING FOR END OF RAM 
C07C  9F71            LA093     STX  TOPRAM        ;SAVE ABSOLUTE TOP OF RAM 
C07E  9F27                      STX  MEMSIZ        ;SAVE TOP OF STRING SPACE 
C080  9F23                      STX  STRTAB        ;SAVE START OF STRING VARIABLES 
C082  3089FF38                  LEAX -200,X        ;CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES 
C086  9F21                      STX  FRETOP        ;SAVE START OF STRING SPACE 
C088  1F14                      TFR  X,S           ;PUT STACK THERE 
C08A  8EC0D1                    LDX  #LA10D        ;POINT X TO ROM SOURCE DATA 
C08D  CE0076                    LDU  #LPTCFW       ;POINT U TO RAM DESTINATION 
C090  C612                      LDB  #18           ;MOVE 18 BYTES 
C092  BDC1B1                    JSR  LA59A         ;MOVE 18 BYTES FROM ROM TO RAM 
C095  CE00A7                    LDU  #IRQVEC       ;POINT U TO NEXT RAM DESTINATION 
C098  C604                      LDB  #4            ;MOVE 4 MORE BYTES 
C09A  BDC1B1                    JSR  LA59A         ;MOVE 4 BYTES FROM ROM TO RAM 
C09D  8639                      LDA  #$39            
C09F  97F0                      STA  LINHDR-1      ;PUT RTS IN LINHDR-1 
C0A1  BDC4BF                    JSR  LAD19         ;G0 DO A 'NEW'
                      * EXTENDED BASIC INITIALISATION                      
C0A4  8E00B5                    LDX  #USR0         ;INITIALIZE ADDRESS OF START OF 
C0A7  9F8D                      STX  USRADR        ;USR JUMP TABLE 
                      * INITIALIZE THE USR CALLS TO;'FC ERROR'
C0A9  CECBD6                    LDU  #LB44A        ;ADDRESS OF 'FC ERROR' ROUTINE
C0AC  C60A                      LDB  #10           ;10 USR CALLS IN EX BASIC 
C0AE  EF81            L8031     STU  ,X++          ;STORE 'FC' ERROR AT USR ADDRESSES
C0B0  5A                        DECB               ;FINISHED ALL 10? 
C0B1  26FB                      BNE  L8031         ;NO 
                      
                      ;; THIS BIT NOT REQURED FOR HB63C09 
                      ;;* INITIALISE ACIA
C0B3  8615                      LDA  #RTS_LOW      ;DIV16 CLOCK -> 7372800 / 4 / 16 = 115200
C0B5  B7A000                    STA  UCTRL
                      
C0B8  8EC106                    LDX  #LA147-1      ;POINT X TO COLOR BASIC COPYRIGHT MESSAGE 
C0BB  BDD0ED                    JSR  LB99C         ;PRINT 'COLOR BASIC'
C0BE  8EC0C9                    LDX  #BAWMST       ;WARM START ADDRESS 
C0C1  9F6F                      STX  RSTVEC        ;SAVE IT 
C0C3  8655                      LDA  #$55          ;WARM START FLAG 
C0C5  976E                      STA  RSTFLG        ;SAVE IT 
C0C7  2004                      BRA  LA0F3         ;GO TO BASIC'S MAIN LOOP
C0C9  12              BAWMST    NOP                ;NOP REQ'D FOR WARM START
C0CA  BDC4D9                    JSR  LAD33         ;DO PART OF A NEW 
C0CD  7EC427          LA0F3     JMP  LAC73         ;GO TO MAIN LOOP OF BASIC 
                      *                              
                      * FIRQ SERVICE ROUTINE                      
C0D0                  BFRQSV                         
C0D0  3B                        RTI                  
                      *                              
                      * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE                      
C0D1  10              LA10D     FCB  16            ;TAB FIELD WIDTH 
C0D2  40                        FCB  64            ;LAST TAB ZONE 
C0D3  50                        FCB  80            ;PRINTER WIDTH 
C0D4  00                        FCB  0             ;LINE PRINTER POSITION 
C0D5  CBD6                      FDB  LB44A         ;ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
                      * LINE INPUT ROUTINE                      
C0D7  0C84                      INC  CHARAD+1        
C0D9  2602                      BNE  LA123           
C0DB  0C83                      INC  CHARAD          
C0DD  B60000          LA123     LDA  >0000           
C0E0  7EC1C2                    JMP  BROMHK          
                      *                              
                      * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1                      
C0E3  7EC1C1                    JMP  BIRQSV        ;IRQ SERVICE 
C0E6  7EC0D0                    JMP  BFRQSV        ;FIRQ SERVICE 
C0E9  7ECBD6                    JMP  LB44A         ;USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
C0EC  80                        FCB  $80           ;*RANDOM SEED 
C0ED  4FC7                      FDB  $4FC7         ;*RANDON SEED OF MANTISSA 
C0EF  5259                      FDB  $5259         ;*.811635157 
                      * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE                      
C0F1  32              COMVEC    FCB  50            ;50 BASIC COMMANDS 
C0F2  C220                      FDB  LAA66         ;POINTS TO RESERVED WORDS 
C0F4  C32F                      FDB  LAB67         ;POINTS TO JUMP TABLE FOR COMMANDS 
C0F6  1D                        FCB  29            ;29 BASIC SECONDARY COMMANDS 
C0F7  C2C2                      FDB  LAB1A         ;POINTS TO SECONDARY FUNCTION RESERVED WORDS 
C0F9  C1D1                      FDB  LAA29         ;POINTS TO SECONDARY FUNCTION JUMP TABLE 
C0FB  0000                      FDB  0             ;NO MORE TABLES (RES WORDS=0) 
C0FD  0000                      FDB  0             ;NO MORE TABLES 
C0FF  0000                      FDB  0             ;NO MORE TABLES 
C101  0000                      FDB  0             ;NO MORE TABLES 
C103  0000                      FDB  0             ;NO MORE TABLES 
C105  0000                      FDB  0             ;NO MORE TABLES (SECONDARY FNS =0) 
                                                     
                      * COPYRIGHT MESSAGES                      
C107  3638303920455854454E444544204241534943 LA147     FCC  "6809 EXTENDED BASIC"
C11A  0D                        FCB  CR              
C11B  2843292031393832204259204D4943524F534F4654           FCC  "(C) 1982 BY MICROSOFT"
                      
C130  0D0D            LA156     FCB  CR,CR           
C132  00              LA165     FCB  $00             
                                                     
                                                     
C133  3416            LA35F     PSHS X,B,A         ;SAVE REGISTERS 
C135  9E76                      LDX  LPTCFW        ;TAB FIELD WIDTH AND TAB ZONE 
C137  DC78                      LDD  LPTWID        ;PRINTER WIDTH AND POSITION 
C139  9F6A            LA37C     STX  DEVCFW        ;SAVE TAB FIELD WIDTH AND ZONE 
C13B  D76C                      STB  DEVPOS        ;SAVE PRINT POSITION 
C13D  976D                      STA  DEVWID        ;SAVE PRINT WIDTH 
C13F  3596                      PULS A,B,X,PC      ;RESTORE REGISTERS 
                                                     
                      * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC                      
                      * EXIT WITH BREAK KEY: CARRY = 1                      
                      * EXIT WITH ENTER KEY: CARRY = 0                      
C141                  LA38D                          
C141  0F73            LA390     CLR  IKEYIM        ;RESET BREAK CHECK KEY TEMP KEY STORAGE 
C143  8E00F4                    LDX  #LINBUF+1     ;INPUT LINE BUFFER 
C146  C601                      LDB  #1            ;ACCB CHAR COUNTER: SET TO 1 TO ALLOW A 
                      *         BACKSPACE AS FIRST CHARACTER  
C148  BDC003          LA39A     JSR  LA171         ;GO GET A CHARACTER FROM CONSOLE IN 
C14B  8108                      CMPA #BS           ;BACKSPACE 
C14D  2607                      BNE  LA3B4         ;NO 
C14F  5A                        DECB               ;YES - DECREMENT CHAR COUNTER 
C150  27EF                      BEQ  LA390         ;BRANCH IF BACK AT START OF LINE AGAIN 
C152  301F                      LEAX -1,X          ;DECREMENT BUFFER POINTER 
C154  2034                      BRA  LA3E8         ;ECHO CHAR TO SCREEN 
C156  8115            LA3B4     CMPA #$15          ;SHIFT RIGHT ARROW? 
C158  260A                      BNE  LA3C2         ;NO 
                      * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE                      
C15A  5A              LA3B8     DECB               ;DEC CHAR CTR 
C15B  27E4                      BEQ  LA390         ;GO BACK TO START IF CHAR CTR = 0 
C15D  8608                      LDA  #BS           ;BACKSPACE? 
C15F  BDC017                    JSR  PUTCHR        ;SEND TO CONSOLE OUT (SCREEN) 
C162  20F6                      BRA  LA3B8         ;KEEP GOING 
C164  8103            LA3C2     CMPA #3            ;BREAK KEY? 
C166  1A01                      ORCC #1            ;SET CARRY FLAG 
C168  2705                      BEQ  LA3CD         ;BRANCH IF BREAK KEY DOWN 
C16A  810D            LA3C8     CMPA #CR           ;ENTER KEY? 
C16C  260D                      BNE  LA3D9         ;NO 
C16E  4F              LA3CC     CLRA               ;CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY 
C16F  3401            LA3CD     PSHS CC            ;SAVE CARRY FLAG 
C171  BDD0AD                    JSR  LB958         ;SEND CR TO SCREEN 
C174  6F84                      CLR  ,X            ;MAKE LAST BYTE IN INPUT BUFFER = 0 
C176  8E00F3                    LDX  #LINBUF       ;RESET INPUT BUFFER POINTER 
C179  3581                      PULS CC,PC         ;RESTORE CARRY FLAG 
                                                     
                      * INSERT A CHARACTER INTO THE;BASIC LINE INPUT BUFFER                      
C17B  8120            LA3D9     CMPA #$20          ;IS IT CONTROL CHAR? 
C17D  25C9                      BLO  LA39A         ;BRANCH IF CONTROL CHARACTER 
C17F  817B                      CMPA #'z+1         ;* 
C181  24C5                      BCC  LA39A         ;* IGNORE IF > LOWER CASE Z 
C183  C1FA                      CMPB #LBUFMX       ;HAVE 250 OR MORE CHARACTERS BEEN ENTERED? 
C185  24C1                      BCC  LA39A         ;YES, IGNORE ANY MORE 
C187  A780                      STA  ,X+           ;PUT IT IN INPUT BUFFER 
C189  5C                        INCB               ;INCREMENT CHARACTER COUNTER 
C18A  BDC017          LA3E8     JSR  PUTCHR        ;ECHO IT TO SCREEN 
C18D  20B9                      BRA  LA39A         ;GO SET SOME MORE 
                                                     
                                                     
                      * EXEC                         
C18F  2705            EXEC      BEQ  LA545         ;BRANCH IF NO ARGUMENT 
C191  BDCEC9                    JSR  LB73D         ;EVALUATE ARGUMENT - ARGUMENT RETURNED IN X 
C194  9F7A                      STX  EXECJP        ;STORE X TO EXEC JUMP ADDRESS 
C196  6E9F007A        LA545     JMP  [EXECJP]      ;GO DO IT 
                                                     
                      * BREAK CHECK                      
C19A  7EC5A8          LA549     JMP  LADEB         ;GO DO BREAK KEY CHECK 
                                                     
                      * INKEY$                       
C19D  9673            INKEY     LDA  IKEYIM        ;WAS A KEY DOWN IN THE BREAK CHECK? 
C19F  2603                      BNE  LA56B         ;YES 
C1A1  BDC008                    JSR  KEYIN         ;GO GET A KEY 
C1A4  0F73            LA56B     CLR  IKEYIM        ;CLEAR INKEY RAM IMAGE 
C1A6  9753                      STA  FPA0+3        ;STORE THE KEY IN FPA0 
C1A8  10260C6F                  LBNE LB68F         ;CONVERT FPA0+3 TO A STRING 
C1AC  9756                      STA  STRDES        ;SET LENGTH OF STRING = 0 IF NO KEY DOWN 
C1AE  7ECE27                    JMP  LB69B         ;PUT A NULL STRING ONTO THE STRING STACK 
                                                     
                      * MOVE ACCB BYTES FROM (X) TO;(U)                      
C1B1  A680            LA59A     LDA  ,X+           ;GET BYTE FROM X 
C1B3  A7C0                      STA  ,U+           ;STORE IT AT U 
C1B5  5A                        DECB               ;MOVED ALL BYTES? 
C1B6  26F9                      BNE  LA59A         ;NO 
C1B8  39              LA5A1     RTS                  
                                                     
C1B9  39              LA5C4     RTS                  
                                                     
                      ** THIS ROUTINE WILL SCAN OFF;THE FILE NAME FROM A BASIC LINE                      
                      ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS                      
                      ** FOLLOWING THE END OF THE NAME                      
C1BA  9D82            LA5C7     JSR  GETCCH        ;GET CURRENT INPUT CHAR FROM BASIC LINE 
C1BC  27FB            LA5C9     BEQ  LA5C4         ;RETURN IF END OF LINE 
C1BE  7ECA08                    JMP  LB277         ;SYNTAX ERROR IF ANY MORE CHARACTERS 
                      * IRQ SERVICE                      
C1C1                  BIRQSV                         
C1C1  3B              LA9C5     RTI                   ;RETURN FROM INTERRUPT  
                                                     
                      * SET CARRY IF NUMERIC - RETURN WITH                      
                      * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END                      
                      * OF BASIC LINE OR SUB LINE                      
C1C2  813A            BROMHK    CMPA #'9+1         ;IS THIS CHARACTER >=(ASCII 9)+1? 
C1C4  240A                      BHS  LAA28         ;BRANCH IF > 9; Z SET IF = COLON 
C1C6  8120                      CMPA #SPACE        ;SPACE? 
C1C8  2602                      BNE  LAA24         ;NO - SET CARRY IF NUMERIC 
C1CA  0E7C                      JMP  GETNCH        ;IF SPACE, GET NECT CHAR (IGNORE SPACES) 
C1CC  8030            LAA24     SUBA #'0           ;* SET CARRY IF 
C1CE  80D0                      SUBA #-'0          ;* CHARACTER > ASCII 0 
C1D0  39              LAA28     RTS                  
                                                     
                      * DISPATCH TABLE FOR SECONDARY FUNCTIONS                      
                      * TOKENS ARE PRECEEDED BY $FF                      
                      * FIRST SET ALWAYS HAS ONE PARAMETER                      
C1D1                  FUNC_TAB                       
C1D1  D3CB            LAA29     FDB  SGN           ;SGN 
C1D3  D43F                      FDB  INT           ;INT 
C1D5  D3E4                      FDB  ABS           ;ABS 
C1D7  00AD                      FDB  USRJMP        ;USR 
0083                  TOK_USR   EQU  (*-FUNC_TAB)/2+$7F  
FF83                  TOK_FF_USR EQU  (*-FUNC_TAB)/2+$FF7F  
C1D9  D670                      FDB  RND           ;RND 
C1DB  D6C5                      FDB  SIN           ;SIN 
C1DD  CEDC                      FDB  PEEK          ;PEEK 
C1DF  CE0D                      FDB  LEN           ;LEN 
C1E1  CC89                      FDB  STR           ;STR$ 
C1E3  CEA2                      FDB  VAL           ;VAL 
C1E5  CE2C                      FDB  ASC           ;ASC 
C1E7  CE18                      FDB  CHR           ;CHR$ 
C1E9  D775                      FDB  ATN           ;ATN 
C1EB  D73D                      FDB  COS           ;COS 
C1ED  D746                      FDB  TAN           ;TAN 
C1EF  D8B7                      FDB  EXP           ;EXP 
C1F1  D8E9                      FDB  FIX           ;FIX 
C1F3  D80B                      FDB  LOG           ;LOG 
C1F5  DA71                      FDB  POS           ;POS 
C1F7  D845                      FDB  SQR           ;SQR 
C1F9  DF43                      FDB  HEXDOL        ;HEX$ 
                      * LEFT, RIGHT AND MID ARE TREATED SEPARATELY                      
C1FB  CE37                      FDB  LEFT          ;LEFT$ 
0095                  TOK_LEFT  EQU  (*-FUNC_TAB)/2+$7F  
C1FD  CE54                      FDB  RIGHT         ;RIGHT$ 
C1FF  CE5B                      FDB  MID           ;MID$ 
0097                  TOK_MID   EQU  (*-FUNC_TAB)/2+$7F  
                      * REMAINING FUNCTIONS                      
C201  C19D                      FDB  INKEY         ;INKEY$ 
0098                  TOK_INKEY EQU  (*-FUNC_TAB)/2+$7F  
C203  CC7A                      FDB  MEM           ;MEM 
C205  DA79                      FDB  VARPT         ;VARPTR 
C207  DB39                      FDB  INSTR         ;INSTR 
C209  DB09                      FDB  STRING        ;STRING$ 
001D                  NUM_SEC_FNS EQU  (*-FUNC_TAB)/2    
                                                     
                      * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC                      
                      * AND LOGICAL OPERATORS - THE;NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS                      
                      * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE                      
                      * EXPRESSION EVALUATION ROUTINE. THEY ARE:                      
                      * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A                      
                      * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.                      
                      * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES                      
                      *                              
C20B  79              LAA51     FCB  $79             
C20C  D116                      FDB  LB9C5         ;+ 
C20E  79                        FCB  $79             
C20F  D10D                      FDB  LB9BC         ;- 
C211  7B                        FCB  $7B             
C212  D21D                      FDB  LBACC         ;* 
C214  7B                        FCB  $7B             
C215  D2E2                      FDB  LBB91         ;/ 
C217  7F                        FCB  $7F             
C218  D84E                      FDB  L8489         ;EXPONENTIATION 
C21A  50                        FCB  $50             
C21B  CA61                      FDB  LB2D5         ;AND 
C21D  46                        FCB  $46             
C21E  CA60                      FDB  LB2D4         ;OR 
                                                     
                      * THIS IS THE RESERVED WORD TABLE                      
                      * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS                      
C220  464F            LAA66     FCC  "FO"          ;80 
C222  D2                        FCB  $80+'R'         
C223  47                        FCC  "G"           ;81 
C224  CF                        FCB  $80+'O'         
0081                  TOK_GO    EQU  $81             
C225  5245                      FCC  "RE"          ;82 
C227  CD                        FCB  $80+'M'         
                      ;EXIT TO MONITOR WITH BYE (SUB'S LITTLE USED ' ' ' INSTEAD OF REM FOR REMARKS
                       IF MON09   ; IF USING WITH MON09
C228  4259                      FCC  "BY"
C22A  C5                        FCB  'E'+$80       ;83
                       ELSE
                                FCB  ''+$80        ;83
                       ENDIF
C22B  454C53                    FCC  "ELS"         ;84 
C22E  C5                        FCB  $80+'E'         
C22F  49                        FCC  "I"           ;85 
C230  C6                        FCB  $80+'F'         
C231  444154                    FCC  "DAT"         ;86 
C234  C1                        FCB  $80+'A'         
C235  5052494E                  FCC  "PRIN"        ;87 
C239  D4                        FCB  $80+'T'         
C23A  4F                        FCC  "O"           ;88 
C23B  CE                        FCB  $80+'N'         
C23C  494E5055                  FCC  "INPU"        ;89 
C240  D4                        FCB  $80+'T'         
C241  454E                      FCC  "EN"          ;8A 
C243  C4                        FCB  $80+'D'         
C244  4E4558                    FCC  "NEX"         ;8B 
C247  D4                        FCB  $80+'T'         
C248  4449                      FCC  "DI"          ;8C 
C24A  CD                        FCB  $80+'M'         
C24B  524541                    FCC  "REA"         ;8D 
C24E  C4                        FCB  $80+'D'         
C24F  5255                      FCC  "RU"          ;8E 
C251  CE                        FCB  $80+'N'         
C252  524553544F52              FCC  "RESTOR"      ;8F 
C258  C5                        FCB  $80+'E'         
C259  5245545552                FCC  "RETUR"       ;90 
C25E  CE                        FCB  $80+'N'         
C25F  53544F                    FCC  "STO"         ;91 
C262  D0                        FCB  $80+'P'         
C263  504F4B                    FCC  "POK"         ;92 
C266  C5                        FCB  $80+'E'         
C267  434F4E                    FCC  "CON"         ;93 
C26A  D4                        FCB  $80+'T'         
C26B  4C4953                    FCC  "LIS"         ;94 
C26E  D4                        FCB  $80+'T'         
C26F  434C4541                  FCC  "CLEA"        ;95 
C273  D2                        FCB  $80+'R'         
C274  4E45                      FCC  "NE"          ;96 
C276  D7                        FCB  $80+'W'         
C277  455845                    FCC  "EXE"         ;97 
C27A  C3                        FCB  $80+'C'         
C27B  54524F                    FCC  "TRO"         ;98 
C27E  CE                        FCB  $80+'N'         
C27F  54524F46                  FCC  "TROF"        ;99 
C283  C6                        FCB  $80+'F'         
C284  4445                      FCC  "DE"          ;9A 
C286  CC                        FCB  $80+'L'         
C287  4445                      FCC  "DE"          ;9B 
C289  C6                        FCB  $80+'F'         
C28A  4C494E                    FCC  "LIN"         ;9C 
C28D  C5                        FCB  $80+'E'         
C28E  52454E55                  FCC  "RENU"        ;9D 
C292  CD                        FCB  $80+'M'         
C293  454449                    FCC  "EDI"         ;9E 
C296  D4                        FCB  $80+'T'         
                      * END OF EXECUTABLE COMMANDS.;THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS                      
C297  544142                    FCC  "TAB"         ;9F 
C29A  A8                        FCB  $80+'('         
009F                  TOK_TAB   EQU  $9F             
C29B  54                        FCC  "T"           ;A0 
C29C  CF                        FCB  $80+'O'         
00A0                  TOK_TO    EQU  $A0             
C29D  5355                      FCC  "SU"          ;A1 
C29F  C2                        FCB  $80+'B'         
00A1                  TOK_SUB   EQU  $A1             
C2A0  544845                    FCC  "THE"         ;A2 
C2A3  CE                        FCB  $80+'N'         
00A2                  TOK_THEN  EQU  $A2             
C2A4  4E4F                      FCC  "NO"          ;A3 
C2A6  D4                        FCB  $80+'T'         
00A3                  TOK_NOT   EQU  $A3             
C2A7  535445                    FCC  "STE"         ;A4 
C2AA  D0                        FCB  $80+'P'         
00A4                  TOK_STEP  EQU  $A4             
C2AB  4F46                      FCC  "OF"          ;A5 
C2AD  C6                        FCB  $80+'F'         
C2AE  AB                        FCB  '++$80        ;A6 
00A6                  TOK_PLUS  EQU  $A6             
C2AF  AD                        FCB  '-+$80        ;A7 
00A7                  TOK_MINUS EQU  $A7             
C2B0  AA                        FCB  '*+$80        ;A8 
C2B1  AF                        FCB  '/+$80        ;A9 
C2B2  DE                        FCB  '^+$80        ;AA 
C2B3  414E                      FCC  "AN"          ;AB 
C2B5  C4                        FCB  $80+'D'         
C2B6  4F                        FCC  "O"           ;AC 
C2B7  D2                        FCB  $80+'R'         
C2B8  BE                        FCB  '>+$80        ;AD 
00AD                  TOK_GREATER EQU  $AD             
C2B9  BD                        FCB  '=+$80        ;AE 
00AE                  TOK_EQUALS EQU  $AE             
C2BA  BC                        FCB  '<+$80        ;AF 
C2BB  46                        FCC  "F"           ;B0 
C2BC  CE                        FCB  $80+'N'         
00B0                  TOK_FN    EQU  $B0             
C2BD  5553494E                  FCC  "USIN"        ;B1 
C2C1  C7                        FCB  $80+'G'         
00B1                  TOK_USING EQU  $B1             
                      *                              
                                                     
                      * FIRST SET ALWAYS HAS ONE PARAMETER                      
C2C2  5347            LAB1A     FCC  "SG"          ;80 
C2C4  CE                        FCB  $80+'N'         
C2C5  494E                      FCC  "IN"          ;81 
C2C7  D4                        FCB  $80+'T'         
C2C8  4142                      FCC  "AB"          ;82 
C2CA  D3                        FCB  $80+'S'         
C2CB  5553                      FCC  "US"          ;83 
C2CD  D2                        FCB  $80+'R'         
C2CE  524E                      FCC  "RN"          ;84 
C2D0  C4                        FCB  $80+'D'         
C2D1  5349                      FCC  "SI"          ;85 
C2D3  CE                        FCB  $80+'N'         
C2D4  504545                    FCC  "PEE"         ;86 
C2D7  CB                        FCB  $80+'K'         
C2D8  4C45                      FCC  "LE"          ;87 
C2DA  CE                        FCB  $80+'N'         
C2DB  535452                    FCC  "STR"         ;88 
C2DE  A4                        FCB  $80+'$'         
C2DF  5641                      FCC  "VA"          ;89 
C2E1  CC                        FCB  $80+'L'         
C2E2  4153                      FCC  "AS"          ;8A 
C2E4  C3                        FCB  $80+'C'         
C2E5  434852                    FCC  "CHR"         ;8B 
C2E8  A4                        FCB  $80+'$'         
C2E9  4154                      FCC  "AT"          ;8C 
C2EB  CE                        FCB  $80+'N'         
C2EC  434F                      FCC  "CO"          ;8D 
C2EE  D3                        FCB  $80+'S'         
C2EF  5441                      FCC  "TA"          ;8E 
C2F1  CE                        FCB  $80+'N'         
C2F2  4558                      FCC  "EX"          ;8F 
C2F4  D0                        FCB  $80+'P'         
C2F5  4649                      FCC  "FI"          ;90 
C2F7  D8                        FCB  $80+'X'         
C2F8  4C4F                      FCC  "LO"          ;91 
C2FA  C7                        FCB  $80+'G'         
C2FB  504F                      FCC  "PO"          ;92 
C2FD  D3                        FCB  $80+'S'         
C2FE  5351                      FCC  "SQ"          ;93 
C300  D2                        FCB  $80+'R'         
C301  484558                    FCC  "HEX"         ;94 
C304  A4                        FCB  $80+'$'         
                      * LEFT, RIGHT AND MID ARE TREATED SEPARATELY                      
C305  4C454654                  FCC  "LEFT"        ;95 
C309  A4                        FCB  $80+'$'         
C30A  5249474854                FCC  "RIGHT"       ;96 
C30F  A4                        FCB  $80+'$'         
C310  4D4944                    FCC  "MID"         ;97 
C313  A4                        FCB  $80+'$'         
                      * REMAINING FUNCTIONS                      
C314  494E4B4559                FCC  "INKEY"       ;98 
C319  A4                        FCB  $80+'$'         
C31A  4D45                      FCC  "ME"          ;99 
C31C  CD                        FCB  $80+'M'         
C31D  5641525054                FCC  "VARPT"       ;9A 
C322  D2                        FCB  $80+'R'         
C323  494E5354                  FCC  "INST"        ;9B 
C327  D2                        FCB  $80+'R'         
C328  535452494E47              FCC  "STRING"      ;9C 
C32E  A4                        FCB  $80+'$'         
                                                     
                      *                              
                      * DISPATCH TABLE FOR COMMANDS TOKEN #
C32F                  CMD_TAB                        
C32F  C4ED            LAB67     FDB  FOR           ;80   
C331  C63B                      FDB  GO            ;81   
C333  C698                      FDB  REM           ;82   
0082                  TOK_REM   EQU  (*-CMD_TAB)/2+$7F  
                       IF MON09
0082                  TOK_SNGL_Q EQU TOK_REM
C335  C5BF                      FDB  BYE
                       ELSE
                                FDB  REM           ;83 (')
                      TOK_SNGL_Q EQU  (*-CMD_TAB)/2+$7F
                       ENDIF
C337  C698                      FDB  REM           ;84 (ELSE) 
0084                  TOK_ELSE  EQU  (*-CMD_TAB)/2+$7F  
C339  C6C9                      FDB  IF            ;85   
0085                  TOK_IF    EQU  (*-CMD_TAB)/2+$7F  
C33B  C695                      FDB  DATA          ;86   
0086                  TOK_DATA  EQU  (*-CMD_TAB)/2+$7F  
C33D  D072                      FDB  PRINT         ;87   
0087                  TOK_PRINT EQU  (*-CMD_TAB)/2+$7F  
C33F  C6F7                      FDB  ON            ;88   
C341  C7A4                      FDB  INPUT         ;89   
0089                  TOK_INPUT EQU  (*-CMD_TAB)/2+$7F  
C343  C5C2                      FDB  END           ;8A   
C345  C889                      FDB  NEXT          ;8B   
C347  CADA                      FDB  DIM           ;8C   
C349  C7DE                      FDB  READ          ;8D   
C34B  C630                      FDB  RUN           ;8E   
C34D  C5A1                      FDB  RESTOR        ;8F 
C34F  C675                      FDB  RETURN        ;90   
C351  C5C6                      FDB  STOP          ;91   
C353  CEE3                      FDB  POKE          ;92   
C355  C5EB                      FDB  CONT          ;93 
C357  CEEA                      FDB  LIST          ;94   
C359  C5FC                      FDB  CLEAR         ;95   
C35B  C4BD                      FDB  NEW           ;96   
C35D  C18F                      FDB  EXEC          ;97 
C35F  DA6C                      FDB  TRON          ;98 
C361  DA6D                      FDB  TROFF         ;99 
C363  DCE8                      FDB  DEL           ;9A 
C365  DC2C                      FDB  DEF           ;9B 
C367  E3D6                      FDB  LINE          ;9C 
C369  DD72                      FDB  RENUM         ;9D 
C36B  D8F8                      FDB  EDIT          ;9E 
009E                  TOK_HIGH_EXEC EQU  (*-CMD_TAB)/2+$7F  
                                                     
                      * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY                      
C36D  4E46            LABAF     FCC  "NF"          ;0 NEXT WITHOUT FOR   
C36F  534E                      FCC  "SN"          ;1 SYNTAX ERROR   
C371  5247                      FCC  "RG"          ;2 RETURN WITHOUT GOSUB   
C373  4F44                      FCC  "OD"          ;3 OUT OF DATA   
C375  4643                      FCC  "FC"          ;4 ILLEGAL FUNCTION CALL   
C377  4F56                      FCC  "OV"          ;5 OVERFLOW   
C379  4F4D                      FCC  "OM"          ;6 OUT OF MEMORY   
C37B  554C                      FCC  "UL"          ;7 UNDEFINED LINE NUMBER   
C37D  4253                      FCC  "BS"          ;8 BAD SUBSCRIPT   
C37F  4444                      FCC  "DD"          ;9 REDIMENSIONED ARRAY   
C381  2F30                      FCC  "/0"          ;10 DIVISION BY ZERO 
C383  4944                      FCC  "ID"          ;11 ILLEGAL DIRECT STATEMENT 
C385  544D                      FCC  "TM"          ;12 TYPE MISMATCH 
C387  4F53                      FCC  "OS"          ;13 OUT OF STRING SPACE 
C389  4C53                      FCC  "LS"          ;14 STRING TOO LONG 
C38B  5354                      FCC  "ST"          ;15 STRING FORMULA TOO COMPLEX 
C38D  434E                      FCC  "CN"          ;16 CAN'T CONTINUE 
C38F  4644                      FCC  "FD"          ;17 BAD FILE DATA 
C391  414F                      FCC  "AO"          ;18 FILE ALREADY OPEN 
C393  444E                      FCC  "DN"          ;19 DEVICE NUMBER ERROR 
C395  494F                      FCC  "IO"          ;20 I/O ERROR 
C397  464D                      FCC  "FM"          ;21 BAD FILE MODE 
C399  4E4F                      FCC  "NO"          ;22 FILE NOT OPEN 
C39B  4945                      FCC  "IE"          ;23 INPUT PAST END OF FILE 
C39D  4453                      FCC  "DS"          ;24 DIRECT STATEMENT IN FILE 
                      * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC                      
C39F  5546            L890B     FCC  "UF"          ;25 UNDEFINED FUNCTION (FN) CALL 
C3A1  4E45            L890D     FCC  "NE"          ;26 FILE NOT FOUND 
                                                     
C3A3  204552524F52    LABE1     FCC  " ERROR"        
C3A9  00                        FCB  $00             
C3AA  20494E20        LABE8     FCC  " IN "          
C3AE  00                        FCB  $00             
C3AF  0D              LABED     FCB  CR              
C3B0  4F4B            LABEE     FCC  "OK"            
C3B2  0D00                      FCB  CR,$00          
C3B4  0D              LABF2     FCB  CR              
C3B5  425245414B                FCC  "BREAK"         
C3BA  00                        FCB  $00             
                                                     
                      * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
                      * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
                      * SOUGHT IS STORED IN VARDES.;EACH BLOCK OF FOR/NEXT DATA IS 18                      
                      * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES                      
                      * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA                      
                      * IS CONSIDERED 'GOSUB/RETURN'
C3BB  3064            LABF9     LEAX 4,S           ;POINT X TO 3RD ADDRESS ON STACK - IGNORE THE 
                      *         FIRST TWO RETURN ADDRESSES ON THE STACK  
C3BD  C612            LABFB     LDB  #18           ;18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
C3BF  9F0F                      STX  TEMPTR        ;SAVE POINTER 
C3C1  A684                      LDA  ,X            ;GET 1ST BYTE 
C3C3  8080                      SUBA #$80          ;* CHECK FOR TYPE OF STACK JUMP FOUND 
C3C5  2615                      BNE  LAC1A         ;* BRANCH IF NOT 'FOR/NEXT'
C3C7  AE01                      LDX  1,X           ;= GET INDEX VARIABLE DESCRIPTOR 
C3C9  9F11                      STX  TMPTR1        ;= POINTER AND SAVE IT IN TMPTR1 
C3CB  9E3B                      LDX  VARDES        ;GET INDEX VARIABLE BEING SEARCHED FOR 
C3CD  2709                      BEQ  LAC16         ;BRANCH IF DEFAULT INDEX VARIABLE - USE THE 
                      *                            ;FIRST 'FOR/NEXT' DATA FOUND ON STACK
                      *                            ;IF NO INDEX VARIABLE AFTER 'NEXT'
C3CF  9C11                      CMPX TMPTR1        ;DOES THE STACK INDEX MATCH THE ONE 
                      *                            ;BEING SEARCHED FOR? 
C3D1  2709                      BEQ  LAC1A         ;YES 
C3D3  9E0F                      LDX  TEMPTR        ;* RESTORE INITIAL POINTER, ADD 
C3D5  3A                        ABX                ;* 18 TO IT AND LOOK FOR 
C3D6  20E5                      BRA  LABFB         ;* NEXT BLOCK OF DATA 
C3D8  9E11            LAC16     LDX  TMPTR1        ;= GET 1ST INDEX VARIABLE FOUND AND 
C3DA  9F3B                      STX  VARDES        ;= SAVE AS 'NEXT' INDEX
C3DC  9E0F            LAC1A     LDX  TEMPTR        ;POINT X TO START OF 'FOR/NEXT' DATA
C3DE  4D                        TSTA               ;SET ZERO FLAG IF 'FOR/NEXT' DATA
C3DF  39                        RTS                  
                      * CHECK FOR MEMORY SPACE FOR NEW TOP OF                      
                      * ARRAYS AND MOVE ARRAYS TO NEW LOCATION                      
C3E0  8D17            LAC1E     BSR  LAC37         ;ACCD = NEW BOTTOM OF FREE RAM - IS THERE 
                      *                            ;ROOM FOR THE STACK? 
                      * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND                      
                      * SAVE FINAL VALUE OF U IN V45                      
C3E2  DE41            LAC20     LDU  V41           ;POINT U TO DESTINATION ADDRESS (V41) 
C3E4  3341                      LEAU 1,U           ;ADD ONE TO U - COMPENSATE FOR FIRST PSHU 
C3E6  9E43                      LDX  V43           ;POINT X TO SOURCE ADDRESS (V43) 
C3E8  3001                      LEAX 1,X           ;ADD ONE - COMPENSATE FOR FIRST LDA ,X 
C3EA  A682            LAC28     LDA  ,-X           ;GRAB A BYTE FROM SOURCE 
C3EC  3602                      PSHU A             ;MOVE IT TO DESTINATION 
C3EE  9C47                      CMPX V47           ;DONE? 
C3F0  26F8                      BNE  LAC28         ;NO - KEEP MOVING BYTES 
C3F2  DF45                      STU  V45           ;SAVE FINAL DESTINATION ADDRESS 
C3F4  39              LAC32     RTS                  
                      * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB                      
                      * BYTES IN FREE RAM - OM ERROR IF NOT                      
C3F5  4F              LAC33     CLRA               ;* ACCD CONTAINS NUMBER OF EXTRA 
C3F6  58                        ASLB               ;* BYTES TO PUT ON STACK 
C3F7  D31F                      ADDD ARYEND        ;END OF PROGRAM AND VARIABLES 
C3F9  C3003A          LAC37     ADDD #STKBUF       ;ADD STACK BUFFER - ROOM FOR STACK? 
C3FC  2508                      BCS  LAC44         ;BRANCH IF GREATER THAN $FFFF 
C3FE  10DF17                    STS  BOTSTK        ;CURRENT NEW BOTTOM OF STACK STACK POINTER 
C401  109317                    CMPD BOTSTK        ;ARE WE GOING TO BE BELOW STACK? 
C404  25EE                      BCS  LAC32         ;YES - NO ERROR 
C406  C60C            LAC44     LDB  #6*2          ;OUT OF MEMORY ERROR 
                                                     
                      * ERROR SERVICING ROUTINE                      
C408  BDC4D9          LAC46     JSR  LAD33         ;RESET STACK, STRING STACK, CONTINUE POINTER 
C40B  BDD0B1                    JSR  LB95C         ;SEND A CR TO SCREEN 
C40E  BDD100                    JSR  LB9AF         ;SEND A '?' TO SCREEN
C411  8EC36D                    LDX  #LABAF        ;POINT TO ERROR TABLE 
C414  3A              LAC60     ABX                ;ADD MESSAGE NUMBER OFFSET 
C415  8D31                      BSR  LACA0         ;* GET TWO CHARACTERS FROM X AND 
C417  8D2F                      BSR  LACA0         ;* SEND TO CONSOLE OUT (SCREEN) 
C419  8EC3A2                    LDX  #LABE1-1      ;POINT TO "ERROR" MESSAGE 
C41C  BDD0ED          LAC68     JSR  LB99C         ;PRINT MESSAGE POINTED TO BY X 
C41F  9668                      LDA  CURLIN        ;GET CURRENT LINE NUMBER (CURL IN) 
C421  4C                        INCA               ;TEST FOR DIRECT MODE 
C422  2703                      BEQ  LAC73         ;BRANCH IF DIRECT MODE 
C424  BDD516                    JSR  LBDC5         ;PRINT 'IN ****'
                                                     
                      * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE                      
C427  BDD0B1          LAC73     JSR  LB95C         ;MOVE CURSOR TO START OF LINE 
C42A  8EC3AF                    LDX  #LABED        ;POINT X TO 'OK', CR MESSAGE
C42D  BDD0ED                    JSR  LB99C         ;PRINT 'OK', CR
C430  BDC141          LAC7C     JSR  LA390         ;GO GET AN INPUT LINE 
C433  CEFFFF                    LDU  #$FFFF        ;THE LINE NUMBER FOR DIRECT MODE IS $FFFF 
C436  DF68                      STU  CURLIN        ;SAVE IT IN CURLIN 
C438  25F6                      BCS  LAC7C         ;BRANCH IF LINE INPUT TERMINATED BY BREAK 
C43A  9F83                      STX  CHARAD        ;SAVE (X) AS CURRENT INPUT POINTER - THIS WILL 
                      *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
                      *         LINE JUST ENTERED WILL BE INTERPRETED  
C43C  9D7C                      JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
C43E  27F0                      BEQ  LAC7C         ;NO LINE INPUT - GET ANOTHER LINE 
C440  250B                      BCS  LACA5         ;BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE 
                      *         THE  STATEMENT ENTERED, SO THIS STATEMENT  
                      *         WILL BE MERGED INTO;THE BASIC PROGRAM  
C442  BDCF9F                    JSR  LB821         ;GO CRUNCH LINE 
C445  7EC576                    JMP  LADC0         ;GO EXECUTE THE STATEMENT (LIVE KEYBOARD) 
                      *                              
C448  A680            LACA0     LDA  ,X+           ;GET A CHARACTER 
C44A  7ED102                    JMP  LB9B1         ;SEND TO CONSOLE OUT 
                      * TAKE A LINE FROM THE LINE INPUT BUFFER                      
                      * AND INSERT IT INTO THE BASIC PROGRAM                      
C44D  BDC71C          LACA5     JSR  LAF67         ;CONVERT LINE NUMBER TO BINARY 
C450  9E2B            LACA8     LDX  BINVAL        ;GET CONVERTED LINE NUMBER 
C452  9FF1                      STX  LINHDR        ;STORE IT IN LINE INPUT HEADER 
C454  BDCF9F                    JSR  LB821         ;GO CRUNCH THE LINE 
C457  D703                      STB  TMPLOC        ;SAVE LINE LENGTH 
C459  8D4C                      BSR  LAD01         ;FIND OUT WHERE TO INSERT LINE 
C45B  2512                      BCS  LACC8         ;BRANCH IF LINE NUMBER DOES NOT ALREADY EXIST 
C45D  DC47                      LDD  V47           ;GET ABSOLUTE ADDRESS OF LINE NUMBER 
C45F  A384                      SUBD ,X            ;SUBTRACT ADDRESS OF NEXT LINE NUMBER 
C461  D31B                      ADDD VARTAB        ;* ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE 
C463  DD1B                      STD  VARTAB        ;* THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM 
C465  EE84                      LDU  ,X            ;POINT U TO ADDRESS OF NEXT LINE NUMBER 
                      * DELETE OLD LINE FROM BASIC PROGRAM                      
C467  3702            LACC0     PULU A             ;GET A BYTE FROM WHAT'S LEFT OF PROGRAM
C469  A780                      STA  ,X+           ;MOVE IT DOWN 
C46B  9C1B                      CMPX VARTAB        ;COMPARE TO END OF BASIC PROGRAM 
C46D  26F8                      BNE  LACC0         ;BRANCH IF NOT AT END 
C46F  96F3            LACC8     LDA  LINBUF        ;* CHECK TO SEE IF THERE IS A LINE IN 
C471  271C                      BEQ  LACE9         ;* THE BUFFER AND BRANCH IF NONE 
C473  DC1B                      LDD  VARTAB        ;= SAVE CURRENT END OF 
C475  DD43                      STD  V43           ;= PROGRAM IN V43 
C477  DB03                      ADDB TMPLOC        ;* ADD LENGTH OF CRUNCHED LINE, 
C479  8900                      ADCA #0            ;* PROPOGATE CARRY AND SAVE NEW END 
C47B  DD41                      STD  V41           ;* OF PROGRAM IN V41 
C47D  BDC3E0                    JSR  LAC1E         ;= MAKE SURE THERE'S ENOUGH RAM FOR THIS
                      *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE  
C480  CE00EF                    LDU  #LINHDR-2     ;POINT U TO LINE TO BE INSERTED 
C483  3702            LACDD     PULU A             ;GET A BYTE FROM NEW LINE 
C485  A780                      STA  ,X+           ;INSERT IT IN PROGRAM 
C487  9C45                      CMPX V45           ;* COMPARE TO ADDRESS OF END OF INSERTED 
C489  26F8                      BNE  LACDD         ;* LINE AND BRANCH IF NOT DONE 
C48B  9E41                      LDX  V41           ;= GET AND SAVE 
C48D  9F1B                      STX  VARTAB        ;= END OF PROGRAM 
C48F  8D36            LACE9     BSR  LAD21         ;RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE 
C491  8D02                      BSR  LACEF         ;ADJUST START OF NEXT LINE ADDRESSES 
C493  209B                      BRA  LAC7C         ;REENTER BASIC'S INPUT LOOP
                      * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM                      
C495  9E19            LACEF     LDX  TXTTAB        ;POINT X TO START OF PROGRAM 
C497  EC84            LACF1     LDD  ,X            ;GET ADDRESS OF NEXT LINE 
C499  2721                      BEQ  LAD16         ;RETURN IF END OF PROGRAM 
C49B  3304                      LEAU 4,X           ;POINT U TO START OF BASIC TEXT IN LINE 
C49D  A6C0            LACF7     LDA  ,U+           ;* SKIP THROUGH THE LINE UNTIL A 
C49F  26FC                      BNE  LACF7         ;* ZERO (END OF LINE) IS FOUND 
C4A1  EF84                      STU  ,X            ;SAVE THE NEW START OF NEXT LINE ADDRESS 
C4A3  AE84                      LDX  ,X            ;POINT X TO START OF NEXT LINE 
C4A5  20F0                      BRA  LACF1         ;KEEP GOING 
                      *                              
                      * FIND A LINE NUMBER IN THE BASIC PROGRAM                      
                      * RETURN WITH CARRY SET IF NO;MATCH FOUND                      
C4A7  DC2B            LAD01     LDD  BINVAL        ;GET THE LINE NUMBER TO FIND 
C4A9  9E19                      LDX  TXTTAB        ;BEGINNING OF PROGRAM 
C4AB  EE84            LAD05     LDU  ,X            ;GET ADDRESS OF NEXT LINE NUMBER 
C4AD  2709                      BEQ  LAD12         ;BRANCH IF END OF PROG 
C4AF  10A302                    CMPD 2,X           ;IS IT A MATCH? 
C4B2  2306                      BLS  LAD14         ;CARRY SET IF LOWER; CARRY CLEAR IF MATCH 
C4B4  AE84                      LDX  ,X            ;X = ADDRESS OF NEXT LINE 
C4B6  20F3                      BRA  LAD05         ;KEEP LOOPING FOR LINE NUMBER 
C4B8  1A01            LAD12     ORCC #1            ;SET CARRY FLAG 
C4BA  9F47            LAD14     STX  V47           ;SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER 
                      *                            ;WHERE IT SHOULD HAVE BEEN 
C4BC  39              LAD16     RTS                  
                                                     
                      * NEW                          
C4BD  26FB            NEW       BNE  LAD14         ;BRANCH IF ARGUMENT GIVEN 
C4BF  9E19            LAD19     LDX  TXTTAB        ;GET START OF BASIC 
C4C1  6F80                      CLR  ,X+           ;* PUT 2 ZERO BYTES THERE - ERASE 
C4C3  6F80                      CLR  ,X+           ;* THE BASIC PROGRAM 
C4C5  9F1B                      STX  VARTAB        ;AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM 
C4C7  9E19            LAD21     LDX  TXTTAB        ;GET START OF BASIC 
C4C9  BDC670                    JSR  LAEBB         ;PUT INPUT POINTER ONE BEFORE START OF BASIC 
                      * ERASE ALL VARIABLES                      
C4CC  9E27            LAD26     LDX  MEMSIZ        ;* RESET START OF STRING VARIABLES 
C4CE  9F23                      STX  STRTAB        ;* TO TOP OF STRING SPACE 
C4D0  BDC5A1                    JSR  RESTOR        ;RESET 'DATA' POINTER TO START OF BASIC
C4D3  9E1B                      LDX  VARTAB        ;* GET START OF VARIABLES AND USE IT 
C4D5  9F1D                      STX  ARYTAB        ;* TO RESET START OF ARRAYS 
C4D7  9F1F                      STX  ARYEND        ;RESET END OF ARRAYS 
C4D9  8E00C9          LAD33     LDX  #STRSTK       ;* RESET STRING STACK POINTER TO 
C4DC  9F0B                      STX  TEMPPT        ;* BOTTOM OF STRING STACK 
C4DE  AEE4                      LDX  ,S            ;GET RETURN ADDRESS OFF STACK 
C4E0  10DE21                    LDS  FRETOP        ;RESTORE STACK POINTER 
C4E3  6FE2                      CLR  ,-S           ;PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF 
                      *                            ;FOR/NEXT DATA FROM THE STACK 
C4E5  0F2D                      CLR  OLDPTR        ;RESET 'CONT' ADDRESS SO YOU
C4E7  0F2E                      CLR  OLDPTR+1      ;'CAN'T CONTINUE'
C4E9  0F08                      CLR  ARYDIS        ;CLEAR THE ARRAY DISABLE FLAG 
C4EB  6E84                      JMP  ,X            ;RETURN TO CALLING ROUTINE - THIS IS NECESSARY 
                      *                            ;SINCE THE STACK WAS RESET 
                      *                              
                      * FOR                          
                      *                              
                      * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR                      
                      * EACH FOR-NEXT LOOP WHICH IS;BEING PROCESSED. THESE                      
                      * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);                      
                      *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;  
                      *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;  
                      * 9-13=FP VALUE OF 'TO' PARAMETER;
                      * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END                      
                      *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
C4ED  8680            FOR       LDA  #$80          ;* SAVE THE DISABLE ARRAY FLAG IN VO8 
C4EF  9708                      STA  ARYDIS        ;* DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY 
C4F1  BDC73E                    JSR  LET           ;SET INDEX VARIABLE TO INITIAL VALUE 
C4F4  BDC3BB                    JSR  LABF9         ;SEARCH THE STACK FOR 'FOR/NEXT' DATA
C4F7  3262                      LEAS 2,S           ;PURGE RETURN ADDRESS OFF OF THE STACK 
C4F9  2604                      BNE  LAD59         ;BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED 
C4FB  9E0F                      LDX  TEMPTR        ;GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
C4FD  3285                      LEAS B,X           ;MOVE THE STACK POINTER TO THE BEGINNING OF THE 
                      * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
                      * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY                      
                      * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
                      * THIS POINT ON THE STACK                      
C4FF  C609            LAD59     LDB  #$09          ;* CHECK FOR ROOM FOR 18 BYTES 
C501  BDC3F5                    JSR  LAC33         ;* IN FREE RAM 
C504  BDC69D                    JSR  LAEE8         ;GET ADDR OF END OF SUBLINE IN X 
C507  DC68                      LDD  CURLIN        ;GET CURRENT LINE NUMBER 
C509  3416                      PSHS X,B,A         ;SAVE LINE ADDR AND LINE NUMBER ON STACK 
C50B  C6A0                      LDB  #TOK_TO       ;TOKEN FOR 'TO'
C50D  BDCA00                    JSR  LB26F         ;SYNTAX CHECK FOR 'TO'
C510  BDC8D4                    JSR  LB143         ;'TM' ERROR IF INDEX VARIABLE SET TO STRING
C513  BDC8D2                    JSR  LB141         ;EVALUATE EXPRESSION 
                      *                              
C516  D654                      LDB  FP0SGN        ;GET FPA0 MANTISSA SIGN 
C518  CA7F                      ORB  #$7F          ;FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA 
C51A  D450                      ANDB FPA0          ;PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA 
C51C  D750                      STB  FPA0          ;SAVE THE PACKED HIGH ORDER MANTISSA 
C51E  108EC525                  LDY  #LAD7F        ;LOAD FOLLOWING ADDRESS INTO Y AS A RETURN 
C522  7EC97B                    JMP  LB1EA         ;ADDRESS - PUSH FPA0 ONTO THE STACK 
C525  8ED216          LAD7F     LDX  #LBAC5        ;POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE) 
C528  BDD365                    JSR  LBC14         ;MOVE (X) TO FPA0 
C52B  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C52D  81A4                      CMPA #TOK_STEP     ;STEP TOKEN 
C52F  2605                      BNE  LAD90         ;BRANCH IF NO 'STEP' VALUE
C531  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C533  BDC8D2                    JSR  LB141         ;EVALUATE NUMERIC EXPRESSION 
C536  BDD3BE          LAD90     JSR  LBC6D         ;CHECK STATUS OF FPA0 
C539  BDC977                    JSR  LB1E6         ;SAVE STATUS AND FPA0 ON THE STACK 
C53C  DC3B                      LDD  VARDES        ;* GET DESCRIPTOR POINTER FOR THE 'STEP'
C53E  3406                      PSHS B,A           ;* VARIABLE AND SAVE IT ON THE STACK 
C540  8680                      LDA  #$80          ;= GET THE 'FOR' FLAG AND
C542  3402                      PSHS A             ;= SAVE IT ON THE STACK 
                      *                              
                      * MAIN COMMAND INTERPRETATION;LOOP                      
C544  1CAF            LAD9E     ANDCC #$AF         ;ENABLE IRQ,FIRQ 
C546  8D60                      BSR  LADEB         ;CHECK FOR KEYBOARD BREAK 
C548  9E83                      LDX  CHARAD        ;GET BASIC'S INPUT POINTER
C54A  9F2F                      STX  TINPTR        ;SAVE IT 
C54C  A680                      LDA  ,X+           ;GET CURRENT INPUT CHAR & MOVE POINTER 
C54E  2707                      BEQ  LADB4         ;BRANCH IF END OF LINE 
C550  813A                      CMPA #':           ;CHECK FOR LINE SEPARATOR 
C552  2722                      BEQ  LADC0         ;BRANCH IF COLON 
C554  7ECA08          LADB1     JMP  LB277         ;'SYNTAX ERROR'-IF NOT LINE SEPARATOR
C557  A681            LADB4     LDA  ,X++          ;GET MS BYTE OF ADDRESS OF NEXT BASIC LINE 
C559  9700                      STA  ENDFLG        ;SAVE IN STOP/END FLAG - CAUSE A STOP IF 
                      *                            ;NEXT LINE ADDRESS IS < $8000; CAUSE 
                      *                            ;AN END IF ADDRESS > $8000 
C55B  2775                      BEQ  LAE15         ;BRANCH TO 'STOP' - END OF PROGRAM
C55D  EC80                      LDD  ,X+           ;GET CURRENT LINE NUMBER 
C55F  DD68                      STD  CURLIN        ;SAVE IN CURLIN 
C561  9F83                      STX  CHARAD        ;SAVE ADDRESS OF FIRST BYTE OF LINE 
                      * EXTENDED BASIC TRACE                      
C563  968C                      LDA  TRCFLG        ;TEST THE TRACE FLAG 
C565  270F                      BEQ  LADC0         ;BRANCH IF TRACE OFF 
C567  865B                      LDA  #$5B          ;<LEFT HAND MARKER FOR TRON LINE NUMBER 
C569  BDC017                    JSR  PUTCHR        ;OUTPUT A CHARACTER 
C56C  9668                      LDA  CURLIN        ;GET MS BYTE OF LINE NUMBER 
C56E  BDD51D                    JSR  LBDCC         ;CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN 
C571  865D                      LDA  #$5D          ;> RIGHT HAND MARKER FOR TRON LINE NUMBER 
C573  BDC017                    JSR  PUTCHR        ;OUTPUT A CHARACTER 
                      * END OF EXTENDED BASIC TRACE                      
C576  9D7C            LADC0     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C578  8D02                      BSR  LADC6         ;GO PROCESS COMMAND 
C57A  20C8                      BRA  LAD9E         ;GO BACK TO MAIN LOOP 
C57C  2729            LADC6     BEQ  LADEA         ;RETURN IF END OF LINE (RTS - was BEQ LAE40) 
C57E  4D                        TSTA               ;CHECK FOR TOKEN - BIT 7 SET (NEGATIVE) 
C57F  102A01BB                  LBPL LET           ;BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
                      *                            ;IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
C583  81FF                      CMPA #$FF          ;SECONDARY TOKEN 
C585  270F                      BEQ  SECTOK          
C587  819E                      CMPA #TOK_HIGH_EXEC   ;SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC 
C589  22C9                      BHI  LADB1         ;'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
C58B  BEC0F4                    LDX  COMVEC+3      ;GET ADDRESS OF BASIC'S COMMAND TABLE
C58E  48              LADD4     ASLA               ;X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7 
C58F  1F89                      TFR  A,B           ;SAVE COMMAND OFFSET IN ACCB 
C591  3A                        ABX                ;NON X POINTS TO COMMAND JUMP ADDR 
C592  9D7C                      JSR  GETNCH        ;GET AN INPUT CHAR 
                      *                              
                      * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
C594  6E94                      JMP  [,X]          ;GO DO A COMMAND 
C596                  SECTOK                         
                      * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS                      
                      * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE                      
C596  9D7C                      JSR  GETNCH        ;GET AN INPUT CHAR 
C598  8197                      CMPA #TOK_MID      ;TOKEN FOR "MID$" 
C59A  102714F3                  LBEQ L86D6         ;PROCESS MID$ REPLACEMENT 
C59E  7ECA08                    JMP  LB277         ;SYNTAX ERROR 
                                                     
                      *                              
                      * RESTORE                      
C5A1  9E19            RESTOR    LDX  TXTTAB        ;BEGINNING OF PROGRAM ADDRESS 
C5A3  301F                      LEAX -1,X          ;MOVE TO ONE BYTE BEFORE PROGRAM 
C5A5  9F33            LADE8     STX  DATPTR        ;SAVE NEW DATA POINTER 
C5A7  39              LADEA     RTS                  
                      *                              
                      * BREAK CHECK                      
C5A8  BDC008          LADEB     JSR  LA1C1         ;GET A KEYSTROKE ENTRY 
C5AB  270A                      BEQ  LADFA         ;RETURN IF NO INPUT 
C5AD  8103            LADF0     CMPA #3            ;CONTROL C? (BREAK) 
C5AF  2715                      BEQ  STOP          ;YES 
C5B1  8113                      CMPA #$13          ;CONTROL S? (PAUSE) 
C5B3  2703                      BEQ  LADFB         ;YES 
C5B5  9773                      STA  IKEYIM        ;SAVE KEYSTROKE IN INKEY IMAGE 
C5B7  39              LADFA     RTS                  
C5B8  BDC008          LADFB     JSR  KEYIN         ;GET A KEY 
C5BB  27FB                      BEQ  LADFB         ;BRANCH IF NO KEY DOWN 
C5BD  20EE                      BRA  LADF0         ;CONTINUE - DO A BREAK CHECK
                       IF MON09
                      *
                      * BYE ;RETURN TO MON09
C5BF  7EE47C          BYE       JMP  MON09_RESET  ;RESET TO MON09
                       ENDIF
                      
                      *                              
                      * END                          
C5C2  9D82            END       JSR  GETCCH        ;GET CURRENT INPUT CHAR 
C5C4  2002                      BRA  LAE0B           
                      *                              
                      * STOP                         
C5C6  1A01            STOP      ORCC #$01          ;SET CARRY FLAG 
C5C8  2631            LAE0B     BNE  LAE40         ;BRANCH IF ARGUMENT EXISTS 
C5CA  9E83                      LDX  CHARAD        ;* SAVE CURRENT POSITION OF 
C5CC  9F2F                      STX  TINPTR        ;* BASIC'S INPUT POINTER
C5CE  0600            LAE11     ROR  ENDFLG        ;ROTATE CARRY INTO BIT 7 OF STOP/END FLAG 
C5D0  3262                      LEAS 2,S           ;PURGE RETURN ADDRESS OFF STACK 
C5D2  9E68            LAE15     LDX  CURLIN        ;GET CURRENT LINE NUMBER 
C5D4  8CFFFF                    CMPX #$FFFF        ;DIRECT MODE? 
C5D7  2706                      BEQ  LAE22         ;YES 
C5D9  9F29                      STX  OLDTXT        ;SAVE CURRENT LINE NUMBER 
C5DB  9E2F                      LDX  TINPTR        ;* GET AND SAVE CURRENT POSITION 
C5DD  9F2D                      STX  OLDPTR        ;* OF BASIC'S INPUT POINTER
C5DF                  LAE22                          
C5DF  8EC3B3                    LDX  #LABF2-1      ;POINT TO CR, 'BREAK' MESSAGE
C5E2  0D00                      TST  ENDFLG        ;CHECK STOP/END FLAG 
C5E4  102AFE3F                  LBPL LAC73         ;BRANCH TO MAIN LOOP OF BASIC IF END 
C5E8  7EC41C                    JMP  LAC68         ;PRINT 'BREAK AT ####' AND GO TO
                      *                            ;BASIC'S MAIN LOOP IF 'STOP'
                                                     
                      * CONT                         
C5EB  260E            CONT      BNE  LAE40         ;RETURN IF ARGUMENT GIVEN 
C5ED  C620                      LDB  #2*16         ;'CAN'T CONTINUE' ERROR
C5EF  9E2D                      LDX  OLDPTR        ;GET CONTINUE ADDRESS (INPUT POINTER) 
C5F1  1027FE13                  LBEQ LAC46         ;'CN' ERROR IF CONTINUE ADDRESS = 0
C5F5  9F83                      STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C5F7  9E29                      LDX  OLDTXT        ;GET LINE NUMBER 
C5F9  9F68                      STX  CURLIN        ;RESET CURRENT LINE NUMBER 
C5FB  39              LAE40     RTS                  
                      *                              
                      * CLEAR                        
C5FC  272C            CLEAR     BEQ  LAE6F         ;BRANCH IF NO ARGUMENT 
C5FE  BDCB72                    JSR  LB3E6         ;EVALUATE ARGUMENT 
C601  3406                      PSHS B,A           ;SAVE AMOUNT OF STRING SPACE ON STACK 
C603  9E27                      LDX  MEMSIZ        ;GET CURRENT TOP OF CLEARED SPACE 
C605  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C607  270C                      BEQ  LAE5A         ;BRANCH IF NO NEW TOP OF CLEARED SPACE 
C609  BDC9FE                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
C60C  BDCEC9                    JSR  LB73D         ;EVALUATE EXPRESSlON; RETURN VALUE IN X 
C60F  301F                      LEAX -1,X          ;X = TOP OF CLEARED SPACE 
C611  9C71                      CMPX TOPRAM        ;COMPARE TO TOP OF RAM 
C613  2218                      BHI  LAE72         ;'OM' ERROR IF > TOP OF RAM
C615  1F10            LAE5A     TFR  X,D           ;ACCD = TOP OF CLEARED SPACE 
C617  A3E1                      SUBD ,S++          ;SUBTRACT OUT AMOUNT OF CLEARED SPACE 
C619  2512                      BCS  LAE72         ;'OM' ERROR IF FREE MEM < 0
C61B  1F03                      TFR  D,U           ;U = BOTTOM OF CLEARED SPACE 
C61D  83003A                    SUBD #STKBUF       ;SUBTRACT OUT STACK BUFFER 
C620  250B                      BCS  LAE72         ;'OM' ERROR IF FREE MEM < 0
C622  931B                      SUBD VARTAB        ;SUBTRACT OUT START OF VARIABLES 
C624  2507                      BCS  LAE72         ;'OM' ERROR IF FREE MEM < 0
C626  DF21                      STU  FRETOP        ;SAVE NEW BOTTOM OF CLEARED SPACE 
C628  9F27                      STX  MEMSIZ        ;SAVE NEW TOP OF CLEARED SPACE 
C62A  7EC4CC          LAE6F     JMP  LAD26         ;ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC 
C62D  7EC406          LAE72     JMP  LAC44         ;'OM' ERROR
                      *                              
                      * RUN                          
C630  9D82            RUN       JSR  GETCCH        ;* GET CURRENT INPUT CHARACTER 
C632  1027FE91                  LBEQ LAD21         ;* IF NO LINE NUMBER 
C636  BDC4CC                    JSR  LAD26         ;ERASE ALL VARIABLES 
C639  2019                      BRA  LAE9F         ;'GOTO' THE RUN ADDRESS
                      *                              
                      * GO                           
C63B  1F89            GO        TFR  A,B           ;SAVE INPUT CHARACTER IN ACCB 
C63D  9D7C            LAE88     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C63F  C1A0                      CMPB #TOK_TO       ;'TO' TOKEN
C641  2716                      BEQ  LAEA4         ;BRANCH IF GOTO 
C643  C1A1                      CMPB #TOK_SUB      ;'SUB' TOKEN
C645  2645                      BNE  LAED7         ;'SYNTAX ERROR' IF NEITHER
C647  C603                      LDB  #3            ;=ROOM FOR 6 
C649  BDC3F5                    JSR  LAC33         ;=BYTES ON STACK? 
C64C  DE83                      LDU  CHARAD        ;* SAVE CURRENT BASIC INPUT POINTER, LINE 
C64E  9E68                      LDX  CURLIN        ;* NUMBER AND SUB TOKEN ON STACK 
C650  86A1                      LDA  #TOK_SUB      ;* 
C652  3452                      PSHS U,X,A         ;* 
C654  8D03            LAE9F     BSR  LAEA4         ;GO DO A 'GOTO'
C656  7EC544                    JMP  LAD9E         ;JUMP BACK TO BASIC'S MAIN LOOP
                      * GOTO                         
C659  9D82            LAEA4     JSR  GETCCH        ;GET CURRENT INPUT CHAR 
C65B  BDC71C                    JSR  LAF67         ;GET LINE NUMBER TO BINARY IN BINVAL 
C65E  8D40                      BSR  LAEEB         ;ADVANCE BASIC'S POINTER TO END OF LINE
C660  3001                      LEAX $01,X         ;POINT TO START OF NEXT LINE 
C662  DC2B                      LDD  BINVAL        ;GET THE LINE NUMBER TO RUN 
C664  109368                    CMPD CURLIN        ;COMPARE TO CURRENT LINE NUMBER 
C667  2202                      BHI  LAEB6         ;IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
                      *              DON'T START LOOKING FROM
                      *              START OF PROGRAM  
C669  9E19                      LDX  TXTTAB        ;BEGINNING OF PROGRAM 
C66B  BDC4AB          LAEB6     JSR  LAD05         ;GO FIND A LINE NUMBER 
C66E  2517                      BCS  LAED2         ;'UNDEFINED LINE NUMBER'
C670  301F            LAEBB     LEAX -1,X          ;MOVE BACK TO JUST BEFORE START OF LINE 
C672  9F83                      STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C674  39              LAEBF     RTS                  
                      *                              
                      * RETURN                       
C675  26FD            RETURN    BNE  LAEBF         ;EXIT ROUTINE IF ARGUMENT GIVEN 
C677  86FF                      LDA  #$FF          ;* PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF 
C679  973B                      STA  VARDES        ;* VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
                      *              STACK TO BE IGNORED  
C67B  BDC3BB                    JSR  LABF9         ;CHECK FOR RETURN DATA ON THE STACK 
C67E  1F14                      TFR  X,S           ;RESET STACK POINTER - PURGE TWO RETURN ADDRESSES 
                      *              FROM THE STACK  
C680  8121                      CMPA #TOK_SUB-$80  ;SUB TOKEN - $80 
C682  270B                      BEQ  LAEDA         ;BRANCH IF 'RETURN' FROM SUBROUTINE
C684  C604                      LDB  #2*2          ;ERROR #2 'RETURN WITHOUT GOSUB'
C686  8C                        FCB  SKP2          ;SKIP TWO BYTES 
C687  C60E            LAED2     LDB  #7*2          ;ERROR #7 'UNDEFINED LINE NUMBER'
C689  7EC408                    JMP  LAC46         ;JUMP TO ERROR HANDLER 
C68C  7ECA08          LAED7     JMP  LB277         ;'SYNTAX ERROR'
C68F  3552            LAEDA     PULS A,X,U         ;* RESTORE VALUES OF CURRENT LINE NUMBER AND 
C691  9F68                      STX  CURLIN        ;* BASIC'S INPUT POINTER FOR THIS SUBROUTINE
C693  DF83                      STU  CHARAD        ;* AND LOAD ACCA WITH SUB TOKEN ($A6) 
                      *                              
                      * DATA                         
C695  8D06            DATA      BSR  LAEE8         ;MOVE INPUT POINTER TO END OF SUBLINE OR LINE 
C697  8C                        FCB  SKP2          ;SKIP 2 BYTES 
                                                     
                      * REM, ELSE                      
C698                  ELSE                           
C698  8D06            REM       BSR  LAEEB         ;MOVE INPUT POINTER TO END OF LINE 
C69A  9F83                      STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C69C  39              LAEE7     RTS                  
                      * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE                      
C69D  C63A            LAEE8     LDB  #':           ;COLON = SUBLINE TERMINATOR CHARACTER 
C69F  86              LAEEA     FCB  SKP1LD        ;SKPILD SKIP ONE BYTE; LDA #$5F 
                      * ADVANCE BASIC'S INPUT POINTER TO END OF
                      * LINE - RETURN ADDRESS OF END OF LINE+1 IN X                      
C6A0  5F              LAEEB     CLRB               ;0 = LINE TERMINATOR CHARACTER 
C6A1  D701                      STB  CHARAC        ;TEMP STORE PRIMARY TERMINATOR CHARACTER 
C6A3  5F                        CLRB               ;0 (END OF LINE) = ALTERNATE TERM. CHAR. 
C6A4  9E83                      LDX  CHARAD        ;LOAD X W/BASIC'S INPUT POINTER
C6A6  1F98            LAEF1     TFR  B,A           ;* CHANGE TERMINATOR CHARACTER 
C6A8  D601                      LDB  CHARAC        ;* FROM ACCB TO CHARAC - SAVE OLD TERMINATOR 
                      *         IN   CHARAC          
C6AA  9701                      STA  CHARAC        ;SWAP PRIMARY AND SECONDARY TERMINATORS 
C6AC  A684            LAEF7     LDA  ,X            ;GET NEXT INPUT CHARACTER 
C6AE  27EC                      BEQ  LAEE7         ;RETURN IF 0 (END OF LINE) 
C6B0  3404                      PSHS B             ;SAVE TERMINATOR ON STACK 
C6B2  A1E0                      CMPA ,S+           ;COMPARE TO INPUT CHARACTER 
C6B4  27E6                      BEQ  LAEE7         ;RETURN IF EQUAL 
C6B6  3001                      LEAX 1,X           ;MOVE POINTER UP ONE 
C6B8  8122                      CMPA #'"           ;CHECK FOR DOUBLE QUOTES 
C6BA  27EA                      BEQ  LAEF1         ;BRANCH IF " - TOGGLE TERMINATOR CHARACTERS 
C6BC  4C                        INCA               ;* CHECK FOR $FF AND BRANCH IF 
C6BD  2602                      BNE  LAF0C         ;* NOT SECONDARY TOKEN 
C6BF  3001                      LEAX 1,X           ;MOVE INPUT POINTER 1 MORE IF SECONDARY 
C6C1  8186            LAF0C     CMPA #TOK_IF+1     ;TOKEN FOR IF? 
C6C3  26E7                      BNE  LAEF7         ;NO - GET ANOTHER INPUT CHARACTER 
C6C5  0C04                      INC  IFCTR         ;INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY 
                      *                            ;'IF' STATEMENTS ARE NESTED IN ONE LINE
C6C7  20E3                      BRA  LAEF7         ;GET ANOTHER INPUT CHARACTER 
                                                     
                      * IF                           
C6C9  BDC8D2          IF        JSR  LB141         ;EVALUATE NUMERIC EXPRESSION 
C6CC  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C6CE  8181                      CMPA #TOK_GO       ;TOKEN FOR GO 
C6D0  2705                      BEQ  LAF22         ;TREAT 'GO' THE SAME AS 'THEN'
C6D2  C6A2                      LDB  #TOK_THEN     ;TOKEN FOR THEN 
C6D4  BDCA00                    JSR  LB26F         ;DO A SYNTAX CHECK ON ACCB 
C6D7  964F            LAF22     LDA  FP0EXP        ;CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO 
C6D9  2613                      BNE  LAF39         ;BRANCH IF CONDITION TRUE 
C6DB  0F04                      CLR  IFCTR         ;CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT 
                      *                            ;TO SEARCH FOR IN NESTED 'IF' LOOPS
C6DD  8DB6            LAF28     BSR  DATA          ;MOVE BASIC'S POINTER TO END OF SUBLINE
C6DF  4D                        TSTA               ;* CHECK TO SEE IF END OF LINE OR SUBLINE 
C6E0  27BA                      BEQ  LAEE7         ;* AND RETURN IF END OF LINE 
C6E2  9D7C                      JSR  GETNCH        ;GET AN INPUT CHARACTER FROM BASIC 
C6E4  8184                      CMPA #TOK_ELSE     ;TOKEN FOR ELSE 
C6E6  26F5                      BNE  LAF28         ;IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
                      *                            ;END OF LINE (ZERO BYTE) 
C6E8  0A04                      DEC  IFCTR         ;CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE 
C6EA  2AF1                      BPL  LAF28         ;BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
C6EC  9D7C                      JSR  GETNCH        ;GET AN INPUT CHARACTER FROM BASIC 
C6EE  9D82            LAF39     JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C6F0  1025FF65                  LBCS LAEA4         ;BRANCH TO 'GOTO' IF NUMERIC CHARACTER
C6F4  7EC57C                    JMP  LADC6         ;RETURN TO MAIN INTERPRETATION LOOP 
                                                     
                      * ON                           
C6F7  BDCE97          ON        JSR  LB70B         ;EVALUATE EXPRESSION 
C6FA  C681                      LDB  #TOK_GO       ;TOKEN FOR GO 
C6FC  BDCA00                    JSR  LB26F         ;SYNTAX CHECK FOR GO 
C6FF  3402                      PSHS A             ;SAVE NEW TOKEN (TO,SUB) 
C701  81A1                      CMPA #TOK_SUB      ;TOKEN FOR SUB? 
C703  2704                      BEQ  LAF54         ;YES 
C705  81A0                      CMPA #TOK_TO       ;TOKEN FOR TO? 
C707  2683            LAF52     BNE  LAED7         ;'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
C709  0A53            LAF54     DEC  FPA0+3        ;DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS 
                      *                            ;IS THE ARGUMENT OF THE 'ON' STATEMENT
C70B  2605                      BNE  LAF5D         ;BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER 
C70D  3504                      PULS B             ;GET BACK THE TOKEN FOLLOWING 'GO'
C70F  7EC63D                    JMP  LAE88         ;GO DO A 'GOTO' OR 'GOSUB'
C712  9D7C            LAF5D     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C714  8D06                      BSR  LAF67         ;CONVERT BASIC LINE NUMBER TO BINARY 
C716  812C                      CMPA #',           ;IS CHARACTER FOLLOWING LINE NUMBER A COMMA? 
C718  27EF                      BEQ  LAF54         ;YES 
C71A  3584                      PULS B,PC          ;IF NOT, FALL THROUGH TO NEXT COMMAND 
C71C  9E74            LAF67     LDX  ZERO          ;DEFAULT LINE NUMBER OF ZERO 
C71E  9F2B                      STX  BINVAL        ;SAVE IT IN BINVAL 
                      *                              
                      * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL                      
                      *                              
C720  2461            LAF6B     BCC  LAFCE         ;RETURN IF NOT NUMERIC CHARACTER 
C722  8030                      SUBA #'0           ;MASK OFF ASCII 
C724  9701                      STA  CHARAC        ;SAVE DIGIT IN VO1 
C726  DC2B                      LDD  BINVAL        ;GET ACCUMULATED LINE NUMBER VALUE 
C728  8118                      CMPA #24           ;LARGEST LINE NUMBER IS $F9FF (63999) - 
                      *         (24*256+255)*10+9                 
C72A  22DB                      BHI  LAF52         ;'SYNTAX' ERROR IF TOO BIG
                      * MULT ACCD X 10                      
C72C  58                        ASLB               ;* 
C72D  49                        ROLA               ;* TIMES 2 
C72E  58                        ASLB               ;= 
C72F  49                        ROLA               ;= TIMES 4 
C730  D32B                      ADDD BINVAL        ;ADD 1 = TIMES 5 
C732  58                        ASLB               ;* 
C733  49                        ROLA               ;* TIMES 10 
C734  DB01                      ADDB CHARAC        ;ADD NEXT DIGIT 
C736  8900                      ADCA #0            ;PROPAGATE CARRY 
C738  DD2B                      STD  BINVAL        ;SAVE NEW ACCUMULATED LINE NUMBER 
C73A  9D7C                      JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
C73C  20E2                      BRA  LAF6B         ;LOOP- PROCESS NEXT DIGIT 
                      *                              
                      * LET (EXBAS)                      
                      * EVALUATE A NON-TOKEN EXPRESSION                      
                      * TARGET = REPLACEMENT                      
C73E  BDCAE3          LET       JSR  LB357         ;FIND TARGET VARIABLE DESCRIPTOR 
C741  9F3B                      STX  VARDES        ;SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION 
C743  C6AE                      LDB  #TOK_EQUALS   ;TOKEN FOR "=" 
C745  BDCA00                    JSR  LB26F         ;DO A SYNTAX CHECK FOR '='
C748  9606                      LDA  VALTYP        ;* GET VARIABLE TYPE AND 
C74A  3402                      PSHS A             ;* SAVE ON THE STACK 
C74C  BDC8E7                    JSR  LB156         ;EVALUATE EXPRESSION 
C74F  3502                      PULS A             ;* REGET VARIABLE TYPE OF 1ST EXPRESSION AND 
C751  46                        RORA               ;* SET CARRY IF STRING 
C752  BDC8D9                    JSR  LB148         ;TYPE CHECK-TM ERROR IF VARIABLE TYPES ON 
                      *                            ;BOTH SIDES OF EQUALS SIGN NOT THE SAME 
C755  10270C2B                  LBEQ LBC33         ;GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC 
                      * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT                      
                      * FPA0+2 INTO THE STRING SPACE. TRANSFER THE                      
                      * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES                      
                      * DON'T MOVE THE STRING IF IT;IS ALREADY IN THE
                      * STRING SPACE. REMOVE DESCRIPTOR FROM STRING                      
                      * STACK IF IT IS LAST ONE ON THE STACK                      
C759  9E52            LAFA4     LDX  FPA0+2        ;POINT X TO DESCRIPTOR OF REPLACEMENT STRING 
C75B  DC21                      LDD  FRETOP        ;LOAD ACCD WITH START OF STRING SPACE 
C75D  10A302                    CMPD 2,X           ;IS THE STRING IN STRING SPACE? 
C760  2411                      BCC  LAFBE         ;BRANCH IF IT'S NOT IN THE STRING SPACE
C762  9C1B                      CMPX VARTAB        ;COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES 
C764  250D                      BCS  LAFBE         ;BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES 
C766  E684            LAFB1     LDB  ,X            ;GET LENGTH OF REPLACEMENT STRING 
C768  BDCC99                    JSR  LB50D         ;RESERVE ACCB BYTES OF STRING SPACE 
C76B  9E4D                      LDX  V4D           ;GET DESCRIPTOR ADDRESS BACK 
C76D  BDCDCF                    JSR  LB643         ;MOVE STRING INTO STRING SPACE 
C770  8E0056                    LDX  #STRDES       ;POINT X TO TEMP STRING DESCRIPTOR ADDRESS 
C773  9F4D            LAFBE     STX  V4D           ;SAVE STRING DESCRIPTOR ADDRESS IN V4D 
C775  BDCE01                    JSR  LB675         ;REMOVE STRING DESCRIPTOR IF LAST ONE 
                      *              ON STRING STACK  
C778  DE4D                      LDU  V4D           ;POINT U TO REPLACEMENT DESCRIPTOR ADDRESS 
C77A  9E3B                      LDX  VARDES        ;GET TARGET DESCRIPTOR ADDRESS 
C77C  3726                      PULU A,B,Y         ;GET LENGTH AND START OF REPLACEMENT STRING 
C77E  A784                      STA  ,X            ;* SAVE STRING LENGTH AND START IN 
C780  10AF02                    STY  2,X           ;* TARGET DESCRIPTOR LOCATION 
C783  39              LAFCE     RTS                  
                                                     
C784  3F5245444F      LAFCF     FCC  "?REDO"       ;?REDO MESSAGE 
C789  0D00                      FCB  CR,$00          
                                                     
C78B                  LAFD6                          
C78B  7EC408          LAFDC     JMP  LAC46         ;JMP TO ERROR HANDLER 
C78E  9609            LAFDF     LDA  INPFLG        ;= GET THE INPUT FLAG AND BRANCH 
C790  2707                      BEQ  LAFEA         ;= IF 'INPUT'
C792  9E31                      LDX  DATTXT        ;* GET LINE NUMBER WHERE THE ERROR OCCURRED 
C794  9F68                      STX  CURLIN        ;* AND USE IT AS THE CURRENT LINE NUMBER 
C796  7ECA08                    JMP  LB277         ;'SYNTAX ERROR'
C799  8EC783          LAFEA     LDX  #LAFCF-1      ;* POINT X TO '?REDO' AND PRINT
C79C  BDD0ED                    JSR  LB99C         ;* IT ON THE SCREEN 
C79F  9E2F                      LDX  TINPTR        ;= GET THE SAVED ABSOLUTE ADDRESS OF 
C7A1  9F83                      STX  CHARAD        ;= INPUT POINTER AND RESTORE IT 
C7A3  39                        RTS                  
                      *                              
                      * INPUT                        
C7A4  C616            INPUT     LDB  #11*2         ;'ID' ERROR
C7A6  9E68                      LDX  CURLIN        ;GET CURRENT LINE NUMBER 
C7A8  3001                      LEAX 1,X           ;ADD ONE 
C7AA  27DF                      BEQ  LAFDC         ;'ID' ERROR BRANCH IF DIRECT MODE
C7AC  8D01                      BSR  LB00F         ;GET SOME INPUT DATA - WAS LB002 
C7AE  39                        RTS                  
C7AF  8122            LB00F     CMPA #'"           ;CHECK FOR PROMPT STRING DELIMITER 
C7B1  260B                      BNE  LB01E         ;BRANCH IF NO PROMPT STRING 
C7B3  BDC9D5                    JSR  LB244         ;PUT PROMPT STRING ON STRING STACK 
C7B6  C63B                      LDB  #';           ;* 
C7B8  BDCA00                    JSR  LB26F         ;* DO A SYNTAX CHECK FOR SEMICOLON 
C7BB  BDD0F0                    JSR  LB99F         ;PRINT MESSAGE TO CONSOLE OUT 
C7BE  8E00F3          LB01E     LDX  #LINBUF       ;POINT TO BASIC'S LINE BUFFER
C7C1  6F84                      CLR  ,X            ;CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA 
                      *              IN LINE BUFFER  
C7C3  8D06                      BSR  LB02F         ;INPUT A STRING TO LINE BUFFER 
C7C5  C62C                      LDB  #',           ;* INSERT A COMMA AT THE END 
C7C7  E784                      STB  ,X            ;* OF THE LINE INPUT BUFFER 
C7C9  2016                      BRA  LB049           
                      * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
C7CB  BDD100          LB02F     JSR  LB9AF         ;SEND A "?" TO CONSOLE OUT 
C7CE  BDD0FD                    JSR  LB9AC         ;SEND A 'SPACE' TO CONSOLE OUT
C7D1  BDC141          LB035     JSR  LA390         ;GO READ IN A BASIC LINE 
C7D4  2405                      BCC  LB03F         ;BRANCH IF ENTER KEY ENDED ENTRY 
C7D6  3264                      LEAS 4,S           ;PURGE TWO RETURN ADDRESSES OFF THE STACK 
C7D8  7EC5CE                    JMP  LAE11         ;GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
C7DB  C62E            LB03F     LDB  #2*23         ;'INPUT PAST END OF FILE' ERROR
C7DD  39                        RTS                  
                      *                              
                      * READ                         
C7DE  9E33            READ      LDX  DATPTR        ;GET 'READ' START ADDRESS
C7E0  86                        FCB  SKP1LD        ;SKIP ONE BYTE - LDA #*$4F 
C7E1  4F              LB049     CLRA               ;'INPUT' ENTRY POINT: INPUT FLAG = 0
C7E2  9709                      STA  INPFLG        ;SET INPUT FLAG; 0 = INPUT: <> 0 = READ 
C7E4  9F35                      STX  DATTMP        ;SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
C7E6  BDCAE3          LB04E     JSR  LB357         ;EVALUATE A VARIABLE 
C7E9  9F3B                      STX  VARDES        ;SAVE DESCRIPTOR ADDRESS 
C7EB  9E83                      LDX  CHARAD        ;* GET BASIC'S INPUT POINTER
C7ED  9F2B                      STX  BINVAL        ;* AND SAVE IT 
C7EF  9E35                      LDX  DATTMP        ;GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
C7F1  A684                      LDA  ,X            ;GET A CHARACTER FROM THE BASIC PROGRAM 
C7F3  2609                      BNE  LB069         ;BRANCH IF NOT END OF LINE 
C7F5  9609                      LDA  INPFLG        ;* CHECK INPUT FLAG AND BRANCH 
C7F7  2651                      BNE  LB0B9         ;* IF LOOKING FOR DATA (READ) 
                      * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
                      * NOT COMING FROM SCREEN                      
C7F9  BDD100                    JSR  LB9AF         ;SEND A '?' TO CONSOLE OUT 
C7FC  8DCD                      BSR  LB02F         ;FILL INPUT BUFFER FROM CONSOLE IN 
C7FE  9F83            LB069     STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C800  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
C802  D606                      LDB  VALTYP        ;* CHECK VARIABLE TYPE AND 
C804  2723                      BEQ  LB098         ;* BRANCH IF NUMERIC 
                      * READ/INPUT A STRING VARIABLE                      
C806  9E83                      LDX  CHARAD        ;LOAD X WITH CURRENT BASIC INPUT POINTER 
C808  9701                      STA  CHARAC        ;SAVE CURRENT INPUT CHARACTER 
C80A  8122                      CMPA #'"           ;CHECK FOR STRING DELIMITER 
C80C  270E                      BEQ  LB08B         ;BRANCH IF STRING DELIMITER 
C80E  301F                      LEAX -1,X          ;BACK UP POINTER 
C810  4F                        CLRA               ;* ZERO = END OF LINE CHARACTER 
C811  9701                      STA  CHARAC        ;* SAVE AS TERMINATOR 
C813  BDC133                    JSR  LA35F         ;SET UP PRINT PARAMETERS 
C816  863A                      LDA  #':           ;END OF SUBLINE CHARACTER 
C818  9701                      STA  CHARAC        ;SAVE AS TERMINATOR I 
C81A  862C                      LDA  #',           ;COMMA 
C81C  9702            LB08B     STA  ENDCHR        ;SAVE AS TERMINATOR 2 
C81E  BDCCAA                    JSR  LB51E         ;STRIP A STRING FROM THE INPUT BUFFER 
C821  BDC9DA                    JSR  LB249         ;MOVE INPUT POINTER TO END OF STRING 
C824  BDC759                    JSR  LAFA4         ;PUT A STRING INTO THE STRING SPACE IF NECESSARY 
C827  2006                      BRA  LB09E         ;CHECK FOR ANOTHER DATA ITEM 
                      * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM                      
C829  BDD463          LB098     JSR  LBD12         ;CONVERT AN ASCII STRING TO FP NUMBER 
C82C  BDD384                    JSR  LBC33         ;PACK FPA0 AND STORE IT IN ADDRESS IN VARDES - 
                      *                            ;INPUT OR READ DATA ITEM 
C82F  9D82            LB09E     JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C831  2706                      BEQ  LB0A8         ;BRANCH IF END OF LINE 
C833  812C                      CMPA #',           ;CHECK FOR A COMMA 
C835  1026FF52                  LBNE LAFD6         ;BAD FILE DATA' ERROR OR RETRY 
C839  9E83            LB0A8     LDX  CHARAD        ;* GET CURRENT INPUT 
C83B  9F35                      STX  DATTMP        ;* POINTER (USED AS A DATA POINTER) AND SAVE IT 
C83D  9E2B                      LDX  BINVAL        ;* RESET INPUT POINTER TO INPUT OR 
C83F  9F83                      STX  CHARAD        ;* READ STATEMENT 
C841  9D82                      JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
C843  2721                      BEQ  LB0D5         ;BRANCH IF END OF LINE - EXIT COMMAND 
C845  BDC9FE                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
C848  209C                      BRA  LB04E         ;GET ANOTHER INPUT OR READ ITEM 
                      * SEARCH FROM ADDRESS IN X FOR                      
                      * 1ST OCCURENCE OF THE TOKEN FOR DATA                      
C84A  9F83            LB0B9     STX  CHARAD        ;RESET BASIC'S INPUT POINTER
C84C  BDC69D                    JSR  LAEE8         ;SEARCH FOR END OF CURRENT LINE OR SUBLINE 
C84F  3001                      LEAX 1,X           ;MOVE X ONE PAST END OF LINE 
C851  4D                        TSTA               ;CHECK FOR END OF LINE 
C852  260A                      BNE  LB0CD         ;BRANCH IF END OF SUBLINE 
C854  C606                      LDB  #2*3          ;'OUT OF DATA' ERROR
C856  EE81                      LDU  ,X++          ;GET NEXT 2 CHARACTERS 
C858  2741                      BEQ  LB10A         ;'OD' ERROR IF END OF PROGRAM
C85A  EC81                      LDD  ,X++          ;GET BASIC LINE NUMBER AND 
C85C  DD31                      STD  DATTXT        ;SAVE IT IN DATTXT 
C85E  A684            LB0CD     LDA  ,X            ;GET AN INPUT CHARACTER 
C860  8186                      CMPA #TOK_DATA     ;DATA TOKEN? 
C862  26E6                      BNE  LB0B9         ;NO ' KEEP LOOKING
C864  2098                      BRA  LB069         ;YES 
                      * EXIT READ AND INPUT COMMANDS                      
C866  9E35            LB0D5     LDX  DATTMP        ;GET DATA POINTER 
C868  D609                      LDB  INPFLG        ;* CHECK INPUT FLAG 
C86A  1026FD37                  LBNE LADE8         ;* SAVE NEW DATA POINTER IF READ 
C86E  A684                      LDA  ,X            ;= CHECK NEXT CHARACTER IN 'INPUT' BUFFER
C870  2706                      BEQ  LB0E7         ;= 
C872  8EC878                    LDX  #LB0E8-1      ;POINT X TO '?EXTRA IGNORED'
C875  7ED0ED                    JMP  LB99C         ;PRINT THE MESSAGE 
C878  39              LB0E7     RTS                  
                                                     
C879  3F45585452412049474E4F524544 LB0E8     FCC  "?EXTRA IGNORED" ;?EXTRA IGNORED MESSAGE 
                                                     
                                                     
C887  0D00                      FCB  CR,$00          
                                                     
                      * NEXT                         
C889  2604            NEXT      BNE  LB0FE         ;BRANCH IF ARGUMENT GIVEN 
C88B  9E74                      LDX  ZERO          ;X = 0: DEFAULT FOR NO ARGUMENT 
C88D  2003                      BRA  LB101           
C88F  BDCAE3          LB0FE     JSR  LB357         ;EVALUATE AN ALPHA EXPRESSION 
C892  9F3B            LB101     STX  VARDES        ;SAVE VARIABLE DESCRIPTOR POINTER 
C894  BDC3BB                    JSR  LABF9         ;GO SCAN FOR 'FOR/NEXT' DATA ON STACK
C897  2704                      BEQ  LB10C         ;BRANCH IF DATA FOUND 
C899  C600                      LDB  #0            ;'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
C89B  2047            LB10A     BRA  LB153         ;PROCESS ERROR 
C89D  1F14            LB10C     TFR  X,S           ;POINT S TO START OF 'FOR/NEXT' DATA
C89F  3003                      LEAX 3,X           ;POINT X TO FP VALUE OF STEP 
C8A1  BDD365                    JSR  LBC14         ;COPY A FP NUMBER FROM (X) TO FPA0 
C8A4  A668                      LDA  8,S           ;GET THE DIRECTION OF STEP 
C8A6  9754                      STA  FP0SGN        ;SAVE IT AS THE SIGN OF FPA0 
C8A8  9E3B                      LDX  VARDES        ;POINT (X) TO INDEX VARIABLE DESCRIPTOR 
C8AA  BDD113                    JSR  LB9C2         ;ADD (X) TO FPA0 (STEP TO INDEX) 
C8AD  BDD384                    JSR  LBC33         ;PACK FPA0 AND STORE IT IN ADDRESS 
                      *                            ;CONTAINED IN VARDES 
C8B0  3069                      LEAX 9,S           ;POINT (X) TO TERMINAL VALUE OF INDEX 
C8B2  BDD3E7                    JSR  LBC96         ;COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX 
C8B5  E068                      SUBB 8,S           ;ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF 
                      *                            ;STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR 
                      *                            ;STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE 
C8B7  270C                      BEQ  LB134         ;BRANCH IF 'FOR/NEXT' LOOP DONE
C8B9  AE6E                      LDX  14,S          ;* GET LINE NUMBER AND 
C8BB  9F68                      STX  CURLIN        ;* BASIC POINTER OF 
C8BD  AEE810                    LDX  16,S          ;* STATEMENT FOLLOWING THE 
C8C0  9F83                      STX  CHARAD        ;* PROPER FOR STATEMENT 
C8C2  7EC544          LB131     JMP  LAD9E         ;JUMP BACK TO COMMAND INTEPR. LOOP 
C8C5  32E812          LB134     LEAS 18,S          ;PULL THE 'FOR-NEXT' DATA OFF THE STACK
C8C8  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
C8CA  812C                      CMPA #',           ;CHECK FOR ANOTHER ARGUMENT 
C8CC  26F4                      BNE  LB131         ;RETURN IF NONE 
C8CE  9D7C                      JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
C8D0  8DBD                      BSR  LB0FE         ;BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
                                                     
                                                     
C8D2  8D13            LB141     BSR  LB156         ;EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC 
C8D4  1CFE            LB143     ANDCC #$FE         ;CLEAR CARRY FLAG 
C8D6  7D              LB145     FCB  $7D           ;OP CODE OF TST $1A01 - SKIP TWO BYTES (DO 
                      *              NOT CHANGE CARRY FLAG)  
C8D7  1A01            LB146     ORCC #1            ;SET CARRY 
                                                     
                      * STRING TYPE MODE CHECK - IF;ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR                      
                      * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR                      
                      * IF ENTERED AT LB148, A TYPE;CHECK IS DONE ON VALTYP                      
                      * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC                      
                      * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.                      
C8D9  0D06            LB148     TST  VALTYP        ;TEST TYPE FLAG; DO NOT CHANGE CARRY 
C8DB  2503                      BCS  LB14F         ;BRANCH IF STRING 
C8DD  2A99                      BPL  LB0E7         ;RETURN ON PLUS 
C8DF  8C                        FCB  SKP2          ;SKIP 2 BYTES - 'TM' ERROR
C8E0  2B96            LB14F     BMI  LB0E7         ;RETURN ON MINUS 
C8E2  C618                      LDB  #12*2         ;'TYPE M1SMATCH' ERROR
C8E4  7EC408          LB153     JMP  LAC46         ;PROCESS ERROR 
                      * EVALUATE EXPRESSION                      
C8E7  8D6E            LB156     BSR  LB1C6         ;BACK UP INPUT POINTER 
C8E9  4F              LB158     CLRA               ;END OF OPERATION PRECEDENCE FLAG 
C8EA  8C                        FCB  SKP2          ;SKIP TWO BYTES 
C8EB  3404            LB15A     PSHS B             ;SAVE FLAG (RELATIONAL OPERATOR FLAG) 
C8ED  3402                      PSHS A             ;SAVE FLAG (PRECEDENCE FLAG) 
C8EF  C601                      LDB  #1            ;* 
C8F1  BDC3F5                    JSR  LAC33         ;* SEE IF ROOM IN FREE RAM FOR (B) WORDS 
C8F4  BDC9B4                    JSR  LB223         ;GO EVALUATE AN EXPRESSION 
C8F7  0F3F                      CLR  TRELFL        ;RESET RELATIONAL OPERATOR FLAG 
C8F9  9D82            LB168     JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
                      * CHECK FOR RELATIONAL OPERATORS                      
C8FB  80AD            LB16A     SUBA #TOK_GREATER  ;TOKEN FOR > 
C8FD  2513                      BCS  LB181         ;BRANCH IF LESS THAN RELATIONAL OPERATORS 
C8FF  8103                      CMPA #3            ;* 
C901  240F                      BCC  LB181         ;* BRANCH IF GREATER THAN RELATIONAL OPERATORS 
C903  8101                      CMPA #1            ;SET CARRY IF '>'
C905  49                        ROLA               ;CARRY TO BIT 0 
C906  983F                      EORA TRELFL        ;* CARRY SET IF 
C908  913F                      CMPA TRELFL        ;* TRELFL = ACCA 
C90A  2564                      BCS  LB1DF         ;BRANCH IF SYNTAX ERROR : == << OR >> 
C90C  973F                      STA  TRELFL        ;BIT 0: >, BIT 1 =, BIT 2: < 
C90E  9D7C                      JSR  GETNCH        ;GET AN INPUT CHARACTER 
C910  20E9                      BRA  LB16A         ;CHECK FOR ANOTHER RELATIONAL OPERATOR 
                      *                              
C912  D63F            LB181     LDB  TRELFL        ;GET RELATIONAL OPERATOR FLAG 
C914  2633                      BNE  LB1B8         ;BRANCH IF RELATIONAL COMPARISON 
C916  1024006B                  LBCC LB1F4         ;BRANCH IF > RELATIONAL OPERATOR 
C91A  8B07                      ADDA #7            ;SEVEN ARITHMETIC/LOGICAL OPERATORS 
C91C  2467                      BCC  LB1F4         ;BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR 
C91E  9906                      ADCA VALTYP        ;ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER 
C920  10270477                  LBEQ LB60F         ;BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
                      *                            ;CONCATENATE TWO STRINGS 
C924  89FF                      ADCA #-1           ;RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER 
C926  3402                      PSHS A             ;* STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2 
C928  48                        ASLA               ;* THEN ADD THE STORED STACK DATA = MULTIPLY 
C929  ABE0                      ADDA ,S+           ;* X 3; 3 BYTE/TABLE ENTRY 
C92B  8EC20B                    LDX  #LAA51        ;JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS 
C92E  3086                      LEAX A,X           ;POINT X TO PROPER TABLE 
C930  3502            LB19F     PULS A             ;GET PRECEDENCE FLAG FROM STACK 
C932  A184                      CMPA ,X            ;COMPARE TO CURRENT OPERATOR 
C934  2455                      BCC  LB1FA         ;BRANCH IF STACK OPERATOR > CURRENT OPERATOR 
C936  8D9C                      BSR  LB143         ;'TM' ERROR IF VARIABLE TYPE = STRING
                                                     
                      * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.                      
C938  3402            LB1A7     PSHS A             ;SAVE PRECEDENCE FLAG 
C93A  8D29                      BSR  LB1D4         ;PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK 
C93C  9E3D                      LDX  RELPTR        ;GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR 
                      *                            ;LAST CALCULATED OPERATION 
C93E  3502                      PULS A             ;GET PRECEDENCE FLAG OF PREVIOUS OPERATION 
C940  261D                      BNE  LB1CE         ;BRANCH IF NOT END OF OPERATION 
C942  4D                        TSTA               ;CHECK TYPE OF PRECEDENCE FLAG 
C943  1027006A                  LBEQ LB220         ;BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION 
C947  204B                      BRA  LB203         ;EVALUATE AN OPERATION 
                                                     
C949  0806            LB1B8     ASL  VALTYP        ;BIT 7 OF TYPE FLAG TO CARRY 
C94B  59                        ROLB               ;SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0 
C94C  8D09                      BSR  LB1C6         ;MOVE THE INPUT POINTER BACK ONE 
C94E  8EC95C                    LDX  #LB1CB        ;POINT X TO RELATIONAL COMPARISON JUMP TABLE 
C951  D73F                      STB  TRELFL        ;SAVE RELATIONAL COMPARISON DATA 
C953  0F06                      CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
C955  20D9                      BRA  LB19F         ;PERFORM OPERATION OR SAVE ON STACK 
                                                     
C957  9E83            LB1C6     LDX  CHARAD        ;* GET BASIC'S INPUT POINTER AND
C959  7EC670                    JMP  LAEBB         ;* MOVE IT BACK ONE 
                      * RELATIONAL COMPARISON JUMP TABLE                      
C95C  64              LB1CB     FCB  $64           ;RELATIONAL COMPARISON FLAG 
C95D  CA80            LB1CC     FDB  LB2F4         ;JUMP ADDRESS 
                                                     
C95F  A184            LB1CE     CMPA ,X            ;COMPARE PRECEDENCE OF LAST DONE OPERATION TO 
                      *         NEXT TO BE DONE OPERATION  
C961  2431                      BCC  LB203         ;EVALUATE OPERATION IF LOWER PRECEDENCE 
C963  20D3                      BRA  LB1A7         ;PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE 
                                                     
                      * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR                      
C965  EC01            LB1D4     LDD  1,X           ;GET ADDRESS OF OPERATOR ROUTINE 
C967  3406                      PSHS B,A           ;SAVE IT ON THE STACK 
C969  8D08                      BSR  LB1E2         ;PUSH FPA0 ONTO STACK 
C96B  D63F                      LDB  TRELFL        ;GET BACK RELATIONAL OPERATOR FLAG 
C96D  16FF7B                    LBRA LB15A         ;EVALUATE ANOTHER EXPRESSION 
C970  7ECA08          LB1DF     JMP  LB277         ;'SYNTAX ERROR'
                      * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT      
                      * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA  
                      * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA  
C973  D654            LB1E2     LDB  FP0SGN        ;GET SIGN OF FPA0 MANTISSA 
C975  A684                      LDA  ,X            ;GET PRECEDENCE CODE TO ACCA 
C977  3520            LB1E6     PULS Y             ;GET RETURN ADDRESS FROM STACK & PUT IT IN Y 
C979  3404                      PSHS B             ;SAVE ACCB ON STACK 
C97B  D64F            LB1EA     LDB  FP0EXP        ;* PUSH FPA0 ONTO THE STACK 
C97D  9E50                      LDX  FPA0          ;* 
C97F  DE52                      LDU  FPA0+2        ;* 
C981  3454                      PSHS U,X,B         ;* 
C983  6EA4                      JMP  ,Y            ;JUMP TO ADDRESS IN Y 
                                                     
                      * BRANCH HERE IF NON-OPERATOR;CHARACTER FOUND - USUALLY ')' OR END OF LINE
C985  9E74            LB1F4     LDX  ZERO          ;POINT X TO DUMMY VALUE (ZERO) 
C987  A6E0                      LDA  ,S+           ;GET PRECEDENCE FLAG FROM STACK 
C989  2726                      BEQ  LB220         ;BRANCH IF END OF EXPRESSION 
C98B  8164            LB1FA     CMPA #$64          ;* CHECK FOR RELATIONAL COMPARISON FLAG 
C98D  2703                      BEQ  LB201         ;* AND BRANCH IF RELATIONAL COMPARISON 
C98F  BDC8D4                    JSR  LB143         ;'TM' ERROR IF VARIABLE TYPE = STRING
C992  9F3D            LB201     STX  RELPTR        ;SAVE POINTER TO OPERATOR ROUTINE 
C994  3504            LB203     PULS B             ;GET RELATIONAL OPERATOR FLAG FROM STACK 
C996  815A                      CMPA #$5A          ;CHECK FOR 'NOT' OPERATOR
C998  2719                      BEQ  LB222         ;RETURN IF 'NOT' - NO RELATIONAL COMPARISON
C99A  817D                      CMPA #$7D          ;CHECK FOR NEGATION (UNARY) FLAG 
C99C  2715                      BEQ  LB222         ;RETURN IF NEGATION - NO RELATIONAL COMPARISON 
                                                     
                      * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES                      
                      * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH                      
                      * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR                      
                      * TO EVALUATING ROUTINE.                      
C99E  54                        LSRB               ;= ROTATE VALTYP BIT INTO CARRY 
C99F  D70A                      STB  RELFLG        ;= FLAG AND SAVE NEW RELFLG 
C9A1  3552                      PULS A,X,U         ;* PULL A FP VALUE OFF OF THE STACK 
C9A3  975C                      STA  FP1EXP        ;* AND SAVE IT IN FPA1 
C9A5  9F5D                      STX  FPA1          ;* 
C9A7  DF5F                      STU  FPA1+2        ;* 
C9A9  3504                      PULS B             ;= GET MANTISSA SIGN AND 
C9AB  D761                      STB  FP1SGN        ;= SAVE IT IN FPA1 
C9AD  D854                      EORB FP0SGN        ;EOR IT WITH FPA1 MANTISSA SIGN 
C9AF  D762                      STB  RESSGN        ;SAVE IT IN RESULT SIGN BYTE 
C9B1  D64F            LB220     LDB  FP0EXP        ;GET EXPONENT OF FPA0 
C9B3  39              LB222     RTS                  
                                                     
C9B4  BDDC01          LB223     JSR  XVEC15        ;CALL EXTENDED BASIC ADD-IN 
C9B7  0F06                      CLR  VALTYP        ;INITIALIZE TYPE FLAG TO NUMERIC 
C9B9  9D7C                      JSR  GETNCH        ;GET AN INPUT CHAR 
C9BB  2403                      BCC  LB22F         ;BRANCH IF NOT NUMERIC 
C9BD  7ED463          LB22C     JMP  LBD12         ;CONVERT ASCII STRING TO FLOATING POINT - 
                      *         RETURN RESULT IN FPA0  
                      * PROCESS A NON NUMERIC FIRST;CHARACTER                      
C9C0  BDCB2E          LB22F     JSR  LB3A2         ;SET CARRY IF NOT ALPHA 
C9C3  2450                      BCC  LB284         ;BRANCH IF ALPHA CHARACTER 
C9C5  812E                      CMPA #'.           ;IS IT '.' (DECIMAL POINT)?
C9C7  27F4                      BEQ  LB22C         ;CONVERT ASCII STRING TO FLOATING POINT 
C9C9  81A7                      CMPA #TOK_MINUS    ;MINUS TOKEN 
C9CB  2740                      BEQ  LB27C         ;YES - GO PROCESS THE MINUS OPERATOR 
C9CD  81A6                      CMPA #TOK_PLUS     ;PLUS TOKEN 
C9CF  27E3                      BEQ  LB223         ;YES - GET ANOTHER CHARACTER 
C9D1  8122                      CMPA #'"           ;STRING DELIMITER? 
C9D3  260A                      BNE  LB24E         ;NO 
C9D5  9E83            LB244     LDX  CHARAD        ;CURRENT BASIC POINTER TO X 
C9D7  BDCCA4                    JSR  LB518         ;SAVE STRING ON STRING STACK 
C9DA  9E64            LB249     LDX  COEFPT        ;* GET ADDRESS OF END OF STRING AND 
C9DC  9F83                      STX  CHARAD        ;* PUT BASIC'S INPUT POINTER THERE
C9DE  39                        RTS                  
C9DF  81A3            LB24E     CMPA #TOK_NOT      ;NOT TOKEN? 
C9E1  260D                      BNE  LB25F         ;NO 
                      * PROCESS THE NOT OPERATOR                      
C9E3  865A                      LDA  #$5A          ;'NOT' PRECEDENCE FLAG
C9E5  BDC8EB                    JSR  LB15A         ;PROCESS OPERATION FOLLOWING 'NOT'
C9E8  BDCB79                    JSR  INTCNV        ;CONVERT FPA0 TO INTEGER IN ACCD 
C9EB  43                        COMA               ;* 'NOT' THE INTEGER
C9EC  53                        COMB               ;* 
C9ED  7ECC80                    JMP  GIVABF        ;CONVERT ACCD TO FLOATING POINT (FPA0) 
C9F0  4C              LB25F     INCA               ;CHECK FOR TOKENS PRECEEDED BY $FF 
C9F1  272E                      BEQ  LB290         ;IT WAS PRECEEDED BY $FF 
C9F3  8D06            LB262     BSR  LB26A         ;SYNTAX CHECK FOR A '('
C9F5  BDC8E7                    JSR  LB156         ;EVALUATE EXPRESSIONS WITHIN PARENTHESES AT 
                      *         HIGHEST PRECEDENCE      
C9F8  C629            LB267     LDB  #')           ;SYNTAX CHECK FOR ')'
C9FA  8C                        FCB  SKP2          ;SKIP 2 BYTES 
C9FB  C628            LB26A     LDB  #'(           ;SYNTAX CHECK FOR '('
C9FD  8C                        FCB  SKP2          ;SKIP 2 BYTES 
C9FE  C62C            LB26D     LDB  #',           ;SYNTAX CHECK FOR COMMA 
CA00  E19F0083        LB26F     CMPB [CHARAD]      ;* COMPARE ACCB TO CURRENT INPUT 
CA04  2602                      BNE  LB277         ;* CHARACTER - SYNTAX ERROR IF NO MATCH 
CA06  0E7C                      JMP  GETNCH        ;GET A CHARACTER FROM BASIC 
CA08  C602            LB277     LDB  #2*1          ;SYNTAX ERROR 
CA0A  7EC408                    JMP  LAC46         ;JUMP TO ERROR HANDLER 
                                                     
                      * PROCESS THE MINUS (UNARY) OPERATOR                      
CA0D  867D            LB27C     LDA  #$7D          ;MINUS (UNARY) PRECEDENCE FLAG 
CA0F  BDC8EB                    JSR  LB15A         ;PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
CA12  7ED63A                    JMP  LBEE9         ;CHANGE SIGN OF FPA0 MANTISSA 
                                                     
                      * EVALUATE ALPHA EXPRESSION                      
CA15  BDCAE3          LB284     JSR  LB357         ;FIND THE DESCRIPTOR ADDRESS OF A VARIABLE 
CA18  9F52            LB287     STX  FPA0+2        ;SAVE DESCRIPTOR ADDRESS IN FPA0 
CA1A  9606                      LDA  VALTYP        ;TEST VARIABLE TYPE 
CA1C  2695                      BNE  LB222         ;RETURN IF STRING 
CA1E  7ED365                    JMP  LBC14         ;COPY A FP NUMBER FROM (X) TO FPA0 
                                                     
                      * EVALUATING A SECONDARY TOKEN                      
CA21  9D7C            LB290     JSR  GETNCH        ;GET AN INPUT CHARACTER (SECONDARY TOKEN) 
CA23  1F89                      TFR  A,B           ;SAVE IT IN ACCB 
CA25  58                        ASLB               ;X2 & BET RID OF BIT 7 
CA26  9D7C                      JSR  GETNCH        ;GET ANOTHER INPUT CHARACTER 
CA28  C138                      CMPB #(NUM_SEC_FNS-1)*2 ;29 SECONDARY FUNCTIONS - 1 
CA2A  2303                      BLS  LB29F         ;BRANCH IF COLOR BASIC TOKEN 
CA2C  7ECA08                    JMP  LB277         ;SYNTAX ERROR 
CA2F  3404            LB29F     PSHS B             ;SAVE TOKEN OFFSET ON STACK 
CA31  C12A                      CMPB #(TOK_LEFT-$80)*2 ;CHECK FOR TOKEN WITH AN ARGUMENT 
CA33  251E                      BCS  LB2C7         ;DO SECONDARIES STRING$ OR LESS 
CA35  C130                      CMPB #(TOK_INKEY-$80)*2 ;* 
CA37  241C                      BCC  LB2C9         ;* DO SECONDARIES $92 (INKEY$) OR > 
CA39  8DC0                      BSR  LB26A         ;SYNTAX CHECK FOR A '('
CA3B  A6E4                      LDA  ,S            ;GET TOKEN NUMBER 
                      * DO SECONDARIES (LEFT$, RIGHT$, MID$)                      
CA3D  BDC8E7                    JSR  LB156         ;EVALUATE FIRST STRING IN ARGUMENT 
CA40  8DBC                      BSR  LB26D         ;SYNTAX CHECK FOR A COMMA 
CA42  BDC8D7                    JSR  LB146         ;'TM' ERROR IF NUMERIC VARiABLE
CA45  3502                      PULS A             ;GET TOKEN OFFSET FROM STACK 
CA47  DE52                      LDU  FPA0+2        ;POINT U TO STRING DESCRIPTOR 
CA49  3442                      PSHS U,A           ;SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS 
CA4B  BDCE97                    JSR  LB70B         ;EVALUATE FIRST NUMERIC ARGUMENT 
CA4E  3502                      PULS A             ;GET TOKEN OFFSET FROM STACK 
CA50  3406                      PSHS B,A           ;SAVE TOKEN OFFSET AND NUMERIC ARGUMENT 
CA52  8E                        FCB  $8E           ;OP CODE OF LDX# - SKlP 2 BYTES 
CA53  8D9E            LB2C7     BSR  LB262         ;SYNTAX CHECK FOR A '('
CA55  3504            LB2C9     PULS B             ;GET TOKEN OFFSET 
CA57  BEC0F9                    LDX  COMVEC+8      ;GET SECONDARY FUNCTION JUMP TABLE ADDRESS 
CA5A  3A              LB2CE     ABX                ;ADD IN COMMAND OFFSET 
                      *                              
                      * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION                      
CA5B  AD94                      JSR  [,X]          ;GO DO AN SECONDARY FUNCTION 
CA5D  7EC8D4                    JMP  LB143         ;'TM' ERROR IF VARIABLE TYPE = STRING
                                                     
                      * LOGICAL OPERATOR 'OR' JUMPS;HERE
CA60  86              LB2D4     FCB  SKP1LD        ;SKIP ONE BYTE - 'OR' FLAG = $4F
                                                     
                      * LOGICAL OPERATOR 'AND' JUMPS HERE
CA61  4F              LB2D5     CLRA               ;AND FLAG = 0 
CA62  9703                      STA  TMPLOC        ;AND/OR FLAG 
CA64  BDCB79                    JSR  INTCNV        ;CONVERT FPA0 INTO AN INTEGER IN ACCD 
CA67  DD01                      STD  CHARAC        ;TEMP SAVE ACCD 
CA69  BDD39B                    JSR  LBC4A         ;MOVE FPA1 TO FPA0 
CA6C  BDCB79                    JSR  INTCNV        ;CONVERT FPA0 INTO AN INTEGER IN ACCD 
CA6F  0D03                      TST  TMPLOC        ;CHECK AND/OR FLAG 
CA71  2606                      BNE  LB2ED         ;BRANCH IF OR 
CA73  9401                      ANDA CHARAC        ;* 'AND' ACCD WITH FPA0 INTEGER
CA75  D402                      ANDB ENDCHR        ;* STORED IN ENDCHR 
CA77  2004                      BRA  LB2F1         ;CONVERT TO FP 
CA79  9A01            LB2ED     ORA  CHARAC        ;* 'OR' ACCD WITH FPA0 INTEGER
CA7B  DA02                      ORB  ENDCHR        ;* STORED IN CHARAC 
CA7D  7ECC80          LB2F1     JMP  GIVABF        ;CONVERT THE VALUE IN ACCD INTO A FP NUMBER 
                                                     
                      * RELATIONAL COMPARISON PROCESS HANDLER                      
CA80  BDC8D9          LB2F4     JSR  LB148         ;'TM' ERROR IF TYPE MISMATCH
CA83  2610                      BNE  LB309         ;BRANCH IF STRING VARIABLE 
CA85  9661                      LDA  FP1SGN        ;* 'PACK' THE MANTISSA
CA87  8A7F                      ORA  #$7F          ;* SIGN OF FPA1 INTO 
CA89  945D                      ANDA FPA1          ;* BIT 7 OF THE 
CA8B  975D                      STA  FPA1          ;* MANTISSA MS BYTE 
CA8D  8E005C                    LDX  #FP1EXP       ;POINT X TO FPA1 
CA90  BDD3E7                    JSR  LBC96         ;COMPARE FPA0 TO FPA1 
CA93  2036                      BRA  LB33F         ;CHECK TRUTH OF RELATIONAL COMPARISON 
                                                     
                      * RELATIONAL COMPARISON OF STRINGS                      
CA95  0F06            LB309     CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
CA97  0A3F                      DEC  TRELFL        ;REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE 
                      *                            ;DESIRED RELATIONAL COMPARISON DATA 
CA99  BDCDE3                    JSR  LB657         ;GET LENGTH AND ADDRESS OF STRING WHOSE 
                      *                            ;DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0 
CA9C  D756                      STB  STRDES        ;* SAVE LENGTH AND ADDRESS IN TEMPORARY 
CA9E  9F58                      STX  STRDES+2      ;* DESCRIPTOR (STRING B) 
CAA0  9E5F                      LDX  FPA1+2        ;= RETURN LENGTH AND ADDRESS OF STRING 
CAA2  BDCDE5                    JSR  LB659         ;= WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2 
CAA5  9656                      LDA  STRDES        ;LOAD ACCA WITH LENGTH OF STRING B 
CAA7  3404                      PSHS B             ;SAVE LENGTH A ON STACK 
CAA9  A0E0                      SUBA ,S+           ;SUBTRACT LENGTH A FROM LENGTH B 
CAAB  2707                      BEQ  LB328         ;BRANCH IF STRINGS OF EQUAL LENGTH 
CAAD  8601                      LDA  #1            ;TRUE FLAG 
CAAF  2403                      BCC  LB328         ;TRUE IF LENGTH B > LENGTH A 
CAB1  D656                      LDB  STRDES        ;LOAD ACCB WITH LENGTH B 
CAB3  40                        NEGA               ;SET FLAG = FALSE (1FF) 
CAB4  9754            LB328     STA  FP0SGN        ;SAVE TRUE/FALSE FLAG 
CAB6  DE58                      LDU  STRDES+2      ;POINT U TO START OF STRING 
CAB8  5C                        INCB               ;COMPENSATE FOR THE DECB BELOW 
                      * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING                      
CAB9  5A              LB32D     DECB               ;DECREMENT SHORTER STRING LENGTH 
CABA  2604                      BNE  LB334         ;BRANCH IF ALL OF STRING NOT COMPARED 
CABC  D654                      LDB  FP0SGN        ;GET TRUE/FALSE FLAB 
CABE  200B                      BRA  LB33F         ;CHECK TRUTH OF RELATIONAL COMPARISON 
CAC0  A680            LB334     LDA  ,X+           ;GET A BYTE FROM STRING A 
CAC2  A1C0                      CMPA ,U+           ;COMPARE TO STRING B 
CAC4  27F3                      BEQ  LB32D         ;CHECK ANOTHER CHARACTER IF = 
CAC6  C6FF                      LDB  #$FF          ;FALSE FLAG IF STRING A > B 
CAC8  2401                      BCC  LB33F         ;BRANCH IF STRING A > STRING B 
CACA  50                        NEGB               ;SET FLAG = TRUE 
                                                     
                      * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0                      
CACB  CB01            LB33F     ADDB #1            ;CONVERT $FF,0,1 TO 0,1,2 
CACD  59                        ROLB               ;NOW IT'S 1,2,4 FOR > = <
CACE  D40A                      ANDB RELFLG        ;'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
CAD0                  COMPARISON                      
CAD0  2702                      BEQ  LB348         ;BRANCH IF FALSE (NO MATCHING BITS) 
CAD2  C6FF                      LDB  #$FF          ;TRUE FLAG 
CAD4  7ED3CD          LB348     JMP  LBC7C         ;CONVERT ACCB INTO FP NUMBER IN FPA0 
                                                     
                      * DIM                          
CAD7  BDC9FE          LB34B     JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
CADA  C601            DIM       LDB  #1            ;DIMENSION FLAG 
CADC  8D08                      BSR  LB35A         ;SAVE ARRAY SPACE FOR THIS VARIABLE 
CADE  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
CAE0  26F5                      BNE  LB34B         ;KEEP DIMENSIONING IF NOT END OF LINE 
CAE2  39                        RTS                  
                      * EVALUATE A VARIABLE - RETURN X AND                      
                      * VARPTR POINTING TO VARIABLE;DESCRIPTOR                      
                      * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO                      
                      * BYTES ARE THE VARIABLE NAME;AND THE NEXT 5                      
                      * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE                      
                      * FIRST BYTE OF VARlABLE NAME;IS SET, THE                      
                      * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF                      
                      * THE SECOND BYTE OF VARIABLE;NAME IS SET, THE                      
                      * VARIABLE IS A STRING, OTHERWISE THE VARIABLE                      
                      * IS NUMERIC.                      
                      * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS                      
                      * INSERTED INTO THE VARIABLE SPACE                      
CAE3  5F              LB357     CLRB               ;DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY 
CAE4  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
CAE6  D705            LB35A     STB  DIMFLG        ;SAVE ARRAY FLAG 
                      * ENTRY POINT FOR DEF FN VARIABLE SEARCH                      
CAE8  9737            LB35C     STA  VARNAM        ;SAVE INPUT CHARACTER 
CAEA  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
CAEC  8D40                      BSR  LB3A2         ;SET CARRY IF NOT ALPHA 
CAEE  1025FF16                  LBCS LB277         ;SYNTAX ERROR IF NOT ALPHA 
CAF2  5F                        CLRB               ;DEFAULT 2ND VARIABLE CHARACTER TO ZERO 
CAF3  D706                      STB  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
CAF5  9D7C                      JSR  GETNCH        ;GET ANOTHER CHARACTER FROM BASIC 
CAF7  2504                      BCS  LB371         ;BRANCH IF NUMERIC (2ND CHARACTER IN 
                      *                            ;VARIABLE MAY BE NUMERIC) 
CAF9  8D33                      BSR  LB3A2         ;SET CARRY IF NOT ALPHA 
CAFB  250A                      BCS  LB37B         ;BRANCH IF NOT ALPHA 
CAFD  1F89            LB371     TFR  A,B           ;SAVE 2ND CHARACTER IN ACCB 
                      * READ INPUT CHARACTERS UNTIL;A NON ALPHA OR                      
                      * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS                      
                      * IN VARIABLE NAME AFTER THE 1ST TWO                      
CAFF  9D7C            LB373     JSR  GETNCH        ;GET AN INPUT CHARACTER 
CB01  25FC                      BCS  LB373         ;BRANCH IF NUMERIC 
CB03  8D29                      BSR  LB3A2         ;SET CARRY IF NOT ALPHA 
CB05  24F8                      BCC  LB373         ;BRANCH IF ALPHA 
CB07  8124            LB37B     CMPA #'$           ;CHECK FOR A STRING VARIABLE 
CB09  2606                      BNE  LB385         ;BRANCH IF IT IS NOT A STRING 
CB0B  0306                      COM  VALTYP        ;SET VARIABLE TYPE TO STRING 
CB0D  CB80                      ADDB #$80          ;SET BIT 7 OF 2ND CHARACTER (STRING) 
CB0F  9D7C                      JSR  GETNCH        ;GET AN INPUT CHARACTER 
CB11  D738            LB385     STB  VARNAM+1      ;SAVE 2ND CHARACTER IN VARNAM+1 
CB13  9A08                      ORA  ARYDIS        ;OR IN THE ARRAY DISABLE FLAG - IF = $80, 
                      *              DON'T SEARCH FOR VARIABLES IN THE ARRAYS
CB15  8028                      SUBA #'(           ;IS THIS AN ARRAY VARIABLE? 
CB17  10270075                  LBEQ LB404         ;BRANCH IF IT IS 
CB1B  0F08                      CLR  ARYDIS        ;RESET THE ARRAY DISABLE FLAG 
CB1D  9E1B                      LDX  VARTAB        ;POINT X TO THE START OF VARIABLES 
CB1F  DC37                      LDD  VARNAM        ;GET VARIABLE IN QUESTION 
CB21  9C1D            LB395     CMPX ARYTAB        ;COMPARE X TO THE END OF VARIABLES 
CB23  2712                      BEQ  LB3AB         ;BRANCH IF END OF VARIABLES 
CB25  10A381                    CMPD ,X++          ;* COMPARE VARIABLE IN QUESTION TO CURRENT 
CB28  273E                      BEQ  LB3DC         ;* VARIABLE AND BRANCH IF MATCH 
CB2A  3005                      LEAX 5,X           ;= MOVE POINTER TO NEXT VARIABLE AND 
CB2C  20F3                      BRA  LB395         ;= KEEP LOOKING 
                                                     
                      * SET CARRY IF NOT UPPER CASE;ALPHA                      
CB2E  8141            LB3A2     CMPA #'A           ;* CARRY SET IF < 'A'
CB30  2504                      BCS  LB3AA         ;* 
CB32  805B                      SUBA #'Z+1         ;= 
                      *         SUBA #-('Z+1)      ;= CARRY CLEAR IF <= 'Z' 
CB34  80A5                      FCB  $80,$A5         
CB36  39              LB3AA     RTS                  
                      * PUT A NEW VARIABLE IN TABLE;OF VARIABLES                      
CB37  8E0074          LB3AB     LDX  #ZERO         ;POINT X TO ZERO LOCATION 
CB3A  EEE4                      LDU  ,S            ;GET CURRENT RETURN ADDRESS 
CB3C  1183CA18                  CMPU #LB287        ;DID WE COME FROM 'EVALUATE ALPHA EXPR'?
CB40  2728                      BEQ  LB3DE         ;YES - RETURN A ZERO VALUE 
CB42  DC1F                      LDD  ARYEND        ;* GET END OF ARRAYS ADDRESS AND 
CB44  DD43                      STD  V43           ;* SAVE IT AT V43 
CB46  C30007                    ADDD #7            ;= ADD 7 TO END OF ARRAYS (EACH 
CB49  DD41                      STD  V41           ;= VARIABLE = 7 BYTES) AND SAVE AT V41 
CB4B  9E1D                      LDX  ARYTAB        ;* GET END OF VARIABLES AND SAVE AT V47 
CB4D  9F47                      STX  V47           ;* 
CB4F  BDC3E0                    JSR  LAC1E         ;MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT 
                      *         TOP  OF VARIABLES    
CB52  9E41                      LDX  V41           ;= GET NEW END OF ARRAYS AND SAVE IT 
CB54  9F1F                      STX  ARYEND        ;= 
CB56  9E45                      LDX  V45           ;* GET NEW END OF VARIABLES AND SAVE IT 
CB58  9F1D                      STX  ARYTAB        ;* 
CB5A  9E47                      LDX  V47           ;GET OLD END OF VARIABLES 
CB5C  DC37                      LDD  VARNAM        ;GET NEW VARIABLE NAME 
CB5E  ED81                      STD  ,X++          ;SAVE VARIABLE NAME 
CB60  4F                        CLRA               ;* ZERO OUT THE FP VALUE OF THE NUMERIC 
CB61  5F                        CLRB               ;* VARIABLE OR THE LENGTH AND ADDRESS 
CB62  ED84                      STD  ,X            ;* OF A STRING VARIABLE 
CB64  ED02                      STD  2,X           ;* 
CB66  A704                      STA  4,X           ;* 
CB68  9F39            LB3DC     STX  VARPTR        ;STORE ADDRESS OF VARIABLE VALUE 
CB6A  39              LB3DE     RTS                  
                      *                              
CB6B  9080000000      LB3DF     FCB  $90,$80,$00,$00,$00 ;* FLOATING POINT -32768 
                      *                            ;SMALLEST SIGNED TWO BYTE INTEGER 
                      *                              
CB70  9D7C            LB3E4     JSR  GETNCH        ;GET AN INPUT CHARACTER FROM BASIC 
CB72  BDC8D2          LB3E6     JSR  LB141         ;GO EVALUATE NUMERIC EXPRESSION 
CB75  9654            LB3E9     LDA  FP0SGN        ;GET FPA0 MANTISSA SIGN 
CB77  2B5D                      BMI  LB44A         ;'FC' ERROR IF NEGATIVE NUMBER
                                                     
                                                     
CB79  BDC8D4          INTCNV    JSR  LB143         ;'TM' ERROR IF STRING VARIABLE
CB7C  964F                      LDA  FP0EXP        ;GET FPA0 EXPONENT 
CB7E  8190                      CMPA #$90          ;* COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND 
CB80  2508                      BCS  LB3FE         ;* BRANCH IF FPA0 < 32768 
CB82  8ECB6B                    LDX  #LB3DF        ;POINT X TO FP VALUE OF -32768 
CB85  BDD3E7                    JSR  LBC96         ;COMPARE -32768 TO FPA0 
CB88  264C                      BNE  LB44A         ;'FC' ERROR IF NOT =
CB8A  BDD419          LB3FE     JSR  LBCC8         ;CONVERT FPA0 TO A TWO BYTE INTEGER 
CB8D  DC52                      LDD  FPA0+2        ;GET THE INTEGER 
CB8F  39                        RTS                  
                      * EVALUATE AN ARRAY VARIABLE                      
CB90  DC05            LB404     LDD  DIMFLG        ;GET ARRAY FLAG AND VARIABLE TYPE 
CB92  3406                      PSHS B,A           ;SAVE THEM ON STACK 
CB94  12                        NOP                ;DEAD SPACE CAUSED BY 1.2 REVISION 
CB95  5F                        CLRB               ;RESET DIMENSION COUNTER 
CB96  9E37            LB40A     LDX  VARNAM        ;GET VARIABLE NAME 
CB98  3414                      PSHS X,B           ;SAVE VARIABLE NAME AND DIMENSION COUNTER 
CB9A  8DD4                      BSR  LB3E4         ;EVALUATE EXPRESSION (DIMENSlON LENGTH) 
CB9C  3534                      PULS B,X,Y         ;PULL OFF VARIABLE NAME, DIMENSlON COUNTER, 
                      *                            ;ARRAY FLAG 
CB9E  9F37                      STX  VARNAM        ;SAVE VARIABLE NAME AND VARIABLE TYPE 
CBA0  DE52                      LDU  FPA0+2        ;GET DIMENSION LENGTH 
CBA2  3460                      PSHS U,Y           ;SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE 
CBA4  5C                        INCB               ;INCREASE DIMENSION COUNTER 
CBA5  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
CBA7  812C                      CMPA #',           ;CHECK FOR ANOTHER DIMENSION 
CBA9  27EB                      BEQ  LB40A         ;BRANCH IF MORE 
CBAB  D703                      STB  TMPLOC        ;SAVE DIMENSION COUNTER 
CBAD  BDC9F8                    JSR  LB267         ;SYNTAX CHECK FOR A ')'
CBB0  3506                      PULS A,B           ;* RESTORE VARIABLE TYPE AND ARRAY 
CBB2  DD05                      STD  DIMFLG        ;* FLAG - LEAVE DIMENSION LENGTH ON STACK 
CBB4  9E1D                      LDX  ARYTAB        ;GET START OF ARRAYS 
CBB6  9C1F            LB42A     CMPX ARYEND        ;COMPARE TO END OF ARRAYS 
CBB8  2721                      BEQ  LB44F         ;BRANCH IF NO MATCH FOUND 
CBBA  DC37                      LDD  VARNAM        ;GET VARIABLE IN QUESTION 
CBBC  10A384                    CMPD ,X            ;COMPARE TO CURRENT VARIABLE 
CBBF  2706                      BEQ  LB43B         ;BRANCH IF = 
CBC1  EC02                      LDD  2,X           ;GET OFFSET TO NEXT ARRAY VARIABLE 
CBC3  308B                      LEAX D,X           ;ADD TO CURRENT POINTER 
CBC5  20EF                      BRA  LB42A         ;KEEP SEARCHING 
CBC7  C612            LB43B     LDB  #2*9          ;'REDIMENSIONED ARRAY' ERROR
CBC9  9605                      LDA  DIMFLG        ;* TEST ARRAY FLAG - IF <>0 YOU ARE TRYING 
CBCB  260B                      BNE  LB44C         ;* TO REDIMENSION AN ARRAY 
CBCD  D603                      LDB  TMPLOC        ;GET NUMBER OF DIMENSIONS IN ARRAY 
CBCF  E104                      CMPB 4,X           ;COMPARE TO THIS ARRAYS DIMENSIONS 
CBD1  2759                      BEQ  LB4A0         ;BRANCH IF = 
CBD3  C610            LB447     LDB  #8*2          ;'BAD SUBSCRIPT'
CBD5  8C                        FCB  SKP2          ;SKIP TWO BYTES 
CBD6  C608            LB44A     LDB  #4*2          ;'ILLEGAL FUNCTION CALL'
CBD8  7EC408          LB44C     JMP  LAC46         ;JUMP TO ERROR SERVICING ROUTINE 
                                                     
                      * INSERT A NEW ARRAY INTO ARRAY VARIABLES                      
                      * EACH SET OF ARRAY VARIABLES;IS PRECEEDED BY A DE-                      
                      * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE                      
                      * NUMBER OF DIMENSIONS IN THE;ARRAY. THE BLOCK IS DEFINED                      
                      * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
                      * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-                      
                      * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-                      
                      * SION 2;' 4+N,5+N:LENGTH OF DIMENSION N.
                                                     
CBDB  CC0005          LB44F     LDD  #5            ;* 5 BYTES/ARRAY ENTRY SAVE AT COEFPT 
CBDE  DD64                      STD  COEFPT        ;* 
CBE0  DC37                      LDD  VARNAM        ;= GET NAME OF ARRAY AND SAVE IN 
CBE2  ED84                      STD  ,X            ;= FIRST 2 BYTES OF DESCRIPTOR 
CBE4  D603                      LDB  TMPLOC        ;GET NUMBER OF DIMENSIONS AND SAVE IN 
CBE6  E704                      STB  4,X           ;* 5TH BYTE OF DESCRIPTOR 
CBE8  BDC3F5                    JSR  LAC33         ;CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM 
CBEB  9F41                      STX  V41           ;TEMPORARILY SAVE DESCRIPTOR ADDRESS 
CBED  C60B            LB461     LDB  #11           ;* DEFAULT DIMENSION VALUE:X(10) 
CBEF  4F                        CLRA               ;* 
CBF0  0D05                      TST  DIMFLG        ;= CHECK ARRAY FLAG AND BRANCH IF 
CBF2  2705                      BEQ  LB46D         ;= NOT DIMENSIONING AN ARRAY 
CBF4  3506                      PULS A,B           ;GET DIMENSION LENGTH 
CBF6  C30001                    ADDD #1            ;ADD ONE (X(0) HAS A LENGTH OF ONE) 
CBF9  ED05            LB46D     STD  5,X           ;SAVE LENGTH OF ARRAY DIMENSION 
CBFB  8D5D                      BSR  LB4CE         ;MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH 
                      *                            ;OF NEW DIMENSION 
CBFD  DD64                      STD  COEFPT        ;TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE 
CBFF  3002                      LEAX 2,X           ;BUMP POINTER UP TWO 
CC01  0A03                      DEC  TMPLOC        ;* DECREMENT DIMENSION COUNTER AND BRANCH IF 
CC03  26E8                      BNE  LB461         ;* NOT DONE WITH ALL DIMENSIONS 
CC05  9F0F                      STX  TEMPTR        ;SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5) 
CC07  D30F                      ADDD TEMPTR        ;ADD TOTAL SIZE OF NEW ARRAY 
CC09  1025F7F9                  LBCS LAC44         ;'OM' ERROR IF > $FFFF
CC0D  1F01                      TFR  D,X           ;SAVE END OF ARRAY IN X 
CC0F  BDC3F9                    JSR  LAC37         ;MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY 
CC12  830035                    SUBD #STKBUF-5     ;SUBTRACT OUT THE (STACK BUFFER - 5) 
CC15  DD1F                      STD  ARYEND        ;SAVE NEW END OF ARRAYS 
CC17  4F                        CLRA               ;ZERO = TERMINATOR BYTE 
CC18  301F            LB48C     LEAX -1,X          ;* STORE TWO TERMINATOR BYTES AT 
CC1A  A705                      STA  5,X           ;* THE END OF THE ARRAY DESCRIPTOR 
CC1C  9C0F                      CMPX TEMPTR        ;* 
CC1E  26F8                      BNE  LB48C         ;* 
CC20  9E41                      LDX  V41           ;GET ADDRESS OF START OF DESCRIPTOR 
CC22  961F                      LDA  ARYEND        ;GET MSB OF END OF ARRAYS; LSB ALREADY THERE 
CC24  9341                      SUBD V41           ;SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR 
CC26  ED02                      STD  2,X           ;SAVE LENGTH OF (ARRAY AND DESCRIPTOR) 
CC28  9605                      LDA  DIMFLG        ;* GET ARRAY FLAG AND BRANCH 
CC2A  262D                      BNE  LB4CD         ;* BACK IF DIMENSIONING 
                      * CALCULATE POINTER TO CORRECT ELEMENT                      
CC2C  E604            LB4A0     LDB  4,X           ;GET THE NUMBER OF DIMENSIONS 
CC2E  D703                      STB  TMPLOC        ;TEMPORARILY SAVE 
CC30  4F                        CLRA               ;* INITIALIZE POINTER 
CC31  5F                        CLRB               ;* TO ZERO 
CC32  DD64            LB4A6     STD  COEFPT        ;SAVE ACCUMULATED POINTER 
CC34  3506                      PULS A,B           ;* PULL DIMENSION ARGUMENT OFF THE 
CC36  DD52                      STD  FPA0+2        ;* STACK AND SAVE IT 
CC38  10A305                    CMPD 5,X           ;COMPARE TO STORED 'DIM' ARGUMENT
CC3B  243A                      BCC  LB4EB         ;'BS' ERROR IF > = "DIM" ARGUMENT
CC3D  DE64                      LDU  COEFPT        ;* GET ACCUMULATED POINTER AND 
CC3F  2704                      BEQ  LB4B9         ;* BRANCH IF 1ST DIMENSION 
CC41  8D17                      BSR  LB4CE         ;= MULTIPLY ACCUMULATED POINTER AND DIMENSION 
CC43  D352                      ADDD FPA0+2        ;= LENGTH AND ADD TO CURRENT ARGUMENT 
CC45  3002            LB4B9     LEAX 2,X           ;MOVE POINTER TO NEXT DIMENSION 
CC47  0A03                      DEC  TMPLOC        ;* DECREMENT DIMENSION COUNTER AND 
CC49  26E7                      BNE  LB4A6         ;* BRANCH IF ANY DIMENSIONS LEFT 
                      * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE                      
CC4B  EDE3                      STD  ,--S            
CC4D  58                        ASLB                 
CC4E  49                        ROLA               ;TIMES 2 
CC4F  58                        ASLB                 
CC50  49                        ROLA               ;TIMES 4 
CC51  E3E1                      ADDD ,S++          ;TIMES 5 
CC53  308B                      LEAX D,X           ;ADD OFFSET TO START OF ARRAY 
CC55  3005                      LEAX 5,X           ;ADJUST POINTER FOR SIZE OF DESCRIPTOR 
CC57  9F39                      STX  VARPTR        ;SAVE POINTER TO ARRAY VALUE 
CC59  39              LB4CD     RTS                  
                      * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER                      
                      * IN COEFPT. RETURN RESULT IN;ACCD, BS ERROR IF > $FFFF                      
CC5A  8610            LB4CE     LDA  #16           ;16 SHIFTS TO DO A MULTIPLY 
CC5C  9745                      STA  V45           ;SHIFT COUNTER 
CC5E  EC05                      LDD  5,X           ;* GET SIZE OF DIMENSION 
CC60  DD17                      STD  BOTSTK        ;* AND SAVE IT 
CC62  4F                        CLRA               ;* ZERO 
CC63  5F                        CLRB               ;* ACCD 
CC64  58              LB4D8     ASLB               ;= SHIFT ACCB LEFT 
CC65  49                        ROLA               ;= ONE BIT 
CC66  250F                      BCS  LB4EB         ;BS' ERROR IF CARRY 
CC68  0865                      ASL  COEFPT+1      ;* SHIFT MULTIPLICAND LEFT ONE 
CC6A  0964                      ROL  COEFPT        ;* BIT - ADD MULTIPLIER TO ACCUMULATOR 
CC6C  2404                      BCC  LB4E6         ;* IF CARRY <> 0 
CC6E  D317                      ADDD BOTSTK        ;ADD MULTIPLIER TO ACCD 
CC70  2505                      BCS  LB4EB         ;BS' ERROR IF CARRY (>$FFFF) 
CC72  0A45            LB4E6     DEC  V45           ;* DECREMENT SHIFT COUNTER 
CC74  26EE                      BNE  LB4D8         ;* IF NOT DONE 
CC76  39                        RTS                  
CC77  7ECBD3          LB4EB     JMP  LB447         ;BS' ERROR 
                      *                              
                      * MEM                          
                      * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE                      
                      * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK                      
                      * FOR WHICH MEM DOES NOT ALLOW.                      
                      *                              
CC7A  1F40            MEM       TFR  S,D           ;PUT STACK POINTER INTO ACCD 
CC7C  931F                      SUBD ARYEND        ;SUBTRACT END OF ARRAYS 
CC7E  21                        FCB  SKP1          ;SKIP ONE BYTE 
                      *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0                      
CC7F  4F              LB4F3     CLRA               ;CLEAR MS BYTE OF ACCD 
                      * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0                      
CC80  0F06            GIVABF    CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
CC82  DD50                      STD  FPA0          ;SAVE ACCD IN TOP OF FACA 
CC84  C690                      LDB  #$90          ;EXPONENT REQUIRED IF THE TOP TWO BYTES 
                      *         OF   FPA0 ARE TO BE;TREATED AS AN INTEGER IN FPA0  
CC86  7ED3D3                    JMP  LBC82         ;CONVERT THE REST OF FPA0 TO AN INTEGER 
                                                     
                      * STR$                         
CC89  BDC8D4          STR       JSR  LB143         ;TM' ERROR IF STRING VARIABLE 
CC8C  CE01F0                    LDU  #STRBUF+2     ;*CONVERT FP NUMBER TO ASCII STRING IN 
CC8F  BDD52D                    JSR  LBDDC         ;*THE STRING BUFFER 
CC92  3262                      LEAS 2,S           ;PURGE THE RETURN ADDRESS FROM THE STACK 
CC94  8E01EF                    LDX  #STRBUF+1     ;*POINT X TO STRING BUFFER AND SAVE 
CC97  200B                      BRA  LB518         ;*THE STRING IN THE STRING SPACE 
                      * RESERVE ACCB BYTES OF STRING SPACE. RETURN START                      
                      * ADDRESS IN (X) AND FRESPC                      
CC99  9F4D            LB50D     STX  V4D           ;SAVE X IN V4D 
CC9B  8D5C            LB50F     BSR  LB56D         ;RESERVE ACCB BYTES IN STRING SPACE 
CC9D  9F58            LB511     STX  STRDES+2      ;SAVE NEW STRING ADDRESS 
CC9F  D756                      STB  STRDES        ;SAVE LENGTH OF RESERVED BLOCK 
CCA1  39                        RTS                  
CCA2  301F            LB516     LEAX -1,X          ;MOVE POINTER BACK ONE 
                      * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR                      
                      * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.                      
                      * THE RESULTING STRING IS STORED IN THE STRING SPACE                      
                      * ONLY IF THE START OF THE STRING IS <= STRBUF+2                      
CCA4  8622            LB518     LDA  #'"           ;* INITIALIZE 
CCA6  9701                      STA  CHARAC        ;* TERMINATORS 
CCA8  9702            LB51A     STA  ENDCHR        ;* TO " 
CCAA  3001            LB51E     LEAX 1,X           ;MOVE POINTER UP ONE 
CCAC  9F62                      STX  RESSGN        ;TEMPORARILY SAVE START OF STRING 
CCAE  9F58                      STX  STRDES+2      ;SAVE START OF STRING IN TEMP DESCRIPTOR 
CCB0  C6FF                      LDB  #-1           ;INITIALIZE CHARACTER COUNTER TO - 1 
CCB2  5C              LB526     INCB               ;INCREMENT CHARACTER COUNTER 
CCB3  A680                      LDA  ,X+           ;GET CHARACTER 
CCB5  270C                      BEQ  LB537         ;BRANCH IF END OF LINE 
CCB7  9101                      CMPA CHARAC        ;* CHECK FOR TERMINATORS 
CCB9  2704                      BEQ  LB533         ;* IN CHARAC AND ENDCHR 
CCBB  9102                      CMPA ENDCHR        ;* DON'T MOVE POINTER BACK
CCBD  26F3                      BNE  LB526         ;* ONE IF TERMINATOR IS "MATCHED" 
CCBF  8122            LB533     CMPA #'"           ;= COMPARE CHARACTER TO STRING DELIMITER 
CCC1  2702                      BEQ  LB539         ;= & DON'T MOVE POINTER BACK IF SO
CCC3  301F            LB537     LEAX -1,X          ;MOVE POINTER BACK ONE 
CCC5  9F64            LB539     STX  COEFPT        ;SAVE END OF STRING ADDRESS 
CCC7  D756                      STB  STRDES        ;SAVE STRING LENGTH IN TEMP DESCRIPTOR 
CCC9  DE62                      LDU  RESSGN        ;GET INITlAL STRING START 
CCCB  118301F0                  CMPU #STRBUF+2     ;COMPARE TO START OF STRING BUFFER 
CCCF  2207            LB543     BHI  LB54C         ;BRANCH IF > START OF STRING BUFFER 
CCD1  8DC6                      BSR  LB50D         ;GO RESERVE SPACE FOR THE STRING 
CCD3  9E62                      LDX  RESSGN        ;POINT X TO THE BEGINNING OF THE STRING 
CCD5  BDCDD1                    JSR  LB645         ;MOVE (B) BYTES FROM (X) TO 
                      *                            ;[FRESPC] - MOVE STRING DATA 
                      * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA                      
                      * ON THE STRING STACK. SET VARIABLE TYPE TO STRING                      
CCD8  9E0B            LB54C     LDX  TEMPPT        ;GET NEXT AVAILABLE STRING STACK DESCRIPTOR 
CCDA  8C00F1                    CMPX #LINHDR       ;COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF 
CCDD  2605                      BNE  LB558         ;FORMULA O.K. 
CCDF  C61E                      LDB  #15*2         ;STRING FORMULA TOO COMPLEX' ERROR 
CCE1  7EC408          LB555     JMP  LAC46         ;JUMP TO ERROR SERVICING ROUTINE 
CCE4  9656            LB558     LDA  STRDES        ;* GET LENGTH OF STRING AND SAVE IT 
                      *         STA  ,X            ;* IN BYTE 0 OF DESCRIPTOR 
CCE6  A700                      FCB  $A7,$00         
CCE8  DC58                      LDD  STRDES+2      ;= GET START ADDRESS OF ACTUAL STRING 
CCEA  ED02                      STD  2,X           ;= AND SAVE IN BYTES 2,3 OF DESCRIPTOR 
CCEC  86FF                      LDA  #$FF          ;* VARIABLE TYPE = STRING 
CCEE  9706                      STA  VALTYP        ;* SAVE IN VARIABLE TYPE FLAG 
CCF0  9F0D                      STX  LASTPT        ;= SAVE START OF DESCRIPTOR 
CCF2  9F52                      STX  FPA0+2        ;= ADDRESS IN LASTPT AND FPA0 
CCF4  3005                      LEAX 5,X           ;5 BYTES/STRING DESCRIPTOR 
CCF6  9F0B                      STX  TEMPPT        ;NEXT AVAILABLE STRING VARIABLE DESCRIPTOR 
CCF8  39                        RTS                  
                      * RESERVE ACCB BYTES IN STRING STORAGE SPACE                      
                      * RETURN WITH THE STARTING ADDRESS OF THE                      
                      * RESERVED STRING SPACE IN (X) AND FRESPC                      
CCF9  0F07            LB56D     CLR  GARBFL        ;CLEAR STRING REORGANIZATION FLAG 
CCFB  4F              LB56F     CLRA               ;* PUSH THE LENGTH OF THE 
CCFC  3406                      PSHS B,A           ;* STRING ONTO THE STACK 
CCFE  DC23                      LDD  STRTAB        ;GET START OF STRING VARIABLES 
CD00  A3E0                      SUBD ,S+           ;SUBTRACT STRING LENGTH 
CD02  109321                    CMPD FRETOP        ;COMPARE TO START OF STRING STORAGE 
CD05  250A                      BCS  LB585         ;IF BELOW START, THEN REORGANIZE 
CD07  DD23                      STD  STRTAB        ;SAVE NEW START OF STRING VARIABLES 
CD09  9E23                      LDX  STRTAB        ;GET START OF STRING VARIABLES 
CD0B  3001                      LEAX 1,X           ;ADD ONE 
CD0D  9F25                      STX  FRESPC        ;SAVE START ADDRESS OF NEWLY RESERVED SPACE 
CD0F  3584                      PULS B,PC          ;RESTORE NUMBER OF BYTES RESERVED AND RETURN 
CD11  C61A            LB585     LDB  #2*13         ;OUT OF STRING SPACE' ERROR 
CD13  0307                      COM  GARBFL        ;TOGGLE REORGANIZATiON FLAG 
CD15  27CA                      BEQ  LB555         ;ERROR IF FRESHLY REORGANIZED 
CD17  8D04                      BSR  LB591         ;GO REORGANIZE STRING SPACE 
CD19  3504                      PULS B             ;GET BACK THE NUMBER OF BYTES TO RESERVE 
CD1B  20DE                      BRA  LB56F         ;TRY TO RESERVE ACCB BYTES AGAIN 
                      * REORGANIZE THE STRING SPACE                      
CD1D  9E27            LB591     LDX  MEMSIZ        ;GET THE TOP OF STRING SPACE 
CD1F  9F23            LB593     STX  STRTAB        ;SAVE TOP OF UNORGANIZED STRING SPACE 
CD21  4F                        CLRA               ;* ZERO OUT ACCD 
CD22  5F                        CLRB               ;* AND RESET VARIABLE 
CD23  DD4B                      STD  V4B           ;* POINTER TO 0 
CD25  9E21                      LDX  FRETOP        ;POINT X TO START OF STRING SPACE 
CD27  9F47                      STX  V47           ;SAVE POINTER IN V47 
CD29  8E00C9                    LDX  #STRSTK       ;POINT X TO START OF STRING DESCRIPTOR STACK 
CD2C  9C0B            LB5A0     CMPX TEMPPT        ;COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR 
CD2E  2704                      BEQ  LB5A8         ;BRANCH IF TOP OF STRING STACK 
CD30  8D32                      BSR  LB5D8         ;CHECK FOR STRING IN UNORGANIZED STRING SPACE 
CD32  20F8                      BRA  LB5A0         ;KEEP CHECKING 
CD34  9E1B            LB5A8     LDX  VARTAB        ;GET THE END OF BASIC PROGRAM 
CD36  9C1D            LB5AA     CMPX ARYTAB        ;COMPARE TO END OF VARIABLES 
CD38  2704                      BEQ  LB5B2         ;BRANCH IF AT TOP OF VARIABLES 
CD3A  8D22                      BSR  LB5D2         ;CHECK FOR STRING IN UNORGANIZED STRING SPACE 
CD3C  20F8                      BRA  LB5AA         ;KEEP CHECKING VARIABLES 
CD3E  9F41            LB5B2     STX  V41           ;SAVE ADDRESS OF THE END OF VARIABLES 
CD40  9E41            LB5B4     LDX  V41           ;GET CURRENT ARRAY POINTER 
CD42  9C1F            LB5B6     CMPX ARYEND        ;COMPARE TO THE END OF ARRAYS 
CD44  2735                      BEQ  LB5EF         ;BRANCH IF AT END OF ARRAYS 
CD46  EC02                      LDD  2,X           ;GET LENGTH OF ARRAY AND DESCRIPTOR 
CD48  D341                      ADDD V41           ;* ADD TO CURRENT ARRAY POINTER 
CD4A  DD41                      STD  V41           ;* AND SAVE IT 
CD4C  A601                      LDA  1,X           ;GET 1ST CHARACTER OF VARIABLE NAME 
CD4E  2AF0                      BPL  LB5B4         ;BRANCH IF NUMERIC ARRAY 
CD50  E604                      LDB  4,X           ;GET THE NUMBER OF DIMENSIONS IN THIS ARRAY 
CD52  58                        ASLB               ;MULTIPLY BY 2 
CD53  CB05                      ADDB #5            ;ADD FIVE BYTES (VARIABLE NAME, ARRAY 
                      *                            ;LENGTH, NUMBER DIMENSIONS) 
CD55  3A                        ABX                ;X NOW POINTS TO START OF ARRAY ELEMENTS 
CD56  9C41            LB5CA     CMPX V41           ;AT END OF THIS ARRAY? 
CD58  27E8                      BEQ  LB5B6         ;YES - CHECK FOR ANOTHER 
CD5A  8D08                      BSR  LB5D8         ;CHECK FOR STRING LOCATED IN 
                      *                            ;UNORGANIZED STRING SPACE 
CD5C  20F8                      BRA  LB5CA         ;KEEP CHECKING ELEMENTS IN THIS ARRAY 
CD5E  A601            LB5D2     LDA  1,X           ;GET F1RST BYTE OF VARIABLE NAME 
CD60  3002                      LEAX 2,X           ;MOVE POINTER TO DESCRIPTOR 
CD62  2A14                      BPL  LB5EC         ;BRANCH IF VARIABLE IS NUMERIC 
                      * SEARCH FOR STRING - ENTER WITH X POINTING TO                      
                      * THE STRING DESCRIPTOR. IF STRING IS STORED                      
                      * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER                      
                      * IN V4B AND RESET V47 TO STRING ADDRESS                      
CD64  E684            LB5D8     LDB  ,X            ;GET THE LENGTH OF THE STRING 
CD66  2710                      BEQ  LB5EC         ;BRANCH IF NULL - NO STRING 
CD68  EC02                      LDD  2,X           ;GET STARTING ADDRESS OF THE STRING 
CD6A  109323                    CMPD STRTAB        ;COMPARE TO THE START OF STRING VARIABLES 
CD6D  2209                      BHI  LB5EC         ;BRANCH IF THIS STRING IS STORED IN 
                      *              THE STRING VARIABLES  
CD6F  109347                    CMPD V47           ;COMPARE TO START OF STRING SPACE 
CD72  2304                      BLS  LB5EC         ;BRANCH IF NOT STORED IN THE STRING SPACE 
CD74  9F4B                      STX  V4B           ;SAVE VARIABLE POINTER IF STORED IN STRING SPACE 
CD76  DD47                      STD  V47           ;SAVE STRING STARTING ADDRESS 
CD78  3005            LB5EC     LEAX 5,X           ;MOVE TO NEXT VARIABLE DESCRIPTOR 
CD7A  39              LB5EE     RTS                  
CD7B  9E4B            LB5EF     LDX  V4B           ;GET ADDRESS OF THE DESCRIPTOR FOR THE 
                      *              STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN  
                      *              THE UNORGANIZED STRING SPACE  
CD7D  27FB                      BEQ  LB5EE         ;BRANCH IF NONE FOUND AND REORGANIZATION DONE 
CD7F  4F                        CLRA               ;CLEAR MS BYTE OF LENGTH 
CD80  E684                      LDB  ,X            ;GET LENGTH OF STRING 
CD82  5A                        DECB               ;SUBTRACT ONE 
CD83  D347                      ADDD V47           ;ADD LENGTH OF STRING TO ITS STARTING ADDRESS 
CD85  DD43                      STD  V43           ;SAVE AS MOVE STARTING ADDRESS 
CD87  9E23                      LDX  STRTAB        ;POINT X TO THE START OF ORGANIZED STRING VARIABLES 
CD89  9F41                      STX  V41           ;SAVE AS MOVE ENDING ADDRESS 
CD8B  BDC3E2                    JSR  LAC20         ;MOVE STRING FROM CURRENT POSITION TO THE 
                      *              TOP OF UNORGANIZED STRING SPACE  
CD8E  9E4B                      LDX  V4B           ;POINT X TO STRING DESCRIPTOR 
CD90  DC45                      LDD  V45           ;* GET NEW STARTING ADDRESS OF STRING AND 
CD92  ED02                      STD  2,X           ;* SAVE IT IN DESCRIPTOR 
CD94  9E45                      LDX  V45           ;GET NEW TOP OF UNORGANIZED STRING SPACE 
CD96  301F                      LEAX -1,X          ;MOVE POINTER BACK ONE 
CD98  7ECD1F                    JMP  LB593         ;JUMP BACK AND REORGANIZE SOME MORE 
                                                     
                                                     
CD9B  DC52            LB60F     LDD  FPA0+2        ;* GET DESCRIPTOR ADDRESS OF STRING A 
CD9D  3406                      PSHS B,A           ;* AND SAVE IT ON THE STACK 
CD9F  BDC9B4                    JSR  LB223         ;GET DESCRIPTOR ADDRESS OF STRING B 
CDA2  BDC8D7                    JSR  LB146         ;TM' ERROR IF NUMERIC VARIABLE 
CDA5  3510                      PULS X             ;* POINT X TO STRING A DESCRIPTOR 
CDA7  9F62                      STX  RESSGN        ;* ADDRESS AND SAVE IT IN RESSGN 
CDA9  E684                      LDB  ,X            ;GET LENGTH OF STRING A 
CDAB  9E52                      LDX  FPA0+2        ;POINT X TO DESCRIPTOR OF STRING B 
CDAD  EB84                      ADDB ,X            ;ADD LENGTH OF STRING B TO STR1NG A 
CDAF  2405                      BCC  LB62A         ;BRANCH IF LENGTH < 256 
CDB1  C61C                      LDB  #2*14         ;STRING TOO LONG' ERROR IF LENGTH > 255 
CDB3  7EC408                    JMP  LAC46         ;JUMP TO ERROR SERVICING ROUTINE 
CDB6  BDCC99          LB62A     JSR  LB50D         ;RESERVE ROOM IN STRING SPACE FOR NEW STRING 
CDB9  9E62                      LDX  RESSGN        ;GET DESCRIPTOR ADDRESS OF STRING A 
CDBB  E684                      LDB  ,X            ;GET LENGTH OF STRING A 
CDBD  8D10                      BSR  LB643         ;MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE 
CDBF  9E4D                      LDX  V4D           ;GET DESCRIPTOR ADDRESS OF STRING B 
CDC1  8D22                      BSR  LB659         ;GET LENGTH AND ADDRESS OF STRING B 
CDC3  8D0C                      BSR  LB645         ;MOVE STRING B INTO REST OF RESERVED BUFFER 
CDC5  9E62                      LDX  RESSGN        ;POINT X TO DESCRIPTOR OF STRING A 
CDC7  8D1C                      BSR  LB659         ;DELETE STRING A IF LAST STRING ON STRING STACK 
CDC9  BDCCD8                    JSR  LB54C         ;PUT STRING DESCRIPTOR ON THE STRING STACK 
CDCC  7EC8F9                    JMP  LB168         ;BRANCH BACK TO EXPRESSION EVALUATION 
                                                     
                      * MOVE (B) BYTES FROM 2,X TO FRESPC                      
CDCF  AE02            LB643     LDX  2,X           ;POINT X TO SOURCE ADDRESS 
CDD1  DE25            LB645     LDU  FRESPC        ;POINT U TO DESTINATION ADDRESS 
CDD3  5C                        INCB               ;COMPENSATION FOR THE DECB BELOW 
CDD4  2004                      BRA  LB64E         ;GO MOVE THE BYTES 
                      * MOVE B BYTES FROM (X) TO (U)                      
CDD6  A680            LB64A     LDA  ,X+           ;* GET A SOURCE BYTE AND MOVE IT 
CDD8  A7C0                      STA  ,U+           ;* TO THE DESTINATION 
CDDA  5A              LB64E     DECB               ;DECREMENT BYTE COUNTER 
CDDB  26F9                      BNE  LB64A         ;BRANCH IF ALL BYTES NOT MOVED 
CDDD  DF25                      STU  FRESPC        ;SAVE ENDING ADDRESS IN FRESPC 
CDDF  39                        RTS                  
                      * RETURN LENGTH (ACCB) AND ADDRESS (X) OF                      
                      * STRING WHOSE DESCRIPTOR IS IN FPA0+2                      
                      * DELETE THE STRING IF IT IS THE LAST ONE                      
                      * PUT ON THE STRING STACK. REMOVE STRING FROM STRING                      
                      * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.                      
CDE0  BDC8D7          LB654     JSR  LB146         ;TM' ERROR IF VARIABLE TYPE = NUMERIC 
CDE3  9E52            LB657     LDX  FPA0+2        ;GET ADDRESS OF SELECTED STRING DESCRIPTOR 
CDE5  E684            LB659     LDB  ,X            ;GET LENGTH OF STRING 
CDE7  8D18                      BSR  LB675         ;* CHECK TO SEE IF THIS STRING DESCRIPTOR WAS 
CDE9  2613                      BNE  LB672         ;* THE LAST ONE PUT ON THE STRING STACK AND 
                      *                            ;* BRANCH IF NOT 
CDEB  AE07                      LDX  5+2,X         ;GET START ADDRESS OF STRING JUST REMOVED 
CDED  301F                      LEAX -1,X          ;MOVE POINTER DOWN ONE 
CDEF  9C23                      CMPX STRTAB        ;COMPARE TO START OF STRING VARIABLES 
CDF1  2608                      BNE  LB66F         ;BRANCH IF THIS STRING IS NOT AT THE BOTTOM 
                      *                            ;OF STRING VARIABLES 
CDF3  3404                      PSHS B             ;SAVE LENGTH; ACCA WAS CLEARED 
CDF5  D323                      ADDD STRTAB        ;* ADD THE LENGTH OF THE JUST REMOVED STRING 
CDF7  DD23                      STD  STRTAB        ;* TO THE START OF STRING VARIABLES - THIS WILL 
                      *                            ;* REMOVE THE STRING FROM THE STRING SPACE 
CDF9  3504                      PULS B             ;RESTORE LENGTH 
CDFB  3001            LB66F     LEAX 1,X           ;ADD ONE TO POINTER 
CDFD  39                        RTS                  
CDFE  AE02            LB672     LDX  2,X           ;*POINT X TO ADDRESS OF STRING NOT 
CE00  39                        RTS                ;*ON THE STRING STACK 
                      * REMOVE STRING FROM STRING STACK. ENTER WITH X                      
                      * POINTING TO A STRING DESCRIPTOR - DELETE THE                      
                      * STRING FROM STACK IF IT IS ON TOP OF THE                      
                      * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG                      
CE01  9C0D            LB675     CMPX LASTPT        ;*COMPARE TO LAST USED DESCRIPTOR ADDRESS 
CE03  2607                      BNE  LB680         ;*ON THE STRING STACK, RETURN IF DESCRIPTOR 
                      *                            ;*ADDRESS NOT ON THE STRING STACK 
CE05  9F0B                      STX  TEMPPT        ;SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE 
CE07  301B                      LEAX -5,X          ;* MOVE LAST USED DESCRIPTOR BACK 5 BYTES 
CE09  9F0D                      STX  LASTPT        ;* AND SAVE AS THE LAST USED DESCRIPTOR ADDR 
CE0B  4F                        CLRA               ;SET ZERO FLAG 
CE0C  39              LB680     RTS                  
                                                     
                      * LEN                          
CE0D  8D03            LEN       BSR  LB686         ;POINT X TO PROPER STRING AND GET LENGTH 
CE0F  7ECC7F          LB683     JMP  LB4F3         ;CONVERT ACCB TO FP NUMBER IN FPA0 
                      * POINT X TO STRING ADDRESS LOAD LENGTH INTO                      
                      * ACCB. ENTER WITH THE STRING;DESCRIPTOR IN                      
                      * BOTTOM TWO BYTES OF FPA0                      
CE12  8DCC            LB686     BSR  LB654         ;GET LENGTH AND ADDRESS OF STRING 
CE14  0F06                      CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
CE16  5D                        TSTB               ;SET FLAGS ACCORDING TO LENGTH 
CE17  39                        RTS                  
                                                     
                      * CHR$                         
CE18  BDCE9A          CHR       JSR  LB70E         ;CONVERT FPA0 TO AN INTEGER IN ACCD 
CE1B  C601            LB68F     LDB  #1            ;* RESERVE ONE BYTE IN 
CE1D  BDCCF9                    JSR  LB56D         ;* THE STRING SPACE 
CE20  9653                      LDA  FPA0+3        ;GET ASCII STRING VALUE 
CE22  BDCC9D                    JSR  LB511         ;SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR 
CE25  A784                      STA  ,X            ;SAVE THE STRING (IT'S ONLY ONE BYTE)
CE27  3262            LB69B     LEAS 2,S           ;PURGE THE RETURN ADDRESS OFF OF THE STACK 
CE29  7ECCD8          LB69D     JMP  LB54C         ;PUT TEMP DESCRIPTOR DATA ONTO STRING STACK 
                                                     
                                                     
CE2C  8D02            ASC       BSR  LB6A4         ;PUT 1ST CHARACTER OF STRING INTO ACCB 
CE2E  20DF                      BRA  LB683         ;CONVERT ACCB INTO FP NUMBER IN FPA0 
CE30  8DE0            LB6A4     BSR  LB686         ;POINT X TO STRING DESCRIPTOR 
CE32  275E                      BEQ  LB706         ;FC' ERROR IF NULL STRING 
CE34  E684                      LDB  ,X            ;GET FIRST BYTE OF STRING 
CE36  39                        RTS                  
                                                     
                                                     
CE37  8D48            LEFT      BSR  LB6F5         ;GET ARGUMENTS FROM STACK 
CE39  4F              LB6AD     CLRA               ;CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$ 
CE3A  E184            LB6AE     CMPB ,X            ;* COMPARE LENGTH PARAMETER TO LENGTH OF 
CE3C  2303                      BLS  LB6B5         ;* STRING AND BRANCH IF LENGTH OF STRING 
                      *                            ;>= LENGTH PARAMETER 
CE3E  E684                      LDB  ,X            ;USE LENGTH OF STRING OTHERWISE 
CE40  4F                        CLRA               ;CLEAR STRING POINTER OFFSET (0 FOR LEFT$) 
CE41  3406            LB6B5     PSHS B,A           ;PUSH PARAMETERS ONTO STACK 
CE43  BDCC9B                    JSR  LB50F         ;RESERVE ACCB BYTES IN THE STRING SPACE 
CE46  9E4D                      LDX  V4D           ;POINT X TO STRING DESCRIPTOR 
CE48  8D9B                      BSR  LB659         ;GET ADDRESS OF OLD STRING (X=ADDRESS) 
CE4A  3504                      PULS B             ;* PULL STRING POINTER OFFSET OFF OF THE STACK 
CE4C  3A                        ABX                ;* AND ADD IT TO STRING ADDRESS 
CE4D  3504                      PULS B             ;PULL LENGTH PARAMETER OFF OF THE STACK 
CE4F  BDCDD1                    JSR  LB645         ;MOVE ACCB BYTES FROM (X) TO [FRESPC] 
CE52  20D5                      BRA  LB69D         ;PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK 
                                                     
                      * RIGHT$                       
CE54  8D2B            RIGHT     BSR  LB6F5         ;GET ARGUMENTS FROM STACK 
CE56  A084                      SUBA ,X            ;ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING 
CE58  40                        NEGA               ;NOW ACCA = LENGTH OF OLD STRING 
CE59  20DF                      BRA  LB6AE         ;PUT NEW STRING IN THE STRING SPACE 
                                                     
                      * MID$                         
CE5B  C6FF            MID       LDB  #$FF          ;* GET DEFAULT VALUE OF LENGTH AND 
CE5D  D753                      STB  FPA0+3        ;* SAVE IT IN FPA0 
CE5F  9D82                      JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
CE61  8129                      CMPA #')           ;ARGUMENT DELIMITER? 
CE63  2705                      BEQ  LB6DE         ;YES - NO LENGTH PARAMETER GIVEN 
CE65  BDC9FE                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
CE68  8D2D                      BSR  LB70B         ;EVALUATE NUMERIC EXPRESSION (LENGTH) 
CE6A  8D15            LB6DE     BSR  LB6F5         ;GET ARGUMENTS FROM STACK 
CE6C  2724                      BEQ  LB706         ;FC' ERROR IF NULL STRING 
CE6E  5F                        CLRB               ;CLEAR LENGTH COUNTER (DEFAULT VALUE) 
CE6F  4A                        DECA               ;*SUOTRACT ONE FROM POSITION PARAMETER (THESE 
CE70  A184                      CMPA ,X            ;*ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE) 
                      *                            ;*AND COMPARE IT TO LENGTH OF OLD STRING 
CE72  24CD                      BCC  LB6B5         ;IF POSITION > LENGTH OF OLD STRING, THEN NEW 
                      *                            ;STRING WILL BE A NULL STRING 
CE74  1F89                      TFR  A,B           ;SAVE ABSOLUTE POSITION PARAMETER IN ACCB 
CE76  E084                      SUBB ,X            ;ACCB=POSITION-LENGTH OF OLD STRING 
CE78  50                        NEGB               ;NOW ACCB=LENGTH OF OLDSTRING-POSITION 
CE79  D153                      CMPB FPA0+3        ;*IF THE AMOUNT OF OLD STRING TO THE RIGHT OF 
CE7B  23C4                      BLS  LB6B5         ;*POSITION IS <= THE LENGTH PARAMETER, BRANCH AND 
                      * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION                      
                      * INSTEAD OF THE LENGTH PARAMETER                      
CE7D  D653                      LDB  FPA0+3        ;GET LENGTH OF NEW STRING 
CE7F  20C0                      BRA  LB6B5         ;PUT NEW STRING IN STRING SPACE 
                      * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC                      
                      * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK                      
CE81  BDC9F8          LB6F5     JSR  LB267         ;SYNTAX CHECK FOR A ")" 
CE84  EEE4                      LDU  ,S            ;LOAD THE RETURN ADDRESS INTO U REGISTER 
CE86  AE65                      LDX  5,S           ;* GET ADDRESS OF STRING AND 
CE88  9F4D                      STX  V4D           ;* SAVE IT IN V4D 
CE8A  A664                      LDA  4,S           ;= PUT LENGTH OF STRING IN 
CE8C  E664                      LDB  4,S           ;= BOTH ACCA AND ACCB 
CE8E  3267                      LEAS 7,S           ;REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK 
CE90  1F35                      TFR  U,PC          ;JUMP TO ADDRESS IN U REGISTER 
CE92  7ECBD6          LB706     JMP  LB44A         ;ILLEGAL FUNCTION CALL' 
                      * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN                      
                      * ACCB - 'FC' ERROR IF EXPRESSION > 255                      
CE95  9D7C            LB709     JSR  GETNCH        ;GET NEXT BASIC INPUT CHARACTER 
CE97  BDC8D2          LB70B     JSR  LB141         ;EVALUATE A NUMERIC EXPRESSION 
CE9A  BDCB75          LB70E     JSR  LB3E9         ;CONVERT FPA0 TO INTEGER IN ACCD 
CE9D  4D                        TSTA               ;TEST MS BYTE OF INTEGER 
CE9E  26F2                      BNE  LB706         ;FC' ERROR IF EXPRESSION > 255 
CEA0  0E82                      JMP  GETCCH        ;GET CURRENT INPUT CHARACTER FROM BASIC 
                                                     
                      * VAL                          
CEA2  BDCE12          VAL       JSR  LB686         ;POINT X TO STRING ADDRESS 
CEA5  102702E1                  LBEQ LBA39         ;IF NULL STRING SET FPA0 
CEA9  DE83                      LDU  CHARAD        ;SAVE INPUT POINTER IN REGISTER U 
CEAB  9F83                      STX  CHARAD        ;POINT INPUT POINTER TO ADDRESS OF STRING 
CEAD  3A                        ABX                ;MOVE POINTER TO END OF STRING TERMINATOR  
CEAE  A684                      LDA  ,X            ;GET LAST BYTE OF STRING 
CEB0  3452                      PSHS U,X,A         ;SAVE INPUT POINTER, STRING TERMINATOR 
                      *         ADDRESS AND CHARACTER   
CEB2  6F84                      CLR  ,X            ;CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION 
CEB4  9D82                      JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
CEB6  BDD463                    JSR  LBD12         ;CONVERT AN ASCII STRING TO FLOATING POINT 
CEB9  3552                      PULS A,X,U         ;RESTORE CHARACTERS AND POINTERS 
CEBB  A784                      STA  ,X            ;REPLACE STRING TERMINATOR 
CEBD  DF83                      STU  CHARAD        ;RESTORE INPUT CHARACTER 
CEBF  39                        RTS                  
                                                     
CEC0  8D07            LB734     BSR  LB73D         ;* EVALUATE AN EXPRESSION, RETURN 
CEC2  9F2B                      STX  BINVAL        ;* THE VALUE IN X; STORE IT IN BINVAL 
CEC4  BDC9FE          LB738     JSR  LB26D         ;SYNTAX CHECK FOR A COMMA 
CEC7  20CE                      BRA  LB70B         ;EVALUATE EXPRESSION IN RANGE 0 <= X < 256 
                      * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF                      
                                                     
CEC9  BDC8D2          LB73D     JSR  LB141         ;EVALUATE NUMERIC EXPRESSION 
CECC  9654            LB740     LDA  FP0SGN        ;GET SIGN OF FPA0 MANTISSA 
CECE  2BC2                      BMI  LB706         ;ILLEGAL FUNCTION CALL' IF NEGATIVE 
CED0  964F                      LDA  FP0EXP        ;GET EXPONENT OF FPA0 
CED2  8190                      CMPA #$90          ;COMPARE TO LARGEST POSITIVE INTEGER 
CED4  22BC                      BHI  LB706         ;ILLEGAL FUNCTION CALL' IF TOO LARGE 
CED6  BDD419                    JSR  LBCC8         ;SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0 
CED9  9E52                      LDX  FPA0+2        ;LOAD X WITH LOWER TWO BYTES OF FPA0 
CEDB  39                        RTS                  
                                                     
                      * PEEK                         
CEDC  8DEE            PEEK      BSR  LB740         ;CONVERT FPA0 TO INTEGER IN REGISTER X 
CEDE  E684                      LDB  ,X            ;GET THE VALUE BEING 'PEEK'ED 
CEE0  7ECC7F                    JMP  LB4F3         ;CONVERT ACCB INTO A FP NUMBER 
                                                     
                      * POKE                         
CEE3  8DDB            POKE      BSR  LB734         ;EVALUATE 2 EXPRESSIONS 
CEE5  9E2B                      LDX  BINVAL        ;GET THE ADDRESS TO BE 'POKE'ED 
CEE7  E784                      STB  ,X            ;STORE THE DATA IN THAT ADDRESS 
CEE9  39                        RTS                  
                                                     
                                                     
                      * LIST                         
CEEA  3401            LIST      PSHS CC            ;SAVE ZERO FLAG ON STACK 
CEEC  BDC71C                    JSR  LAF67         ;CONVERT DECIMAL LINE NUMBER TO BINARY 
CEEF  BDC4A7                    JSR  LAD01         ;* FIND RAM ADDRESS OF THAT LINE NUMBER AND 
CEF2  9F66                      STX  LSTTXT        ;* SAVE IT IN LSTTXT 
CEF4  3501                      PULS CC            ;GET ZERO FLAG FROM STACK 
CEF6  2712                      BEQ  LB784         ;BRANCH IF END OF LINE 
CEF8  9D82                      JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
CEFA  2713                      BEQ  LB789         ;BRANCH IF END OF LINE 
CEFC  81A7                      CMPA #TOK_MINUS    ;MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?) 
CEFE  2609                      BNE  LB783         ;NO - RETURN 
CF00  9D7C                      JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
CF02  2706                      BEQ  LB784         ;BRANCH IF END OF LINE 
CF04  BDC71C                    JSR  LAF67         ;GET ENDING LINE NUMBER 
CF07  2706                      BEQ  LB789         ;BRANCH IF LEGAL LINE NUMBER 
CF09  39              LB783 RTS                      
                      * LIST THE ENTIRE PROGRAM                      
CF0A  CEFFFF          LB784     LDU  #$FFFF        ;* SET THE DEFAULT ENDING LINE NUMBER 
CF0D  DF2B                      STU  BINVAL        ;* TO $FFFF 
CF0F  3262            LB789     LEAS 2,S           ;PURGE RETURN ADDRESS FROM THE STACK 
CF11  9E66                      LDX  LSTTXT        ;POINT X TO STARTING LINE ADDRESS 
CF13  BDD0B1          LB78D     JSR  LB95C         ;MOVE CURSOR TO START OF A NEW LINE 
CF16  BDC19A                    JSR  LA549         ;CHECK FOR A BREAK OR PAUSE 
CF19  EC84                      LDD  ,X            ;GET ADDRESS OF NEXT BASIC LINE 
CF1B  2603                      BNE  LB79F         ;BRANCH IF NOT END OF PROGRAM 
CF1D                  LB797                          
CF1D  7EC427                    JMP  LAC73         ;RETURN TO BASIC'S MAIN INPUT LOOP
CF20  9F66            LB79F     STX  LSTTXT        ;SAVE NEW STARTING LINE ADDRESS 
CF22  EC02                      LDD  2,X           ;* GET THE LINE NUMBER OF THIS LINE AND 
CF24  10932B                    CMPD BINVAL        ;* COMPARE IT TO ENDING LINE NUMBER 
CF27  22F4                      BHI  LB797         ;EXIT IF LINE NUMBER > ENDING LINE NUMBER 
CF29  BDD51D                    JSR  LBDCC         ;PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL 
CF2C  BDD0FD                    JSR  LB9AC         ;SEND A SPACE TO CONSOLE OUT 
CF2F  9E66                      LDX  LSTTXT        ;GET RAM ADDRESS OF THIS LINE 
CF31  8D10                      BSR  LB7C2         ;UNCRUNCH A LINE 
CF33  AE9F0066                  LDX  [LSTTXT]      ;POINT X TO START OF NEXT LINE 
CF37  CE00F4                    LDU  #LINBUF+1     ;POINT U TO BUFFER FULL OF UNCRUNCHED LINE 
CF3A  A6C0            LB7B9     LDA  ,U+           ;GET A BYTE FROM THE BUFFER 
CF3C  27D5                      BEQ  LB78D         ;BRANCH IF END OF BUFFER 
CF3E  BDD102                    JSR  LB9B1         ;SEND CHARACTER TO CONSOLE OUT 
CF41  20F7                      BRA  LB7B9         ;GET ANOTHER CHARACTER 
                                                     
                      * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
CF43  3004            LB7C2     LEAX 4,X           ;MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER 
CF45  108E00F4                  LDY  #LINBUF+1     ;UNCRUNCH LINE INTO LINE INPUT BUFFER 
CF49  A680            LB7CB     LDA  ,X+           ;GET A CHARACTER 
CF4B  2751                      BEQ  LB820         ;BRANCH IF END OF LINE 
CF4D  2B15                      BMI  LB7E6         ;BRANCH IF IT'S A TOKEN
CF4F  813A                      CMPA #':           ;CHECK FOR END OF SUB LINE 
CF51  260D                      BNE  LB7E2         ;BRNCH IF NOT END OF SUB LINE 
CF53  E684                      LDB  ,X            ;GET CHARACTER FOLLOWING COLON 
CF55  C184                      CMPB #TOK_ELSE     ;TOKEN FOR ELSE? 
CF57  27F0                      BEQ  LB7CB         ;YES - DON'T PUT IT IN BUFFER
CF59  C182                      CMPB #TOK_SNGL_Q   ;TOKEN FOR REMARK? 
CF5B  27EC                      BEQ  LB7CB         ;YES - DON'T PUT IT IN BUFFER
CF5D  8C                        FCB  SKP2          ;SKIP TWO BYTES 
CF5E  8621            LB7E0     LDA  #'!           ;EXCLAMATION POINT 
CF60  8D30            LB7E2     BSR  LB814         ;PUT CHARACTER IN BUFFER 
CF62  20E5                      BRA  LB7CB         ;GET ANOTHER CHARACTER 
                                                     
CF64  CEC0E7          LB7E6     LDU  #COMVEC-10    ;FIRST DO COMMANDS 
CF67  81FF                      CMPA #$FF          ;CHECK FOR SECONDARY TOKEN 
CF69  2604                      BNE  LB7F1         ;BRANCH IF NON SECONDARY TOKEN 
CF6B  A680                      LDA  ,X+           ;GET SECONDARY TOKEN 
CF6D  3345                      LEAU 5,U           ;BUMP IT UP TO SECONDARY FUNCTIONS 
CF6F  847F            LB7F1     ANDA #$7F          ;MASK OFF BIT 7 OF TOKEN 
CF71  334A            LB7F3     LEAU 10,U          ;MOVE TO NEXT COMMAND TABLE 
CF73  6DC4                      TST  ,U            ;IS THIS TABLE ENABLED? 
CF75  27E7                      BEQ  LB7E0         ;NO - ILLEGAL TOKEN 
CF77  A0C4                      SUBA ,U            ;SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER 
CF79  2AF6                      BPL  LB7F3         ;BRANCH IF TOKEN NOT IN THIS TABLE 
CF7B  ABC4                      ADDA ,U            ;RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE 
CF7D  EE41                      LDU  1,U           ;POINT U TO COMMAND DICTIONARY TABLE 
CF7F  4A              LB801     DECA               ;DECREMENT TOKEN NUMBER 
CF80  2B06                      BMI  LB80A         ;BRANCH IF THIS IS THE CORRECT TOKEN 
                      * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN                      
CF82  6DC0            LB804     TST  ,U+           ;GRAB A BYTE 
CF84  2AFC                      BPL  LB804         ;BRANCH IF BIT 7 NOT SET 
CF86  20F7                      BRA  LB801         ;GO SEE IF THIS IS THE CORRECT TOKEN 
CF88  A6C4            LB80A     LDA  ,U            ;GET A CHARACTER FROM DICTIONARY TABLE 
CF8A  8D06                      BSR  LB814         ;PUT CHARACTER IN BUFFER 
CF8C  6DC0                      TST  ,U+           ;CHECK FOR START OF NEXT TOKEN 
CF8E  2AF8                      BPL  LB80A         ;BRANCH IF NOT DONE WITH THIS TOKEN 
CF90  20B7                      BRA  LB7CB         ;GO GET ANOTHER CHARACTER 
CF92  108C01ED        LB814     CMPY #LINBUF+LBUFMX ;TEST FOR END OF LINE INPUT BUFFER
CF96  2406                      BCC  LB820         ;BRANCH IF AT END OF BUFFER 
CF98  847F                      ANDA #$7F          ;MASK OFF BIT 7 
CF9A  A7A0                      STA  ,Y+           ;* SAVE CHARACTER IN BUFFER AND 
CF9C  6FA4                      CLR  ,Y            ;* CLEAR NEXT CHARACTER SLOT IN BUFFER 
CF9E  39              LB820     RTS                  
                      *                              
                      * CRUNCH THE LINE THAT THE INPUT POINTER IS                      
                      * POINTING TO INTO THE LINE INPUT BUFFER                      
                      * RETURN LENGTH OF CRUNCHED LINE IN ACCD                      
                      *                              
CF9F  9E83            LB821     LDX  CHARAD        ;GET BASIC'S INPUT POINTER ADDRESS 
CFA1  CE00F3                    LDU  #LINBUF       ;POINT X TO LINE INPUT BUFFER 
CFA4  0F43            LB829     CLR  V43           ;CLEAR ILLEGAL TOKEN FLAG 
CFA6  0F44                      CLR  V44           ;CLEAR DATA FLAG 
CFA8  A680            LB82D     LDA  ,X+           ;GET INPUT CHAR 
CFAA  2721                      BEQ  LB852         ;BRANCH IF END OF LINE 
CFAC  0D43                      TST  V43           ;* CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT 
CFAE  270F                      BEQ  LB844         ;* PROCESSING AN ILLEGAL TOKEN 
CFB0  BDCB2E                    JSR  LB3A2         ;SET CARRY IF NOT UPPER CASE ALPHA 
CFB3  2418                      BCC  LB852         ;BRANCH IF UPPER CASE ALPHA 
CFB5  8130                      CMPA #'0           ;* DON'T CRUNCH ASCII NUMERIC CHARACTERS
CFB7  2504                      BLO  LB842         ;* BRANCH IF NOT NUMERIC 
CFB9  8139                      CMPA #'9           ;* 
CFBB  2310                      BLS  LB852         ;* BRANCH IF NUMERIC 
                      * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC                      
CFBD  0F43            LB842     CLR  V43           ;CLEAR ILLEGAL TOKEN FLAG 
CFBF  8120            LB844     CMPA #SPACE        ;SPACE? 
CFC1  270A                      BEQ  LB852         ;DO NOT REMOVE SPACES 
CFC3  9742                      STA  V42           ;SAVE INPUT CHARACTER AS SCAN DELIMITER 
CFC5  8122                      CMPA #'"           ;CHECK FOR STRING DELIMITER 
CFC7  2738                      BEQ  LB886         ;BRANCH IF STRING 
CFC9  0D44                      TST  V44           ;* CHECK DATA FLAG AND BRANCH IF CLEAR 
CFCB  2719                      BEQ  LB86B         ;* DO NOT CRUNCH DATA 
CFCD  A7C0            LB852     STA  ,U+           ;SAVE CHARACTER IN BUFFER 
CFCF  2706                      BEQ  LB85C         ;BRANCH IF END OF LINE 
CFD1  813A                      CMPA #':           ;* CHECK FOR END OF SUBLINE 
CFD3  27CF                      BEQ  LB829         ;* AND RESET FLAGS IF END OF SUBLINE 
CFD5  20D1            LB85A     BRA  LB82D         ;GO GET ANOTHER CHARACTER 
CFD7  6FC0            LB85C     CLR  ,U+           ;* DOUBLE ZERO AT END OF LINE 
CFD9  6FC0                      CLR  ,U+           ;* 
CFDB  1F30                      TFR  U,D           ;SAVE ADDRESS OF END OF LINE IN ACCD 
CFDD  8300F1                    SUBD #LINHDR       ;LENGTH OF LINE IN ACCD 
CFE0  8E00F2                    LDX  #LINBUF-1     ;* SET THE INPUT POINTER TO ONE BEFORE 
CFE3  9F83                      STX  CHARAD        ;* THE START OF THE CRUNCHED LINE 
CFE5  39                        RTS                ;EXIT 'CRUNCH'   
CFE6  813F            LB86B     CMPA #'?           ;CHECK FOR "?" - PRINT ABBREVIATION 
CFE8  2604                      BNE  LB873         ;BRANCH IF NOT PRINT ABBREVIATION 
CFEA  8687                      LDA  #TOK_PRINT    ;* GET THE PRINT TOKEN AND SAVE IT 
CFEC  20DF                      BRA  LB852         ;* IN BUFFER 
CFEE  8127            LB873     CMPA #''           ;APOSTROPHE IS SAME AS REM 
CFF0  2613                      BNE  LB88A         ;BRANCH IF NOT REMARK 
CFF2  CC3A82                    LDD  #$3A00+TOK_SNGL_Q ;COLON, REM TOKEN 
CFF5  EDC1                      STD  ,U++          ;SAVE IN BUFFER 
CFF7  0F42            LB87C     CLR  V42           ;SET DELIMITER = 0 (END OF LINE) 
CFF9  A680            LB87E     LDA  ,X+           ;SCAN TILL WE MATCH [V42] 
CFFB  27D0                      BEQ  LB852         ;BRANCH IF END OF LINE 
CFFD  9142                      CMPA V42           ;DELIMITER? 
CFFF  27CC                      BEQ  LB852         ;BRANCH OUT IF SO 
D001  A7C0            LB886     STA  ,U+           ;DON'T CRUNCH REMARKS OR STRINGS
D003  20F4                      BRA  LB87E         ;GO GET MORE STRING OR REMARK 
D005  8130            LB88A     CMPA #'0           ;* LESS THAN ASCII ZERO? 
D007  2504                      BCS  LB892         ;* BRANCH IF SO 
D009  813C                      CMPA #';+1         ;= CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON 
D00B  25C0                      BCS  LB852         ;= AND INSERT IN BUFFER IF SO 
D00D  301F            LB892     LEAX -1,X          ;MOVE INPUT POINTER BACK ONE 
D00F  3450                      PSHS U,X           ;SAVE POINTERS TO INPUT STRING, OUTPUT STRING 
D011  0F41                      CLR  V41           ;TOKEN FLAG 0 = COMMAND, FF = SECONDARY 
D013  CEC0E7                    LDU  #COMVEC-10    ;POINT U TO COMMAND INTERPRETATION 
                      *                            ;TABLE FOR BASIC - 10 
D016  0F42            LB89B     CLR  V42           ;INITIALIZE V42 AS TOKEN COUNTER 
D018  334A            LB89D     LEAU 10,U          ;MOVE TO NEXT COMMAND INTERPRETATION TABLE 
D01A  A6C4                      LDA  ,U            ;GET NUMBER OF COMMANDS 
D01C  2731                      BEQ  LB8D4         ;GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE 
D01E  10AE41                    LDY  1,U           ;POINT Y TO COMMAND DICTIONARY TABLE 
D021  AEE4            LB8A6     LDX  ,S            ;GET POINTER TO INPUT STRING 
D023  E6A0            LB8A8     LDB  ,Y+           ;GET A BYTE FROM DICTIONARY TABLE 
D025  E080                      SUBB ,X+           ;SUBTRACT INPUT CHARACTER 
D027  27FA                      BEQ  LB8A8         ;LOOP IF SAME 
D029  C180                      CMPB #$80          ;LAST CHAR IN RESERVED WORD TABLE HAD 
                      *                            ;BIT 7 SET, SO IF WE HAVE $80 HERE 
                      *                            ;THEN IT IS A GOOD COMPARE 
D02B  2638                      BNE  LB8EA         ;BRANCH IF NO MATCH - CHECK ANOTHER COMMAND 
D02D  3262                      LEAS 2,S           ;DELETE OLD INPUT POINTER FROM STACK 
D02F  3540                      PULS U             ;GET POINTER TO OUTPUT STRING 
D031  DA42                      ORB  V42           ;OR IN THE TABLE POSITION TO MAKE THE TOKEN 
                      *                            ;- NOTE THAT B ALREADY HAD $80 IN IT - 
D033  9641                      LDA  V41           ;* CHECK TOKEN FLAG AND BRANCH 
D035  2606                      BNE  LB8C2         ;* IF SECONDARY 
D037  C184                      CMPB #TOK_ELSE     ;IS IT ELSE TOKEN? 
D039  2606                      BNE  LB8C6         ;NO 
D03B  863A                      LDA  #':           ;PUT A COLON (SUBLINE) BEFORE ELSE TOKEN 
D03D  EDC1            LB8C2     STD  ,U++          ;SECONDARY TOKENS PRECEEDED BY $FF 
D03F  2094                      BRA  LB85A         ;GO PROCESS MORE INPUT CHARACTERS 
D041  E7C0            LB8C6     STB  ,U+           ;SAVE THIS TOKEN 
D043  C186                      CMPB #TOK_DATA     ;DATA TOKEN? 
D045  2602                      BNE  LB8CE         ;NO 
D047  0C44                      INC  V44           ;SET DATA FLAG 
D049  C182            LB8CE     CMPB #TOK_REM      ;REM TOKEN? 
D04B  27AA                      BEQ  LB87C         ;YES 
D04D  2086            LB8D2     BRA  LB85A         ;GO PROCESS MORE INPUT CHARACTERS 
                      * CHECK FOR A SECONDARY TOKEN                      
D04F  CEC0EC          LB8D4     LDU  #COMVEC-5     ;NOW DO SECONDARY FUNCTIONS 
D052  0341                      COM  V41           ;TOGGLE THE TOKEN FLAG 
D054  26C0                      BNE  LB89B         ;BRANCH IF NOW CHECKING SECONDARY COMMANDS 
                                                     
                      * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO                      
                      * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN                      
D056  3550                      PULS X,U           ;RESTORE INPUT AND OUTPUT POINTERS 
D058  A680                      LDA  ,X+           ;* MOVE THE FIRST CHARACTER OF AN 
D05A  A7C0                      STA  ,U+           ;* ILLEGAL TOKEN 
D05C  BDCB2E                    JSR  LB3A2         ;SET CARRY IF NOT ALPHA 
D05F  25EC                      BCS  LB8D2         ;BRANCH IF NOT ALPHA 
D061  0343                      COM  V43           ;SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA 
D063  20E8                      BRA  LB8D2         ;PROCESS MORE INPUT CHARACTERS 
D065  0C42            LB8EA     INC  V42           ;INCREMENT TOKEN COUNTER 
D067  4A                        DECA               ;DECR COMMAND COUNTER 
D068  27AE                      BEQ  LB89D         ;GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE 
D06A  313F                      LEAY -1,Y          ;MOVE POINTER BACK ONE 
D06C  E6A0            LB8F1     LDB  ,Y+           ;* GET TO NEXT 
D06E  2AFC                      BPL  LB8F1         ;* RESERVED WORD 
D070  20AF                      BRA  LB8A6         ;GO SEE IF THIS WORD IS A MATCH 
                                                     
                      * PRINT                        
D072  2739            PRINT     BEQ  LB958         ;BRANCH IF NO ARGUMENT 
D074  8D01                      BSR  LB8FE         ;CHECK FOR ALL PRINT OPTIONS 
D076  39                        RTS                  
D077                  LB8FE                          
D077  BDDFD7          LB918     JSR  XVEC9         ;CALL EXTENDED BASIC ADD-IN 
D07A  273E            LB91B     BEQ  LB965         ;RETURN IF END OF LINE 
D07C  819F            LB91D     CMPA #TOK_TAB      ;TOKEN FOR TAB( ? 
D07E  2753                      BEQ  LB97E         ;YES 
D080  812C                      CMPA #',           ;COMMA? 
D082  2737                      BEQ  LB966         ;YES - ADVANCE TO NEXT TAB FIELD 
D084  813B                      CMPA #';           ;SEMICOLON? 
D086  2760                      BEQ  LB997         ;YES - DO NOT ADVANCE CURSOR 
D088  BDC8E7                    JSR  LB156         ;EVALUATE EXPRESSION 
D08B  9606                      LDA  VALTYP        ;* GET VARIABLE TYPE AND 
D08D  3402                      PSHS A             ;* SAVE IT ON THE STACK 
D08F  2606                      BNE  LB938         ;BRANCH IF STRING VARIABLE 
D091  BDD52A                    JSR  LBDD9         ;CONVERT FP NUMBER TO AN ASCII STRING 
D094  BDCCA2                    JSR  LB516         ;PARSE A STRING FROM (X-1) AND PUT 
                      *                            ;DESCRIPTOR ON STRING STACK 
D097  8D57            LB938     BSR  LB99F         ;PRINT STRING POINTED TO BY X 
D099  3504                      PULS B             ;GET VARIABLE TYPE BACK 
D09B  BDC133                    JSR  LA35F         ;SET UP TAB WIDTH ZONE, ETC 
D09E  5D              LB949     TSTB               ;CHECK CURRENT PRINT POSITION 
D09F  2608                      BNE  LB954         ;BRANCH IF NOT AT START OF LINE 
D0A1  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
D0A3  812C                      CMPA #',           ;COMMA? 
D0A5  2714                      BEQ  LB966         ;SKIP TO NEXT TAB FIELD 
D0A7  8D54                      BSR  LB9AC         ;SEND A SPACE TO CONSOLE OUT 
D0A9  9D82            LB954     JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
D0AB  26CF                      BNE  LB91D         ;BRANCH IF NOT END OF LINE 
D0AD  860D            LB958     LDA  #CR           ;* SEND A CR TO 
D0AF  2051                      BRA  LB9B1         ;* CONSOLE OUT 
D0B1  BDC133          LB95C     JSR  LA35F         ;SET UP TAB WIDTH, ZONE ETC 
D0B4  27F7                      BEQ  LB958         ;BRANCH IF WIDTH = ZERO 
D0B6  966C                      LDA  DEVPOS        ;GET PRINT POSITION 
D0B8  26F3                      BNE  LB958         ;BRANCH IF NOT AT START OF LINE 
D0BA  39              LB965     RTS                  
                      * SKIP TO NEXT TAB FIELD                      
D0BB  BDC133          LB966     JSR  LA35F         ;SET UP TAB WIDTH, ZONE ETC 
D0BE  270A                      BEQ  LB975         ;BRANCH IF LINE WIDTH = 0 (CASSETTE) 
D0C0  D66C                      LDB  DEVPOS        ;GET CURRENT POSITION 
D0C2  D16B                      CMPB DEVLCF        ;COMPARE TO LAST TAB ZONE 
D0C4  2506                      BCS  LB977         ;BRANCH IF < LAST TAB ZONE 
D0C6  8DE5                      BSR  LB958         ;SEND A CARRIAGE RETURN TO CONSOLE OUT 
D0C8  201E                      BRA  LB997         ;GET MORE DATA 
D0CA  D66C            LB975     LDB  DEVPOS        ;* 
D0CC  D06A            LB977     SUBB DEVCFW        ;* SUBTRACT TAB FIELD WIDTH FROM CURRENT 
D0CE  24FC                      BCC  LB977         ;* POSITION UNTIL CARRY SET - NEGATING THE 
D0D0  50                        NEGB               ;* REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT 
                      *              * TAB ZONE IN ACCB  
D0D1  2010                      BRA  LB98E         ;GO ADVANCE TO NEXT TAB ZONE 
                                                     
                      * PRINT TAB(                      
D0D3  BDCE95          LB97E     JSR  LB709         ;EVALUATE EXPRESSION - RETURN VALUE IN B 
D0D6  8129                      CMPA #')           ;* 'SYNTAX' ERROR IF NOT ')' 
D0D8  1026F92C                  LBNE LB277         ;* 
D0DC  BDC133                    JSR  LA35F         ;SET UP TAB WIDTH, ZONE ETC 
D0DF  D06C                      SUBB DEVPOS        ;GET DIFFERENCE OF PRINT POSITION & TAB POSITION 
D0E1  2305                      BLS  LB997         ;BRANCH IF TAB POSITION < CURRENT POSITION 
D0E3                  LB98E                          
D0E3  8D18            LB992     BSR  LB9AC         ;SEND A SPACE TO CONSOLE OUT 
D0E5  5A                        DECB               ;DECREMENT DIFFERENCE COUNT 
D0E6  26FB                      BNE  LB992         ;BRANCH UNTIL CURRENT POSITION = TAB POSITION 
D0E8  9D7C            LB997     JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
D0EA  7ED07A                    JMP  LB91B         ;LOOK FOR MORE PRINT DATA 
                      * COPY A STRING FROM (X) TO CONSOLE OUT                      
D0ED  BDCCA4          LB99C     JSR  LB518         ;PARSE A STRING FROM X AND PUT 
                      *         DESCRIPTOR ON STRING STACK  
D0F0  BDCDE3          LB99F     JSR  LB657         ;GET LENGTH OF STRING AND REMOVE 
                      *         DESCRIPTOR FROM STRING STACK  
D0F3  5C                        INCB               ;COMPENSATE FOR DECB BELOW 
D0F4  5A              LB9A3     DECB               ;DECREMENT COUNTER 
D0F5  27C3                      BEQ  LB965         ;EXIT ROUTINE 
D0F7  A680                      LDA  ,X+           ;GET A CHARACTER FROM X 
D0F9  8D07                      BSR  LB9B1         ;SEND TO CONSOLE OUT 
D0FB  20F7                      BRA  LB9A3         ;KEEP LOOPING 
D0FD  8620            LB9AC     LDA  #SPACE        ;SPACE TO CONSOLE OUT 
D0FF  8C                        FCB  SKP2          ;SKIP NEXT TWO BYTES 
D100  863F            LB9AF     LDA  #'?           ;QUESTION MARK TO CONSOLE OUT 
D102  7EC017          LB9B1     JMP  PUTCHR        ;JUMP TO CONSOLE OUT 
                                                     
                      * FLOATING POINT MATH PACKAGE                      
                                                     
                      * ADD .5 TO FPA0                      
D105  8ED611          LB9B4     LDX  #LBEC0        ;FLOATING POINT CONSTANT (.5) 
D108  2009                      BRA  LB9C2         ;ADD .5 TO FPA0 
                      * SUBTRACT FPA0 FROM FP NUMBER POINTED                      
                      * TO BY (X), LEAVE RESULT IN FPA0                      
D10A  BDD280          LB9B9     JSR  LBB2F         ;COPY PACKED FP DATA FROM (X) TO FPA1 
                                                     
                      * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER                      
                      * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)                      
D10D  0354            LB9BC     COM  FP0SGN        ;CHANGE MANTISSA SIGN OF FPA0 
D10F  0362                      COM  RESSGN        ;REVERSE RESULT SIGN FLAG 
D111  2003                      BRA  LB9C5         ;GO ADD FPA1 AND FPA0 
                      * ADD FP NUMBER POINTED TO BY                      
                      * (X) TO FPA0 - LEAVE RESULT IN FPA0                      
D113  BDD280          LB9C2     JSR  LBB2F         ;UNPACK PACKED FP DATA FROM (X) TO 
                      *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA  
                                                     
                      * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO                      
                                                     
D116  5D              LB9C5     TSTB               ;CHECK EXPONENT OF FPA0 
D117  10270280                  LBEQ LBC4A         ;COPY FPA1 TO FPA0 IF FPA0 = 
D11B  8E005C                    LDX  #FP1EXP       ;POINT X TO FPA1 
D11E  1F89            LB9CD     TFR  A,B           ;PUT EXPONENT OF FPA1 INTO ACCB 
D120  5D                        TSTB               ;CHECK EXPONENT 
D121  276C                      BEQ  LBA3E         ;RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0) 
D123  D04F                      SUBB FP0EXP        ;SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1 
D125  2769                      BEQ  LBA3F         ;BRANCH IF EXPONENTS ARE EQUAL 
D127  250A                      BCS  LB9E2         ;BRANCH IF EXPONENT FPA0 > FPA1 
D129  974F                      STA  FP0EXP        ;REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT 
D12B  9661                      LDA  FP1SGN        ;* REPLACE FPA0 MANTISSA SIGN 
D12D  9754                      STA  FP0SGN        ;* WITH FPA1 MANTISSA SIGN 
D12F  8E004F                    LDX  #FP0EXP       ;POINT X TO FPA0 
D132  50                        NEGB               ;NEGATE DIFFERENCE OF EXPONENTS 
D133  C1F8            LB9E2     CMPB #-8           ;TEST DIFFERENCE OF EXPONENTS 
D135  2F59                      BLE  LBA3F         ;BRANCH IF DIFFERENCE OF EXPONENTS <= 8 
D137  4F                        CLRA               ;CLEAR OVERFLOW BYTE 
D138  6401                      LSR  1,X           ;SHIFT MS BYTE OF MANTISSA; BIT 7 = 0 
D13A  BDD20B                    JSR  LBABA         ;GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES 
D13D  D662            LB9EC     LDB  RESSGN        ;GET SIGN FLAG 
D13F  2A0B                      BPL  LB9FB         ;BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME 
D141  6301                      COM  1,X           ;* COMPLEMENT MANTISSA POINTED 
D143  6302                      COM  2,X           ;* TO BY (X) THE 
D145  6303                      COM  3,X           ;* ADCA BELOW WILL 
D147  6304                      COM  4,X           ;* CONVERT THIS OPERATION 
D149  43                        COMA               ;* INTO A NEG (MANTISSA) 
D14A  8900                      ADCA #0            ;ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG 
                      * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA                      
                      *                              
                      * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0                      
D14C  9763            LB9FB     STA  FPSBYT        ;SAVE FPA SUB BYTE 
D14E  9653                      LDA  FPA0+3        ;* ADD LS BYTE 
D150  9960                      ADCA FPA1+3        ;* OF MANTISSA 
D152  9753                      STA  FPA0+3        ;SAVE IN FPA0 LSB 
D154  9652                      LDA  FPA0+2        ;* ADD NEXT BYTE 
D156  995F                      ADCA FPA1+2        ;* OF MANTISSA 
D158  9752                      STA  FPA0+2        ;SAVE IN FPA0 
D15A  9651                      LDA  FPA0+1        ;* ADD NEXT BYTE 
D15C  995E                      ADCA FPA1+1        ;* OF MANTISSA 
D15E  9751                      STA  FPA0+1        ;SAVE IN FPA0 
D160  9650                      LDA  FPA0          ;* ADD MS BYTE 
D162  995D                      ADCA FPA1          ;* OF MANTISSA 
D164  9750                      STA  FPA0          ;SAVE IN FPA0 
D166  5D                        TSTB               ;TEST SIGN FLAG  
D167  2A44                      BPL  LBA5C         ;BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE 
D169  2502            LBA18     BCS  LBA1C         ;BRANCH IF POSITIVE MANTISSA 
D16B  8D5D                      BSR  LBA79         ;NEGATE FPA0 MANTISSA 
                                                     
                      * NORMALIZE FPA0                      
D16D  5F              LBA1C     CLRB               ;CLEAR TEMPORARY EXPONENT ACCUMULATOR 
D16E  9650            LBA1D     LDA  FPA0          ;TEST MSB OF MANTISSA 
D170  262E                      BNE  LBA4F         ;BRANCH IF <> 0 
D172  9651                      LDA  FPA0+1        ;* IF THE MSB IS 
D174  9750                      STA  FPA0          ;* 0, THEN SHIFT THE 
D176  9652                      LDA  FPA0+2        ;* MANTISSA A WHOLE BYTE 
D178  9751                      STA  FPA0+1        ;* AT A TIME. THIS 
D17A  9653                      LDA  FPA0+3        ;* IS FASTER THAN ONE 
D17C  9752                      STA  FPA0+2        ;* BIT AT A TIME 
D17E  9663                      LDA  FPSBYT        ;* BUT USES MORE MEMORY. 
D180  9753                      STA  FPA0+3        ;* FPSBYT, THE CARRY IN 
D182  0F63                      CLR  FPSBYT        ;* BYTE, REPLACES THE MATISSA LSB. 
D184  CB08                      ADDB #8            ;SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT 
D186  C128                      CMPB #5*8          ;CHECK FOR 5 SHIFTS 
D188  2DE4                      BLT  LBA1D         ;BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0 
D18A  4F              LBA39     CLRA               ;A ZERO EXPONENT = 0 FLOATING POINT 
D18B  974F            LBA3A     STA  FP0EXP        ;ZERO OUT THE EXPONENT 
D18D  9754                      STA  FP0SGN        ;ZERO OUT THE MANTISSA SIGN 
D18F  39              LBA3E     RTS                  
D190  8D6D            LBA3F     BSR  LBAAE         ;SHIFT FPA0 MANTISSA TO RIGHT 
D192  5F                        CLRB               ;CLEAR CARRY FLAG 
D193  20A8                      BRA  LB9EC           
                      * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7                      
                      * OF MATISSA MS BYTE = 1                      
D195  5C              LBA44     INCB               ;ADD ONE TO EXPONENT ACCUMULATOR 
D196  0863                      ASL  FPSBYT        ;SHIFT SUB BYTE ONE LEFT 
D198  0953                      ROL  FPA0+3        ;SHIFT LS BYTE 
D19A  0952                      ROL  FPA0+2        ;SHIFT NS BYTE 
D19C  0951                      ROL  FPA0+1        ;SHIFT NS BYTE 
D19E  0950                      ROL  FPA0          ;SHIFT MS BYTE 
D1A0  2AF3            LBA4F     BPL  LBA44         ;BRANCH IF NOT YET NORMALIZED 
D1A2  964F                      LDA  FP0EXP        ;GET CURRENT EXPONENT 
D1A4  3404                      PSHS B             ;SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION 
D1A6  A0E0                      SUBA ,S+           ;SUBTRACT ACCUMULATED EXPONENT MODIFIER 
D1A8  974F                      STA  FP0EXP        ;SAVE AS NEW EXPONENT 
D1AA  23DE                      BLS  LBA39         ;SET FPA0 = 0 IF THE NORMALIZATION CAUSED 
                      *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE  
                      *         SIZE OF THE EXPONENT  
D1AC  8C                        FCB  SKP2          ;SKIP 2 BYTES 
D1AD  2508            LBA5C     BCS  LBA66         ;BRANCH IF MANTISSA OVERFLOW 
D1AF  0863                      ASL  FPSBYT        ;SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF 
                      *                            ;FLAG (TRUNCATE THE REST OF SUB BYTE) 
D1B1  8600                      LDA  #0            ;CLRA, BUT DO NOT CHANGE CARRY FLAG 
D1B3  9763                      STA  FPSBYT        ;CLEAR THE SUB BYTE 
D1B5  200C                      BRA  LBA72         ;GO ROUND-OFF RESULT 
D1B7  0C4F            LBA66     INC  FP0EXP        ;INCREMENT EXPONENT - MULTIPLY BY 2 
D1B9  2728                      BEQ  LBA92         ;OVERFLOW ERROR IF CARRY PAST $FF 
D1BB  0650                      ROR  FPA0          ;* SHIFT MANTISSA 
D1BD  0651                      ROR  FPA0+1        ;* ONE TO 
D1BF  0652                      ROR  FPA0+2        ;* THE RIGHT - 
D1C1  0653                      ROR  FPA0+3        ;* DIVIDE BY TWO 
D1C3  2404            LBA72     BCC  LBA78         ;BRANCH IF NO ROUND-OFF NEEDED 
D1C5  8D0D                      BSR  LBA83         ;ADD ONE TO MANTISSA - ROUND OFF 
D1C7  27EE                      BEQ  LBA66         ;BRANCH iF OVERFLOW - MANTISSA = 0 
D1C9  39              LBA78     RTS                  
                      * NEGATE FPA0 MANTISSA                      
D1CA  0354            LBA79     COM  FP0SGN        ;TOGGLE SIGN OF MANTISSA 
D1CC  0350            LBA7B     COM  FPA0          ;* COMPLEMENT ALL 4 MANTISSA BYTES 
D1CE  0351                      COM  FPA0+1        ;* 
D1D0  0352                      COM  FPA0+2        ;* 
D1D2  0353                      COM  FPA0+3        ;* 
                      * ADD ONE TO FPA0 MANTISSA                      
D1D4  9E52            LBA83     LDX  FPA0+2        ;* GET BOTTOM 2 MANTISSA 
D1D6  3001                      LEAX 1,X           ;* BYTES, ADD ONE TO 
D1D8  9F52                      STX  FPA0+2        ;* THEM AND SAVE THEM 
D1DA  2606                      BNE  LBA91         ;BRANCH IF NO OVERFLOW 
D1DC  9E50                      LDX  FPA0          ;* IF OVERFLOW ADD ONE 
D1DE  3001                      LEAX 1,X           ;* TO TOP 2 MANTISSA 
D1E0  9F50                      STX  FPA0          ;* BYTES AND SAVE THEM 
D1E2  39              LBA91     RTS                  
D1E3  C60A            LBA92     LDB  #2*5          ;OV' OVERFLOW ERROR 
D1E5  7EC408                    JMP  LAC46         ;PROCESS AN ERROR 
D1E8  8E0012          LBA97     LDX  #FPA2-1       ;POINT X TO FPA2 
                      * SHIFT FPA POINTED TO BY (X);TO                      
                      * THE RIGHT -(B) TIMES. EXIT WITH                      
                      * ACCA CONTAINING DATA SHIFTED OUT                      
                      * TO THE RIGHT (SUB BYTE) AND;THE DATA                      
                      * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY                      
D1EB  A604            LBA9A     LDA  4,X           ;GET LS BYTE OF MANTISSA (X) 
D1ED  9763                      STA  FPSBYT        ;SAVE IN FPA SUB BYTE 
D1EF  A603                      LDA  3,X           ;* SHIFT THE NEXT THREE BYTES OF THE 
D1F1  A704                      STA  4,X           ;* MANTISSA RIGHT ONE COMPLETE BYTE. 
D1F3  A602                      LDA  2,X           ;* 
D1F5  A703                      STA  3,X           ;* 
D1F7  A601                      LDA  1,X           ;* 
D1F9  A702                      STA  2,X           ;* 
D1FB  965B                      LDA  FPCARY        ;GET THE CARRY IN BYTE 
D1FD  A701                      STA  1,X           ;STORE AS THE MS MANTISSA BYTE OF (X) 
D1FF  CB08            LBAAE     ADDB #8            ;ADD 8 TO DIFFERENCE OF EXPONENTS 
D201  2FE8                      BLE  LBA9A         ;BRANCH IF EXPONENT DIFFERENCE < -8 
D203  9663                      LDA  FPSBYT        ;GET FPA SUB BYTE 
D205  C008                      SUBB #8            ;CAST OUT THE 8 ADDED IN ABOVE 
D207  270C                      BEQ  LBAC4         ;BRANCH IF EXPONENT DIFFERENCE = 0 
                                                     
                                                     
D209  6701            LBAB8     ASR  1,X           ;* SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT 
D20B  6602            LBABA     ROR  2,X           ;* 
D20D  6603                      ROR  3,X           ;* 
D20F  6604                      ROR  4,X           ;* 
D211  46                        RORA               ;* 
D212  5C                        INCB               ;ADD ONE TO EXPONENT DIFFERENCE 
D213  26F4                      BNE  LBAB8         ;BRANCH IF EXPONENTS NOT = 
D215  39              LBAC4     RTS                  
D216  8100000000      LBAC5     FCB  $81,$00,$00,$00,$00 ;FLOATING POINT CONSTANT 1.0 
                                                     
                      * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY                      
                      * FPA0 BY (X) - RETURN PRODUCT IN FPA0                      
D21B  8D63            LBACA     BSR  LBB2F         ;MOVE PACKED FPA FROM (X) TO FPA1 
D21D  2760            LBACC     BEQ  LBB2E         ;BRANCH IF EXPONENT OF FPA0 = 0 
D21F  8D78                      BSR  LBB48         ;CALCULATE EXPONENT OF PRODUCT 
                      * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE                      
                      * HIGH ORDER BYTES OF PRODUCT;IN FPA0. THE                      
                      * LOW ORDER FOUR BYTES OF THE;PRODUCT WILL                      
                      * BE STORED IN VAB-VAE.                      
D221  8600            LBAD0     LDA  #0            ;* ZERO OUT MANTISSA OF FPA2 
D223  9713                      STA  FPA2          ;* 
D225  9714                      STA  FPA2+1        ;* 
D227  9715                      STA  FPA2+2        ;* 
D229  9716                      STA  FPA2+3        ;* 
D22B  D653                      LDB  FPA0+3        ;GET LS BYTE OF FPA0 
D22D  8D22                      BSR  LBB00         ;MULTIPLY BY FPA1 
D22F  D663                      LDB  FPSBYT        ;* TEMPORARILY SAVE SUB BYTE 4 
D231  D78B                      STB  VAE           ;* 
D233  D652                      LDB  FPA0+2        ;GET NUMBER 3 MANTISSA BYTE OF FPA0 
D235  8D1A                      BSR  LBB00         ;MULTIPLY BY FPA1 
D237  D663                      LDB  FPSBYT        ;* TEMPORARILY SAVE SUB BYTE 3 
D239  D78A                      STB  VAD           ;* 
D23B  D651                      LDB  FPA0+1        ;GET NUMBER 2 MANTISSA BYTE OF FPA0 
D23D  8D12                      BSR  LBB00         ;MULTIPLY BY FPA1 
D23F  D663                      LDB  FPSBYT        ;* TEMPORARILY SAVE SUB BYTE 2 
D241  D789                      STB  VAC           ;* 
D243  D650                      LDB  FPA0          ;GET MS BYTE OF FPA0 MANTISSA 
D245  8D0C                      BSR  LBB02         ;MULTIPLY BY FPA1 
D247  D663                      LDB  FPSBYT        ;* TEMPORARILY SAVE SUB BYTE 1 
D249  D788                      STB  VAB           ;* 
D24B  BDD35C                    JSR  LBC0B         ;COPY MANTISSA FROM FPA2 TO FPA0 
D24E  7ED16D                    JMP  LBA1C         ;NORMALIZE FPA0 
D251  2795            LBB00     BEQ  LBA97         ;SHIFT FPA2 ONE BYTE TO RIGHT 
D253  43              LBB02     COMA               ;SET CARRY FLAG 
                      * MULTIPLY FPA1 MANTISSA BY ACCB AND                      
                      * ADD PRODUCT TO FPA2 MANTISSA                      
D254  9613            LBB03     LDA  FPA2          ;GET FPA2 MS BYTE 
D256  56                        RORB               ;ROTATE CARRY FLAG INTO SHIFT COUNTER;  
                      *         DATA BIT INTO CARRY  
D257  2726                      BEQ  LBB2E         ;BRANCH WHEN 8 SHIFTS DONE 
D259  2416                      BCC  LBB20         ;DO NOT ADD FPA1 IF DATA BIT = 0 
D25B  9616                      LDA  FPA2+3        ;* ADD MANTISSA LS BYTE 
D25D  9B60                      ADDA FPA1+3        ;* 
D25F  9716                      STA  FPA2+3        ;* 
D261  9615                      LDA  FPA2+2        ;= ADD MANTISSA NUMBER 3 BYTE 
D263  995F                      ADCA FPA1+2        ;= 
D265  9715                      STA  FPA2+2        ;= 
D267  9614                      LDA  FPA2+1        ;* ADD MANTISSA NUMBER 2 BYTE 
D269  995E                      ADCA FPA1+1        ;* 
D26B  9714                      STA  FPA2+1        ;* 
D26D  9613                      LDA  FPA2          ;= ADD MANTISSA MS BYTE 
D26F  995D                      ADCA FPA1          ;= 
D271  46              LBB20     RORA               ;* ROTATE CARRY;INTO MS BYTE  
D272  9713                      STA  FPA2          ;* 
D274  0614                      ROR  FPA2+1        ;= ROTATE FPA2 ONE BIT TO THE RIGHT 
D276  0615                      ROR  FPA2+2        ;= 
D278  0616                      ROR  FPA2+3        ;= 
D27A  0663                      ROR  FPSBYT        ;= 
D27C  4F                        CLRA               ;CLEAR CARRY FLAG 
D27D  20D5                      BRA  LBB03         ;KEEP LOOPING 
D27F  39              LBB2E     RTS                  
                      * UNPACK A FP NUMBER FROM (X);TO FPA1                      
D280  EC01            LBB2F     LDD  1,X           ;GET TWO MSB BYTES OF MANTISSA FROM 
                      *         FPA  POINTED TO BY X  
D282  9761                      STA  FP1SGN        ;SAVE PACKED MANTISSA SIGN BYTE 
D284  8A80                      ORA  #$80          ;FORCE BIT 7 OF MSB MANTISSA = 1 
D286  DD5D                      STD  FPA1          ;SAVE 2 MSB BYTES IN FPA1 
D288  D661                      LDB  FP1SGN        ;* GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0 
D28A  D854                      EORB FP0SGN        ;* SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE, 
D28C  D762                      STB  RESSGN        ;* NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED 
                      *                            ;* MANTISSA SIGN BYTE 
D28E  EC03                      LDD  3,X           ;= GET 2 LSB BYTES OF MANTISSA 
D290  DD5F                      STD  FPA1+2        ;= AND PUT IN FPA1 
D292  A684                      LDA  ,X            ;* GET EXPONENT FROM (X) AND 
D294  975C                      STA  FP1EXP        ;* PUT IN EXPONENT OF FPA1 
D296  D64F                      LDB  FP0EXP        ;GET EXPONENT OF FPA0 
D298  39                        RTS                  
                      * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1                      
                      * ENTER WITH EXPONENT OF FPA1;IN ACCA                      
D299  4D              LBB48     TSTA               ;TEST EXPONENT OF FPA1 
D29A  2716                      BEQ  LBB61         ;PURGE RETURN ADDRESS & SET FPA0 = 0 
D29C  9B4F                      ADDA FP0EXP        ;ADD FPA1 EXPONENT TO FPA0 EXPONENT 
D29E  46                        RORA               ;ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY 
D29F  49                        ROLA               ;SET OVERFLOW FLAG 
D2A0  2810                      BVC  LBB61         ;BRANCH IF EXPONENT TOO LARGE OR SMALL 
D2A2  8B80                      ADDA #$80          ;ADD $80 BIAS TO EXPONENT 
D2A4  974F                      STA  FP0EXP        ;SAVE NEW EXPONENT 
D2A6  270C                      BEQ  LBB63         ;SET FPA0 
D2A8  9662                      LDA  RESSGN        ;GET MANTISSA SIGN 
D2AA  9754                      STA  FP0SGN        ;SAVE AS MANTISSA SIGN OF FPA0 
D2AC  39                        RTS                  
                      * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0                      
                      * = IS NEGATIVE THEN FPA0 = 0                      
D2AD  9654            LBB5C     LDA  FP0SGN        ;GET MANTISSA SIGN OF FPA0 
D2AF  43                        COMA               ;CHANGE SIGN OF FPA0 MANTISSA 
D2B0  2002                      BRA  LBB63           
D2B2  3262            LBB61     LEAS 2,S           ;PURGE RETURN ADDRESS FROM STACK 
D2B4  102AFED2        LBB63     LBPL LBA39         ;ZERO FPA0 MANTISSA SIGN & EXPONENT 
D2B8  7ED1E3          LBB67     JMP  LBA92         ;OV' OVERFLOW ERROR 
                      * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0                      
D2BB  BDD3B0          LBB6A     JSR  LBC5F         ;TRANSFER FPA0 TO FPA1 
D2BE  270D                      BEQ  LBB7C         ;BRANCH IF EXPONENT = 0 
D2C0  8B02                      ADDA #2            ;ADD 2 TO EXPONENT (TIMES 4) 
D2C2  25F4                      BCS  LBB67         ;OV' ERROR IF EXPONENT > $FF 
D2C4  0F62                      CLR  RESSGN        ;CLEAR RESULT SIGN BYTE 
D2C6  BDD11E                    JSR  LB9CD         ;ADD FPA1 TO FPA0 (TIMES 5) 
D2C9  0C4F                      INC  FP0EXP        ;ADD ONE TO EXPONENT (TIMES 10) 
D2CB  27EB                      BEQ  LBB67         ;OV' ERROR IF EXPONENT > $FF 
D2CD  39              LBB7C     RTS                  
D2CE  8420000000      LBB7D     FCB  $84,$20,$00,$00,$00 ;FLOATING POINT CONSTANT 10 
                      * DIVIDE FPA0 BY 10                      
D2D3  BDD3B0          LBB82     JSR  LBC5F         ;MOVE FPA0 TO FPA1 
D2D6  8ED2CE                    LDX  #LBB7D        ;POINT TO FLOATING POINT CONSTANT 10 
D2D9  5F                        CLRB               ;ZERO MANTISSA SIGN BYTE 
D2DA  D762            LBB89     STB  RESSGN        ;STORE THE QUOTIENT MANTISSA SIGN BYTE 
D2DC  BDD365                    JSR  LBC14         ;UNPACK AN FP NUMBER FROM (X) INTO FPA0 
D2DF  8C                        FCB  SKP2          ;SKIP TWO BYTES 
                      * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0                      
D2E0  8D9E            LBB8F     BSR  LBB2F         ;GET FP NUMBER FROM (X) TO FPA1 
                                                     
                      * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH                      
                      * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)                      
                                                     
                      * DIVIDE FPA1 BY FPA0                      
D2E2  2773            LBB91     BEQ  LBC06         ;/0' DIVIDE BY ZERO ERROR 
D2E4  004F                      NEG  FP0EXP        ;GET EXPONENT OF RECIPROCAL OF DIVISOR 
D2E6  8DB1                      BSR  LBB48         ;CALCULATE EXPONENT OF QUOTIENT 
D2E8  0C4F                      INC  FP0EXP        ;INCREMENT EXPONENT 
D2EA  27CC                      BEQ  LBB67         ;OV' OVERFLOW ERROR 
D2EC  8E0013                    LDX  #FPA2         ;POINT X TO MANTISSA OF FPA2 - HOLD 
                      *                            ;TEMPORARY QUOTIENT IN FPA2 
D2EF  C604                      LDB  #4            ;5 BYTE DIVIDE 
D2F1  D703                      STB  TMPLOC        ;SAVE BYTE COUNTER 
D2F3  C601                      LDB  #1            ;SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE 
                      * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -                      
                      * SET CARRY FLAG IF FPA1 >= FPA0                      
D2F5  9650            LBBA4     LDA  FPA0          ;* COMPARE THE TWO MS BYTES 
D2F7  915D                      CMPA FPA1          ;* OF FPA0 AND FPA1 AND 
D2F9  2613                      BNE  LBBBD         ;* BRANCH IF <> 
D2FB  9651                      LDA  FPA0+1        ;= COMPARE THE NUMBER 2 
D2FD  915E                      CMPA FPA1+1        ;= BYTES AND 
D2FF  260D                      BNE  LBBBD         ;= BRANCH IF <> 
D301  9652                      LDA  FPA0+2        ;* COMPARE THE NUMBER 3 
D303  915F                      CMPA FPA1+2        ;* BYTES AND 
D305  2607                      BNE  LBBBD         ;* BRANCH IF <> 
D307  9653                      LDA  FPA0+3        ;= COMPARE THE LS BYTES 
D309  9160                      CMPA FPA1+3        ;= AND BRANCH 
D30B  2601                      BNE  LBBBD         ;= IF <> 
D30D  43                        COMA               ;SET CARRY FLAG IF FPA0 = FPA1 
D30E  1FA8            LBBBD     TFR  CC,A          ;SAVE CARRY FLAG STATUS IN ACCA; CARRY 
                      *         CLEAR IF FPA0 > FPA1  
D310  59                        ROLB               ;ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE 
D311  240A                      BCC  LBBCC         ;CARRY WILL BE SET AFTER 8 SHIFTS 
D313  E780                      STB  ,X+           ;SAVE TEMPORARY QUOTIENT 
D315  0A03                      DEC  TMPLOC        ;DECREMENT BYTE COUNTER 
D317  2B34                      BMI  LBBFC         ;BRANCH IF DONE 
D319  272E                      BEQ  LBBF8         ;BRANCH IF LAST BYTE 
D31B  C601                      LDB  #1            ;RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE 
D31D  1F8A            LBBCC     TFR  A,CC          ;RESTORE CARRY FLAG AND 
D31F  250E                      BCS  LBBDE         ;BRANCH IF FPA0 =< FPA1 
D321  0860            LBBD0     ASL  FPA1+3        ;* SHIFT FPA1 MANTISSA 1 BIT TO LEFT 
D323  095F                      ROL  FPA1+2        ;* 
D325  095E                      ROL  FPA1+1        ;* 
D327  095D                      ROL  FPA1          ;* 
D329  25E3                      BCS  LBBBD         ;BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT 
D32B  2BC8                      BMI  LBBA4         ;IF MSB OF HIGH ORDER MANTISSA BYTE IS 
                      *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1  
D32D  20DF                      BRA  LBBBD         ;CARRY IS CLEAR, CHECK ANOTHER BIT 
                      * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1                      
D32F  9660            LBBDE     LDA  FPA1+3        ;* SUBTRACT THE LS BYTES OF MANTISSA 
D331  9053                      SUBA FPA0+3        ;* 
D333  9760                      STA  FPA1+3        ;* 
D335  965F                      LDA  FPA1+2        ;= THEN THE NEXT BYTE 
D337  9252                      SBCA FPA0+2        ;= 
D339  975F                      STA  FPA1+2        ;= 
D33B  965E                      LDA  FPA1+1        ;* AND THE NEXT 
D33D  9251                      SBCA FPA0+1        ;* 
D33F  975E                      STA  FPA1+1        ;* 
D341  965D                      LDA  FPA1          ;= AND FINALLY, THE MS BYTE OF MANTISSA 
D343  9250                      SBCA FPA0          ;= 
D345  975D                      STA  FPA1          ;= 
D347  20D8                      BRA  LBBD0         ;GO SHIFT FPA1 
D349  C640            LBBF8     LDB  #$40          ;USE ONLY TWO BITS OF THE LAST BYTE (FIFTH) 
D34B  20D0                      BRA  LBBCC         ;GO SHIFT THE LAST BYTE 
D34D  56              LBBFC     RORB               ;* SHIFT CARRY (ALWAYS SET HERE) INTO  
D34E  56                        RORB               ;* BIT 5 AND MOVE  
D34F  56                        RORB               ;* BITS 1,0 TO BITS 7,6  
D350  D763                      STB  FPSBYT        ;SAVE SUB BYTE 
D352  8D08                      BSR  LBC0B         ;MOVE MANTISSA OF FPA2 TO FPA0 
D354  7ED16D                    JMP  LBA1C         ;NORMALIZE FPA0 
D357  C614            LBC06     LDB  #2*10         ;/0' ERROR 
D359  7EC408                    JMP  LAC46         ;PROCESS THE ERROR 
                      * COPY MANTISSA FROM FPA2 TO FPA0                      
D35C  9E13            LBC0B     LDX  FPA2          ;* MOVE TOP 2 BYTES 
D35E  9F50                      STX  FPA0          ;* 
D360  9E15                      LDX  FPA2+2        ;= MOVE BOTTOM 2 BYTES 
D362  9F52                      STX  FPA0+2        ;= 
D364  39                        RTS                  
                      * COPY A PACKED FP NUMBER FROM (X) TO FPA0                      
D365  3402            LBC14     PSHS A             ;SAVE ACCA 
D367  EC01                      LDD  1,X           ;GET TOP TWO MANTISSA BYTES 
D369  9754                      STA  FP0SGN        ;SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN 
D36B  8A80                      ORA  #$80          ;UNPACK MS BYTE 
D36D  DD50                      STD  FPA0          ;SAVE UNPACKED TOP 2 MANTISSA BYTES 
D36F  0F63                      CLR  FPSBYT        ;CLEAR MANTISSA SUB BYTE 
D371  E684                      LDB  ,X            ;GET EXPONENT TO ACCB 
D373  AE03                      LDX  3,X           ;* MOVE LAST 2 
D375  9F52                      STX  FPA0+2        ;* MANTISSA BYTES 
D377  D74F                      STB  FP0EXP        ;SAVE EXPONENT 
D379  3582                      PULS A,PC          ;RESTORE ACCA AND RETURN 
                                                     
D37B  8E0045          LBC2A     LDX  #V45          ;POINT X TO MANTISSA OF FPA4 
D37E  2006                      BRA  LBC35         ;MOVE FPA0 TO FPA4 
D380  8E0040          LBC2F     LDX  #V40          ;POINT X TO MANTISSA OF FPA3 
D383  8C                        FCB  SKP2          ;SKIP TWO BYTES 
D384  9E3B            LBC33     LDX  VARDES        ;POINT X TO VARIABLE DESCRIPTOR IN VARDES 
                      * PACK FPA0 AND MOVE IT TO ADDRESS IN X                      
D386  964F            LBC35     LDA  FP0EXP        ;* COPY EXPONENT 
D388  A784                      STA  ,X            ;* 
D38A  9654                      LDA  FP0SGN        ;GET MANTISSA SIGN BIT 
D38C  8A7F                      ORA  #$7F          ;MASK THE BOTTOM 7 BITS 
D38E  9450                      ANDA FPA0          ;AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE 
D390  A701                      STA  1,X           ;SAVE MS BYTE 
D392  9651                      LDA  FPA0+1        ;* MOVE 2ND MANTISSA BYTE 
D394  A702                      STA  2,X           ;* 
D396  DE52                      LDU  FPA0+2        ;= MOVE BOTTOM 2 MANTISSA BYTES 
D398  EF03                      STU  3,X           ;= 
D39A  39                        RTS                  
                      * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA                      
D39B  9661            LBC4A     LDA  FP1SGN        ;* COPY MANTISSA SIGN FROM 
D39D  9754            LBC4C     STA  FP0SGN        ;* FPA1 TO FPA0 
D39F  9E5C                      LDX  FP1EXP        ;= COPY EXPONENT + MS BYTE FROM 
D3A1  9F4F                      STX  FP0EXP        ;= FPA1 TO FPA0 
D3A3  0F63                      CLR  FPSBYT        ;CLEAR MANTISSA SUB BYTE 
D3A5  965E                      LDA  FPA1+1        ;* COPY 2ND MANTISSA BYTE 
D3A7  9751                      STA  FPA0+1        ;* FROM FPA1 TO FPA0 
D3A9  9654                      LDA  FP0SGN        ;GET MANTISSA SIGN 
D3AB  9E5F                      LDX  FPA1+2        ;* COPY 3RD AND 4TH MANTISSA BYTE 
D3AD  9F52                      STX  FPA0+2        ;* FROM FPA1 TO FPA0 
D3AF  39                        RTS                  
                      * TRANSFER FPA0 TO FPA1                      
D3B0  DC4F            LBC5F     LDD  FP0EXP        ;* TRANSFER EXPONENT & MS BYTE 
D3B2  DD5C                      STD  FP1EXP        ;* 
D3B4  9E51                      LDX  FPA0+1        ;= TRANSFER MIDDLE TWO BYTES 
D3B6  9F5E                      STX  FPA1+1        ;= 
D3B8  9E53                      LDX  FPA0+3        ;* TRANSFER BOTTOM TWO BYTES 
D3BA  9F60                      STX  FPA1+3        ;* 
D3BC  4D                        TSTA               ;SET FLAGS ACCORDING TO EXPONENT 
D3BD  39                        RTS                  
                      * CHECK FPA0; RETURN ACCB = 0;IF FPA0 = 0,                      
                      * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE                      
D3BE  D64F            LBC6D     LDB  FP0EXP        ;GET EXPONENT 
D3C0  2708                      BEQ  LBC79         ;BRANCH IF FPA0 = 0 
D3C2  D654            LBC71     LDB  FP0SGN        ;GET SIGN OF MANTISSA 
D3C4  59              LBC73     ROLB               ;BIT 7 TO CARRY 
D3C5  C6FF                      LDB  #$FF          ;NEGATIVE FLAG 
D3C7  2501                      BCS  LBC79         ;BRANCH IF NEGATIVE MANTISSA 
D3C9  50                        NEGB               ;ACCB = 1 IF POSITIVE MANTISSA 
D3CA  39              LBC79     RTS                  
                                                     
                      * SGN                          
D3CB  8DF1            SGN       BSR  LBC6D         ;SET ACCB ACCORDING TO SIGN OF FPA0 
                      * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER                      
D3CD  D750            LBC7C     STB  FPA0          ;SAVE ACCB IN FPA0 
D3CF  0F51                      CLR  FPA0+1        ;CLEAR NUMBER 2 MANTISSA BYTE OF FPA0 
D3D1  C688                      LDB  #$88          ;EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER 
D3D3  9650            LBC82     LDA  FPA0          ;GET MS BYTE OF MANTISSA 
D3D5  8080                      SUBA #$80          ;SET CARRY IF POSITIVE MANTISSA 
D3D7  D74F            LBC86     STB  FP0EXP        ;SAVE EXPONENT 
D3D9  DC74                      LDD  ZERO          ;* ZERO OUT ACCD AND 
D3DB  DD52                      STD  FPA0+2        ;* BOTTOM HALF OF FPA0 
D3DD  9763                      STA  FPSBYT        ;CLEAR SUB BYTE 
D3DF  9754                      STA  FP0SGN        ;CLEAR SIGN OF FPA0 MANTISSA 
D3E1  7ED169                    JMP  LBA18         ;GO NORMALIZE FPA0 
                                                     
                      * ABS                          
D3E4  0F54            ABS       CLR  FP0SGN        ;FORCE MANTISSA SIGN OF FPA0 POSITIVE 
D3E6  39                        RTS                  
                      * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO                      
                      * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN                      
                      * ZERO FLAG SET AND ACCB = 0,;IF EQUAL; ACCB = 1 IF                      
                      * FPA0 > (X); ACCB = $FF IF FPA0 < (X)                      
D3E7  E684            LBC96     LDB  ,X            ;CHECK EXPONENT OF (X) 
D3E9  27D3                      BEQ  LBC6D         ;BRANCH IF FPA = 0 
D3EB  E601                      LDB  1,X           ;GET MS BYTE OF MANTISSA OF (X) 
D3ED  D854                      EORB FP0SGN        ;EOR WITH SIGN OF FPA0 
D3EF  2BD1                      BMI  LBC71         ;BRANCH IF SIGNS NOT = 
                      * COMPARE FPA0 WITH FP NUMBER;POINTED TO BY (X).                      
                      * FPA0 IS NORMALIZED, (X) IS PACKED.                      
D3F1  D64F            LBCA0     LDB  FP0EXP        ;* GET EXPONENT OF 
D3F3  E184                      CMPB ,X            ;* FPA0, COMPARE TO EXPONENT OF 
D3F5  261D                      BNE  LBCC3         ;* (X) AND BRANCH IF <>. 
D3F7  E601                      LDB  1,X           ;* GET MS BYTE OF (X), KEEP ONLY 
D3F9  CA7F                      ORB  #$7F          ;* THE SIGN BIT - 'AND' THE BOTTOM 7 
D3FB  D450                      ANDB FPA0          ;* BITS OF FPA0 INTO ACCB 
D3FD  E101                      CMPB 1,X           ;= COMPARE THE BOTTOM 7 BITS OF THE MANTISSA 
D3FF  2613                      BNE  LBCC3         ;= MS BYTE AND BRANCH IF <> 
D401  D651                      LDB  FPA0+1        ;* COMPARE 2ND BYTE 
D403  E102                      CMPB 2,X           ;* OF MANTISSA, 
D405  260D                      BNE  LBCC3         ;* BRANCH IF <> 
D407  D652                      LDB  FPA0+2        ;= COMPARE 3RD BYTE 
D409  E103                      CMPB 3,X           ;= OF MANTISSA, 
D40B  2607                      BNE  LBCC3         ;= BRANCH IF <> 
D40D  D653                      LDB  FPA0+3        ;* SUBTRACT LS BYTE 
D40F  E004                      SUBB 4,X           ;* OF (X) FROM LS BYTE OF 
D411  2601                      BNE  LBCC3         ;* FPA0, BRANCH IF <> 
D413  39                        RTS                ;RETURN IF FP (X) = FPA0 
D414  56              LBCC3     RORB               ;SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X) 
D415  D854                      EORB FP0SGN        ;TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE 
D417  20AB                      BRA  LBC73         ;GO SET ACCB ACCORDING TO COMPARISON 
                      * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT                      
                      * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA                      
D419  D64F            LBCC8     LDB  FP0EXP        ;GET EXPONENT OF FPA0 
D41B  273D                      BEQ  LBD09         ;ZERO MANTISSA IF FPA0 = 0 
D41D  C0A0                      SUBB #$A0          ;SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD 
                      *                            ;THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN 
                      *                            ;THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT 
                      *                            ;WILL BE TO THE RIGHT OF THE MANTISSA 
D41F  9654                      LDA  FP0SGN        ;TEST SIGN OF FPA0 MANTISSA 
D421  2A05                      BPL  LBCD7         ;BRANCH IF POSITIVE 
D423  035B                      COM  FPCARY        ;COMPLEMENT CARRY IN BYTE 
D425  BDD1CC                    JSR  LBA7B         ;NEGATE MANTISSA OF FPA0 
D428  8E004F          LBCD7     LDX  #FP0EXP       ;POINT X TO FPA0 
D42B  C1F8                      CMPB #-8           ;EXPONENT DIFFERENCE < -8? 
D42D  2E06                      BGT  LBCE4         ;YES 
D42F  BDD1FF                    JSR  LBAAE         ;SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0 
D432  0F5B                      CLR  FPCARY        ;CLEAR CARRY IN BYTE 
D434  39                        RTS                  
D435  0F5B            LBCE4     CLR  FPCARY        ;CLEAR CARRY IN BYTE 
D437  9654                      LDA  FP0SGN        ;* GET SIGN OF FPA0 MANTISSA 
D439  49                        ROLA               ;* ROTATE IT INTO THE CARRY FLAG 
D43A  0650                      ROR  FPA0          ;ROTATE CARRY (MANTISSA SIGN) INTO BIT 7 
                      *                            ;OF LS BYTE OF MANTISSA 
D43C  7ED20B                    JMP  LBABA         ;DE-NORMALIZE FPA0 
                                                     
                      * INT                          
                      * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT                      
                      * TO THE EXTREME RIGHT OF THE;MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE                      
                      * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT                      
                      * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION                      
                      * ONLY THE INTEGER PORTION OF;FPA0 WILL REMAIN.                      
                      *                              
D43F  D64F            INT       LDB  FP0EXP        ;GET EXPONENT OF FPA0 
D441  C1A0                      CMPB #$A0          ;LARGEST POSSIBLE INTEGER EXPONENT 
D443  241D                      BCC  LBD11         ;RETURN IF FPA0 >= 32768 
D445  8DD2                      BSR  LBCC8         ;SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE 
                      *                            ;LS BYTE OF THE FPA0 MANTISSA 
D447  D763                      STB  FPSBYT        ;ACCB = 0: ZERO OUT THE SUB BYTE 
D449  9654                      LDA  FP0SGN        ;GET MANTISSA SIGN 
D44B  D754                      STB  FP0SGN        ;FORCE MANTISSA SIGN TO BE POSITIVE 
D44D  8080                      SUBA #$80          ;SET CARRY IF MANTISSA 
D44F  86A0                      LDA  #$A0          ;* GET DENORMALIZED EXPONENT AND 
D451  974F                      STA  FP0EXP        ;* SAVE IT IN FPA0 EXPONENT 
D453  9653                      LDA  FPA0+3        ;= GET LS BYTE OF FPA0 AND 
D455  9701                      STA  CHARAC        ;= SAVE IT IN CHARAC 
D457  7ED169                    JMP  LBA18         ;NORMALIZE FPA0 
                                                     
D45A  D750            LBD09     STB  FPA0          ;* LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB 
D45C  D751                      STB  FPA0+1        ;* 
D45E  D752                      STB  FPA0+2        ;* 
D460  D753                      STB  FPA0+3        ;* 
D462  39              LBD11     RTS                ;* 
                                                     
                      * CONVERT ASCII STRING TO FLOATING POINT                      
D463  9E74            LBD12     LDX  ZERO          ;(X) = 0 
D465  9F54                      STX  FP0SGN        ;* ZERO OUT FPA0 & THE SIGN FLAG (COEFCT) 
D467  9F4F                      STX  FP0EXP        ;* 
D469  9F51                      STX  FPA0+1        ;* 
D46B  9F52                      STX  FPA0+2        ;* 
D46D  9F47                      STX  V47           ;INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO 
D46F  9F45                      STX  V45           ;INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0 
D471  2564                      BCS  LBD86         ;IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST 
                      *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK  
D473  BDDBA0                    JSR  XVEC19        ;CALL EXTENDED BASIC ADD-IN 
D476  812D            LBD25     CMPA #'-           ;* CHECK FOR A LEADING MINUS SIGN AND BRANCH 
D478  2604                      BNE  LBD2D         ;* IF NO MINUS SIGN 
D47A  0355                      COM  COEFCT        ;TOGGLE SIGN; 0 = +; FF = - 
D47C  2004                      BRA  LBD31         ;INTERPRET THE REST OF THE STRING 
D47E  812B            LBD2D     CMPA #'+           ;* CHECK FOR LEADING PLUS SlGN AND BRANCH 
D480  2604                      BNE  LBD35         ;* IF NOT A PLUS SIGN 
D482  9D7C            LBD31     JSR  GETNCH        ;GET NEXT INPUT CHARACTER FROM BASIC 
D484  2551                      BCS  LBD86         ;BRANCH IF NUMERIC CHARACTER 
D486  812E            LBD35     CMPA #'.           ;DECIMAL POlNT? 
D488  2728                      BEQ  LBD61         ;YES 
D48A  8145                      CMPA #'E           ;"E" SHORTHAND FORM (SCIENTIFIC NOTATION)? 
D48C  2628                      BNE  LBD65         ;NO 
                      * EVALUATE EXPONENT OF EXPONENTIAL FORMAT                      
D48E  9D7C                      JSR  GETNCH        ;GET NEXT INPUT CHARACTER FROM BASIC 
D490  2564                      BCS  LBDA5         ;BRANCH IF NUMERIC 
D492  81A7                      CMPA #TOK_MINUS    ;MINUS TOKEN? 
D494  270E                      BEQ  LBD53         ;YES 
D496  812D                      CMPA #'-           ;ASCII MINUS? 
D498  270A                      BEQ  LBD53         ;YES 
D49A  81A6                      CMPA #TOK_PLUS     ;PLUS TOKEN? 
D49C  2708                      BEQ  LBD55         ;YES 
D49E  812B                      CMPA #'+           ;ASCII PLUS? 
D4A0  2704                      BEQ  LBD55         ;YES 
D4A2  2006                      BRA  LBD59         ;BRANCH IF NO SIGN FOUND 
D4A4  0348            LBD53     COM  V48           ;SET EXPONENT SIGN FLAG TO NEGATIVE 
                      * STRIP A DECIMAL NUMBER FROM;BASIC LINE, CONVERT IT TO BINARY IN V47                      
D4A6  9D7C            LBD55     JSR  GETNCH        ;GET NEXT INPUT CHARACTER FROM BASIC 
D4A8  254C                      BCS  LBDA5         ;IF NUMERIC CHARACTER, CONVERT TO BINARY 
D4AA  0D48            LBD59     TST  V48           ;* CHECK EXPONENT SIGN FLAG 
D4AC  2708                      BEQ  LBD65         ;* AND BRANCH IF POSITIVE 
D4AE  0047                      NEG  V47           ;NEGATE VALUE OF EXPONENT 
D4B0  2004                      BRA  LBD65           
D4B2  0346            LBD61     COM  V46           ;*TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER 
D4B4  26CC                      BNE  LBD31         ;*CHARACTER IF <> 0 - TERMINATE INTERPRETATION 
                      *         IF   SECOND DECIMAL;POINT  
                      * ADJUST FPA0 FOR THE DECIMAL;EXPONENT IN V47                      
D4B6  9647            LBD65     LDA  V47           ;* GET EXPONENT, SUBTRACT THE NUMBER OF 
D4B8  9045                      SUBA V45           ;* PLACES TO THE RIGHT OF DECIMAL POINT 
D4BA  9747                      STA  V47           ;* AND RESAVE IT. 
D4BC  2712                      BEQ  LBD7F         ;EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO 
D4BE  2A09                      BPL  LBD78         ;BRANCH IF POSITIVE EXPONENT 
D4C0  BDD2D3          LBD6F     JSR  LBB82         ;DIVIDE FPA0 BY 10 
D4C3  0C47                      INC  V47           ;INCREMENT EXPONENT COUNTER (MULTIPLY BY 10) 
D4C5  26F9                      BNE  LBD6F         ;KEEP MULTIPLYING 
D4C7  2007                      BRA  LBD7F         ;EXIT ROUTINE 
D4C9  BDD2BB          LBD78     JSR  LBB6A         ;MULTIPLY FPA0 BY 10 
D4CC  0A47                      DEC  V47           ;DECREMENT EXPONENT COUNTER (DIVIDE BY 10) 
D4CE  26F9                      BNE  LBD78         ;KEEP MULTIPLYING 
D4D0  9655            LBD7F     LDA  COEFCT        ;GET THE SIGN FLAG 
D4D2  2A8E                      BPL  LBD11         ;RETURN IF POSITIVE 
D4D4  7ED63A                    JMP  LBEE9         ;TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE 
                      *MULTIPLY FPA0 BY TEN AND ADD;ACCA TO THE RESULT                      
D4D7  D645            LBD86     LDB  V45           ;*GET THE RIGHT DECIMAL COUNTER AND SUBTRACT 
D4D9  D046                      SUBB V46           ;*THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT 
D4DB  D745                      STB  V45           ;*FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS 
                      *                            ;-1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE 
D4DD  3402                      PSHS A             ;SAVE NEW DIGIT ON STACK 
D4DF  BDD2BB                    JSR  LBB6A         ;MULTIPLY FPA0 BY 10 
D4E2  3504                      PULS B             ;GET NEW DIGIT BACK 
D4E4  C030                      SUBB #'0           ;MASK OFF ASCII 
D4E6  8D02                      BSR  LBD99         ;ADD ACCB TO FPA0 
D4E8  2098                      BRA  LBD31         ;GET ANOTHER CHARACTER FROM BASIC 
D4EA  BDD380          LBD99     JSR  LBC2F         ;PACK FPA0 AND SAVE IT IN FPA3 
D4ED  BDD3CD                    JSR  LBC7C         ;CONVERT ACCB TO FP NUMBER IN FPA0 
D4F0  8E0040                    LDX  #V40          ;* ADD FPA0 TO 
D4F3  7ED113                    JMP  LB9C2         ;* FPA3 
                                                     
                                                     
D4F6  D647            LBDA5     LDB  V47             
D4F8  58                        ASLB               ;TIMES 2 
D4F9  58                        ASLB               ;TIMES 4 
D4FA  DB47                      ADDB V47           ;ADD 1 = TIMES 5 
D4FC  58                        ASLB               ;TIMES 10 
D4FD  8030                      SUBA #'0           ;*MASK OFF ASCII FROM ACCA, PUSH 
D4FF  3404                      PSHS B             ;*RESULT ONTO THE STACK AND 
D501  ABE0                      ADDA ,S+           ;ADD lT TO ACCB 
D503  9747                      STA  V47           ;SAVE IN V47 
D505  209F                      BRA  LBD55         ;INTERPRET ANOTHER CHARACTER 
                      *                              
D507  9B3EBC1FFD      LBDB6     FCB  $9B,$3E,$BC,$1F,$FD ;* 99999999.9 
D50C  9E6E6B27FD      LBDBB     FCB  $9E,$6E,$6B,$27,$FD ;* 999999999 
D511  9E6E6B2800      LBDC0     FCB  $9E,$6E,$6B,$28,$00 ;* 1E + 09 
                      *                              
D516  8EC3A9          LBDC5     LDX  #LABE8-1      ;POINT X TO " IN " MESSAGE 
D519  8D0C                      BSR  LBDD6         ;COPY A STRING FROM (X) TO CONSOLE OUT 
D51B  DC68                      LDD  CURLIN        ;GET CURRENT BASIC LINE NUMBER TO ACCD 
                      * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER                      
                      * AND PRINT IT TO CONSOLE OUT                      
D51D  DD50            LBDCC     STD  FPA0          ;SAVE ACCD IN TOP HALF OF FPA0 
D51F  C690                      LDB  #$90          ;REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
D521  43                        COMA               ;SET CARRY FLAG - FORCE POSITIVE MANTISSA 
D522  BDD3D7                    JSR  LBC86         ;ZERO BOTTOM HALF AND SIGN OF FPA0, THEN 
                      *         SAVE EXPONENT AND NORMALIZE IT  
D525  8D03                      BSR  LBDD9         ;CONVERT FP NUMBER TO ASCII STRING 
D527  7ED0ED          LBDD6     JMP  LB99C         ;COPY A STRING FROM (X) TO CONSOLE OUT 
                                                     
                      * CONVERT FP NUMBER TO ASCII STRING                      
D52A  CE01F1          LBDD9     LDU  #STRBUF+3     ;POINT U TO BUFFER WHICH WILL NOT CAUSE 
                      *                            ;THE STRING TO BE STORED IN STRING SPACE 
D52D  8620            LBDDC     LDA  #SPACE        ;SPACE = DEFAULT SIGN FOR POSITIVE # 
D52F  D654                      LDB  FP0SGN        ;GET SIGN OF FPA0 
D531  2A02                      BPL  LBDE4         ;BRANCH IF POSITIVE 
D533  862D                      LDA  #'-           ;ASCII MINUS SIGN 
D535  A7C0            LBDE4     STA  ,U+           ;STORE SIGN OF NUMBER 
D537  DF64                      STU  COEFPT        ;SAVE BUFFER POINTER 
D539  9754                      STA  FP0SGN        ;SAVE SIGN (IN ASCII) 
D53B  8630                      LDA  #'0           ;ASCII ZERO IF EXPONENT = 0 
D53D  D64F                      LDB  FP0EXP        ;GET FPA0 EXPONENT 
D53F  102700C6                  LBEQ LBEB8         ;BRANCH IF FPA0 = 0 
D543  4F                        CLRA               ;BASE 10 EXPONENT=0 FOR FP NUMBER > 1 
D544  C180                      CMPB #$80          ;CHECK EXPONENT 
D546  2208                      BHI  LBDFF         ;BRANCH IF FP NUMBER > 1 
                      * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS                      
D548  8ED511                    LDX  #LBDC0        ;POINT X TO FP 1E+09 
D54B  BDD21B                    JSR  LBACA         ;MULTIPLY FPA0 BY (X) 
D54E  86F7                      LDA  #-9           ;BASE 10 EXPONENT = -9 
D550  9745            LBDFF     STA  V45           ;BASE 10 EXPONENT 
                      * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE                      
                      * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST                      
                      * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE                      
                      * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING                      
                      * SCIENTIFIC NOTATION                      
D552  8ED50C          LBE01     LDX  #LBDBB        ;POINT X TO FP 999,999,999 
D555  BDD3F1                    JSR  LBCA0         ;COMPARE FPA0 TO 999,999,999 
D558  2E0F                      BGT  LBE18         ;BRANCH IF > 999,999,999 
D55A  8ED507          LBE09     LDX  #LBDB6        ;POINT X TO FP 99,999,999.9 
D55D  BDD3F1                    JSR  LBCA0         ;COMPARE FPA0 TO 99,999,999.9 
D560  2E0E                      BGT  LBE1F         ;BRANCH IF > 99,999,999.9 (IN RANGE) 
D562  BDD2BB                    JSR  LBB6A         ;MULTIPLY FPA0 BY 10 
D565  0A45                      DEC  V45           ;SUBTRACT ONE FROM DECIMAL OFFSET 
D567  20F1                      BRA  LBE09         ;PSEUDO - NORMALIZE SOME MORE 
D569  BDD2D3          LBE18     JSR  LBB82         ;DIVIDE FPA0 BY 10 
D56C  0C45                      INC  V45           ;ADD ONE TO BASE 10 EXPONENT 
D56E  20E2                      BRA  LBE01         ;PSEUDO - NORMALIZE SOME MORE 
D570  BDD105          LBE1F     JSR  LB9B4         ;ADD .5 TO FPA0 (ROUND OFF) 
D573  BDD419                    JSR  LBCC8         ;CONVERT FPA0 TO AN INTEGER 
D576  C601                      LDB  #1            ;DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT) 
D578  9645                      LDA  V45           ;* GET BASE 10 EXPONENT AND ADD TEN TO IT 
D57A  8B0A                      ADDA #9+1          ;* (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
D57C  2B09                      BMI  LBE36         ;BRANCH IF NUMBER < 1.0 
D57E  810B                      CMPA #9+2          ;NINE PLACES MAY BE DISPLAYED WITHOUT 
                      *         USING SCIENTIFIC NOTATION  
D580  2405                      BCC  LBE36         ;BRANCH IF SCIENTIFIC NOTATION REQUIRED 
D582  4A                        DECA               ;* SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR 
D583  1F89                      TFR  A,B           ;* AND SAVE IT IN ACCB (DECiMAL POINT FLAG) 
D585  8602                      LDA  #2            ;FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION 
D587  4A              LBE36     DECA               ;* SUBTRACT TWO (WITHOUT AFFECTING CARRY) 
D588  4A                        DECA               ;* FROM BASE 10 EXPONENT 
D589  9747                      STA  V47           ;SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY 
                      *         IN   SCIENTIFIC NOTATION  
D58B  D745                      STB  V45           ;DECIMAL POINT FLAG - NUMBER OF PLACES TO 
                      *         LEFT OF DECIMAL POINT  
D58D  2E0D                      BGT  LBE4B         ;BRANCH IF >= 1 
D58F  DE64                      LDU  COEFPT        ;POINT U TO THE STRING BUFFER 
D591  862E                      LDA  #'.           ;* STORE A PERIOD 
D593  A7C0                      STA  ,U+           ;* IN THE BUFFER 
D595  5D                        TSTB               ;CHECK DECIMAL POINT FLAG  
D596  2704                      BEQ  LBE4B         ;BRANCH IF NOTHING TO LEFT OF DECIMAL POINT 
D598  8630                      LDA  #'0           ;* STORE A ZERO 
D59A  A7C0                      STA  ,U+           ;* IN THE BUFFER 
                                                     
                      * CONVERT FPA0 INTO A STRING OF ASCII DIGITS                      
D59C  8ED616          LBE4B     LDX  #LBEC5        ;POINT X TO FP POWER OF 10 MANTISSA 
D59F  C680                      LDB  #0+$80        ;INITIALIZE DIGIT COUNTER TO 0+$80 
                      * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA                      
                      * IS NEGATIVE. WHEN YOU 'ADD';A NEGATIVE MANTISSA, IT IS                      
                      * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW                      
                      * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.                      
D5A1  9653            LBE50     LDA  FPA0+3        ;* ADD MANTISSA LS 
D5A3  AB03                      ADDA 3,X           ;* BYTE OF FPA0 
D5A5  9753                      STA  FPA0+3        ;* AND (X) 
D5A7  9652                      LDA  FPA0+2        ;= ADD MANTISSA 
D5A9  A902                      ADCA 2,X           ;= NUMBER 3 BYTE OF 
D5AB  9752                      STA  FPA0+2        ;= FPA0 AND (X) 
D5AD  9651                      LDA  FPA0+1        ;* ADD MANTISSA 
D5AF  A901                      ADCA 1,X           ;* NUMBER 2 BYTE OF 
D5B1  9751                      STA  FPA0+1        ;* FPA0 AND (X) 
D5B3  9650                      LDA  FPA0          ;= ADD MANTISSA 
D5B5  A984                      ADCA ,X            ;= MS BYTE OF 
D5B7  9750                      STA  FPA0          ;= FPA0 AND (X) 
D5B9  5C                        INCB               ;ADD ONE TO DIGIT COUNTER 
D5BA  56                        RORB               ;ROTATE CARRY INTO BIT 7  
D5BB  59                        ROLB               ;*SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND 
D5BC  28E3                      BVC  LBE50         ;*POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA 
D5BE  2403                      BCC  LBE72         ;BRANCH IF NEGATIVE MANTISSA 
D5C0  C00B                      SUBB #10+1         ;* TAKE THE 9'S COMPLEMENT IF
D5C2  50                        NEGB               ;* ADDING MANTISSA 
D5C3  CB2F            LBE72     ADDB #'0-1         ;ADD ASCII OFFSET TO DIGIT 
D5C5  3004                      LEAX 4,X           ;MOVE TO NEXT POWER OF 10 MANTISSA 
D5C7  1F98                      TFR  B,A           ;SAVE DIGIT IN ACCA 
D5C9  847F                      ANDA #$7F          ;MASK OFF BIT 7 (ADD/SUBTRACT FLAG) 
D5CB  A7C0                      STA  ,U+           ;STORE DIGIT IN STRING BUFFER 
D5CD  0A45                      DEC  V45           ;DECREMENT DECIMAL POINT FLAG 
D5CF  2604                      BNE  LBE84         ;BRANCH IF NOT TIME FOR DECIMAL POINT 
D5D1  862E                      LDA  #'.           ;* STORE DECIMAL POINT IN 
D5D3  A7C0                      STA  ,U+           ;* STRING BUFFER 
D5D5  53              LBE84     COMB               ;TOGGLE BIT 7 (ADD/SUBTRACT FLAG) 
D5D6  C480                      ANDB #$80          ;MASK OFF ALL BUT ADD/SUBTRACT FLAG 
D5D8  8CD63A                    CMPX #LBEC5+36     ;COMPARE X TO END OF MANTISSA TABLE 
D5DB  26C4                      BNE  LBE50         ;BRANCH IF NOT AT END OF TABLE 
                      * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY                      
D5DD  A6C2            LBE8C     LDA  ,-U           ;GET THE LAST CHARACTER; MOVE POINTER BACK 
D5DF  8130                      CMPA #'0           ;WAS IT A ZERO? 
D5E1  27FA                      BEQ  LBE8C         ;IGNORE TRAILING ZEROS IF SO 
D5E3  812E                      CMPA #'.           ;CHECK FOR DECIMAL POINT 
D5E5  2602                      BNE  LBE98         ;BRANCH IF NOT DECIMAL POINT 
D5E7  335F                      LEAU -1,U          ;STEP OVER THE DECIMAL POINT 
D5E9  862B            LBE98     LDA  #'+           ;ASCII PLUS SIGN 
D5EB  D647                      LDB  V47           ;GET SCIENTIFIC NOTATION EXPONENT 
D5ED  271C                      BEQ  LBEBA         ;BRANCH IF NOT SCIENTIFIC NOTATION 
D5EF  2A03                      BPL  LBEA3         ;BRANCH IF POSITIVE EXPONENT 
D5F1  862D                      LDA  #'-           ;ASCII MINUS SIGN 
D5F3  50                        NEGB               ;NEGATE EXPONENT IF NEGATIVE 
D5F4  A742            LBEA3     STA  2,U           ;STORE EXPONENT SIGN IN STRING 
D5F6  8645                      LDA  #'E           ;* GET ASCII 'E' (SCIENTIFIC NOTATION
D5F8  A741                      STA  1,U           ;* FLAG) AND SAVE IT IN THE STRING 
D5FA  862F                      LDA  #'0-1         ;INITIALIZE ACCA TO ASCII ZERO 
                                                     
                                                     
D5FC  4C              LBEAB     INCA               ;ADD ONE TO 10'S DIGIT OF EXPONENT
D5FD  C00A                      SUBB #10           ;SUBTRACT 10 FROM ACCB 
D5FF  24FB                      BCC  LBEAB         ;ADD 1 TO 10'S DIGIT IF NO CARRY
D601  CB3A                      ADDB #'9+1         ;CONVERT UNITS DIGIT TO ASCII 
D603  ED43                      STD  3,U           ;SAVE EXPONENT IN STRING 
D605  6F45                      CLR  5,U           ;CLEAR LAST BYTE (TERMINATOR) 
D607  2004                      BRA  LBEBC         ;GO RESET POINTER 
D609  A7C4            LBEB8     STA  ,U            ;STORE LAST CHARACTER 
D60B  6F41            LBEBA     CLR  1,U           ;CLEAR LAST BYTE (TERMINATOR - REQUIRED BY 
                      *         PRINT SUBROUTINES)    
D60D  8E01F1          LBEBC     LDX  #STRBUF+3     ;RESET POINTER TO START OF BUFFER 
D610  39                        RTS                  
                      *                              
D611  8000000000      LBEC0     FCB  $80,$00,$00,$00,$00 ;FLOATING POINT .5 
                      *                              
                      *** TABLE OF UNNORMALIZED POWERS OF 10                      
D616  FA0A1F00        LBEC5     FCB  $FA,$0A,$1F,$00 ;-100000000 
D61A  00989680        LBEC9     FCB  $00,$98,$96,$80 ;10000000 
D61E  FFF0BDC0        LBECD     FCB  $FF,$F0,$BD,$C0 ;-1000000 
D622  000186A0        LBED1     FCB  $00,$01,$86,$A0 ;100000 
D626  FFFFD8F0        LBED5     FCB  $FF,$FF,$D8,$F0 ;-10000 
D62A  000003E8        LBED9     FCB  $00,$00,$03,$E8 ;1000 
D62E  FFFFFF9C        LBEDD     FCB  $FF,$FF,$FF,$9C ;-100 
D632  0000000A        LBEE1     FCB  $00,$00,$00,$0A ;10 
D636  FFFFFFFF        LBEE5     FCB  $FF,$FF,$FF,$FF ;-1 
                      *                              
                      *                              
D63A  964F            LBEE9     LDA  FP0EXP        ;GET EXPONENT OF FPA0 
D63C  2702                      BEQ  LBEEF         ;BRANCH IF FPA0 = 0 
D63E  0354                      COM  FP0SGN        ;TOGGLE MANTISSA SIGN OF FPA0 
D640  39              LBEEF     RTS                  
                      * EXPAND A POLYNOMIAL OF THE FORM                      
                      * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0                      
                      * AND THE X REGISTER POINTS TO A TABLE OF                      
                      * COEFFICIENTS A,B,C,D....                      
D641  9F64            LBEF0     STX  COEFPT        ;SAVE COEFFICIENT TABLE POINTER 
D643  BDD380                    JSR  LBC2F         ;MOVE FPA0 TO FPA3 
D646  8D05                      BSR  LBEFC         ;MULTIPLY FPA3 BY FPA0 
D648  8D08                      BSR  LBF01         ;EXPAND POLYNOMIAL 
D64A  8E0040                    LDX  #V40          ;POINT X TO FPA3 
D64D  7ED21B          LBEFC     JMP  LBACA         ;MULTIPLY (X) BY FPA0 
                                                     
                      * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL                      
                      * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE                      
                      * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE                      
                      * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER                      
                      * OF PACKED FLOATING POINT NUMBERS. THE                      
                      * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =                      
                      * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0'YN)
D650  9F64            LBEFF     STX  COEFPT        ;SAVE COEFFICIENT TABLE POINTER 
D652  BDD37B          LBF01     JSR  LBC2A         ;MOVE FPA0 TO FPA4 
D655  9E64                      LDX  COEFPT        ;GET THE COEFFICIENT POINTER 
D657  E680                      LDB  ,X+           ;GET THE TOP OF COEFFICIENT TABLE TO 
D659  D755                      STB  COEFCT        ;* USE AND STORE IT IN TEMPORARY COUNTER 
D65B  9F64                      STX  COEFPT        ;SAVE NEW COEFFICIENT POINTER 
D65D  8DEE            LBF0C     BSR  LBEFC         ;MULTIPLY (X) BY FPA0 
D65F  9E64                      LDX  COEFPT        ;*GET COEFFICIENT POINTER 
D661  3005                      LEAX 5,X           ;*MOVE TO NEXT FP NUMBER 
D663  9F64                      STX  COEFPT        ;*SAVE NEW COEFFICIENT POINTER 
D665  BDD113                    JSR  LB9C2         ;ADD (X) AND FPA0 
D668  8E0045                    LDX  #V45          ;POINT (X) TO FPA4 
D66B  0A55                      DEC  COEFCT        ;DECREMENT TEMP COUNTER 
D66D  26EE                      BNE  LBF0C         ;BRANCH IF MORE COEFFICIENTS LEFT 
D66F  39                        RTS                  
                                                     
                      * RND                          
D670  BDD3BE          RND       JSR  LBC6D         ;TEST FPA0 
D673  2B1F                      BMI  LBF45         ;BRANCH IF FPA0 = NEGATIVE 
D675  2715                      BEQ  LBF3B         ;BRANCH IF FPA0 = 0 
D677  8D10                      BSR  LBF38         ;CONVERT FPA0 TO AN INTEGER 
D679  BDD380                    JSR  LBC2F         ;PACK FPA0 TO FPA3 
D67C  8D0E                      BSR  LBF3B         ;GET A RANDOM NUMBER: FPA0 < 1.0 
D67E  8E0040                    LDX  #V40          ;POINT (X) TO FPA3 
D681  8DCA                      BSR  LBEFC         ;MULTIPLY (X) BY FPA0 
D683  8ED216                    LDX  #LBAC5        ;POINT (X) TO FP VALUE OF 1.0 
D686  BDD113                    JSR  LB9C2         ;ADD 1.0 TO FPA0 
D689  7ED43F          LBF38     JMP  INT           ;CONVERT FPA0 TO AN INTEGER 
                      * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0                      
D68C  9EB1            LBF3B     LDX  RVSEED+1      ;* MOVE VARIABLE 
D68E  9F50                      STX  FPA0          ;* RANDOM NUMBER 
D690  9EB3                      LDX  RVSEED+3      ;* SEED TO 
D692  9F52                      STX  FPA0+2        ;* FPA0 
D694  BED6C1          LBF45     LDX  RSEED         ;= MOVE FIXED 
D697  9F5D                      STX  FPA1          ;= RANDOM NUMBER 
D699  BED6C3                    LDX  RSEED+2       ;= SEED TO 
D69C  9F5F                      STX  FPA1+2        ;= MANTISSA OF FPA0 
D69E  BDD221                    JSR  LBAD0         ;MULTIPLY FPA0 X FPA1 
D6A1  DC8A                      LDD  VAD           ;GET THE TWO LOWEST ORDER PRODUCT BYTES 
D6A3  C3658B                    ADDD #$658B        ;ADD A CONSTANT 
D6A6  DDB3                      STD  RVSEED+3      ;SAVE NEW LOW ORDER VARIABLE RANDOM # SEED 
D6A8  DD52                      STD  FPA0+2        ;SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA 
D6AA  DC88                      LDD  VAB           ;GET 2 MORE LOW ORDER PRODUCT BYTES 
D6AC  C9B0                      ADCB #$B0          ;ADD A CONSTANT 
D6AE  8905                      ADCA #5            ;ADD A CONSTANT 
D6B0  DDB1                      STD  RVSEED+1      ;SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED 
D6B2  DD50                      STD  FPA0          ;SAVE NEW HIGH ORDER FPA0 MANTISSA 
D6B4  0F54                      CLR  FP0SGN        ;FORCE FPA0 MANTISSA = POSITIVE 
D6B6  8680                      LDA  #$80          ;* SET FPA0 BIASED EXPONENT 
D6B8  974F                      STA  FP0EXP        ;* TO 0 1 < FPA0 < 0 
D6BA  9615                      LDA  FPA2+2        ;GET A BYTE FROM FPA2 (MORE RANDOMNESS) 
D6BC  9763                      STA  FPSBYT        ;SAVE AS SUB BYTE 
D6BE  7ED16D                    JMP  LBA1C         ;NORMALIZE FPA0 
                      *                              
D6C1  40E6            RSEED     FDB  $40E6         ;*CONSTANT RANDOM NUMBER GENERATOR SEED 
D6C3  4DAB                      FDB  $4DAB         ;* 
                                                     
                      * SIN                          
                      * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY                      
                      * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS                      
                      * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE                      
                      * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.                      
                                                     
                      * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:                      
                      * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)                      
D6C5  BDD3B0          SIN       JSR  LBC5F         ;COPY FPA0 TO FPA1 
D6C8  8ED70A                    LDX  #LBFBD        ;POINT (X) TO 2*PI 
D6CB  D661                      LDB  FP1SGN        ;*GET MANTISSA SIGN OF FPA1 
D6CD  BDD2DA                    JSR  LBB89         ;*AND DIVIDE FPA0 BY 2*PI 
D6D0  BDD3B0                    JSR  LBC5F         ;COPY FPA0 TO FPA1 
D6D3  8DB4                      BSR  LBF38         ;CONVERT FPA0 TO AN INTEGER 
D6D5  0F62                      CLR  RESSGN        ;SET RESULT SIGN = POSITIVE 
D6D7  965C                      LDA  FP1EXP        ;*GET EXPONENT OF FPA1 
D6D9  D64F                      LDB  FP0EXP        ;*GET EXPONENT OF FPA0 
D6DB  BDD10D                    JSR  LB9BC         ;*SUBTRACT FPA0 FROM FPA1 
                      * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI                      
D6DE  8ED70F                    LDX  #LBFC2        ;POINT X TO FP (.25) 
D6E1  BDD10A                    JSR  LB9B9         ;SUBTRACT FPA0 FROM .25 (PI/2) 
D6E4  9654                      LDA  FP0SGN        ;GET MANTISSA SIGN OF FPA0 
D6E6  3402                      PSHS A             ;SAVE IT ON STACK 
D6E8  2A09                      BPL  LBFA6         ;BRANCH IF MANTISSA POSITIVE 
D6EA  BDD105                    JSR  LB9B4         ;ADD .5 (PI) TO FPA0 
D6ED  9654                      LDA  FP0SGN        ;GET SIGN OF FPA0 
D6EF  2B05                      BMI  LBFA9         ;BRANCH IF NEGATIVE 
D6F1  030A                      COM  RELFLG        ;COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG) 
D6F3  BDD63A          LBFA6     JSR  LBEE9         ;TOGGLE MANTISSA SIGN OF FPA0 
D6F6  8ED70F          LBFA9     LDX  #LBFC2        ;POINT X TO FP (.25) 
D6F9  BDD113                    JSR  LB9C2         ;ADD .25 (PI/2) TO FPA0 
D6FC  3502                      PULS A             ;GET OLD MANTISSA SIGN 
D6FE  4D                        TSTA               ;* BRANCH IF OLD 
D6FF  2A03                      BPL  LBFB7         ;* SIGN WAS POSITIVE 
D701  BDD63A                    JSR  LBEE9         ;TOGGLE MANTISSA SIGN 
D704  8ED714          LBFB7     LDX  #LBFC7        ;POINT X TO TABLE OF COEFFICIENTS 
D707  7ED641                    JMP  LBEF0         ;GO CALCULATE POLYNOMIAL VALUE 
                                                     
D70A  83490FDAA2      LBFBD     FCB  $83,$49,$0F,$DA,$A2 ;6.28318531 (2*PI) 
D70F  7F00000000      LBFC2     FCB  $7F,$00,$00,$00,$00 ;.25 
                                                     
                                                     
D714  05              LBFC7     FCB  6-1                 ;SIX COEFFICIENTS 
D715  84E61A2D1B      LBFC8     FCB  $84,$E6,$1A,$2D,$1B ;* -((2*PI)**11)/11! 
D71A  862807FBF8      LBFCD     FCB  $86,$28,$07,$FB,$F8 ;* ((2*PI)**9)/9! 
D71F  8799688901      LBFD2     FCB  $87,$99,$68,$89,$01 ;* -((2*PI)**7)/7! 
D724  872335DFE1      LBFD7     FCB  $87,$23,$35,$DF,$E1 ;* ((2*PI)**5)/5! 
D729  86A55DE728      LBFDC     FCB  $86,$A5,$5D,$E7,$28 ;* -((2*PI)**3)/3! 
D72E  83490FDAA2      LBFE1     FCB  $83,$49,$0F,$DA,$A2 ;* 
                                                     
D733  A154468F13                FCB  $A1,$54,$46,$8F,$13 ;UNUSED GARBAGE BYTES 
D738  8F524389CD                FCB  $8F,$52,$43,$89,$CD ;UNUSED GARBAGE BYTES 
                      * EXTENDED BASIC                      
                                                     
                      * COS                          
                      * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)                      
D73D  8ED770          COS       LDX  #L83AB        ;POINT X TO FP CONSTANT (P1/2) 
D740  BDD113                    JSR  LB9C2         ;ADD FPA0 TO (X) 
D743  7ED6C5          L837E     JMP  SIN           ;JUMP TO SIN ROUTINE 
                                                     
                      * TAN                          
                      * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)                      
D746  BDD380          TAN       JSR  LBC2F         ;PACK FPA0 AND MOVE IT TO FPA3 
D749  0F0A                      CLR  RELFLG        ;RESET QUADRANT FLAG 
D74B  8DF6                      BSR  L837E         ;CALCULATE SIN OF ARGUMENT 
D74D  8E004A                    LDX  #V4A          ;POINT X TO FPA5 
D750  BDD386                    JSR  LBC35         ;PACK FPA0 AND MOVE IT TO FPA5 
D753  8E0040                    LDX  #V40          ;POINT X TO FPA3 
D756  BDD365                    JSR  LBC14         ;MOVE FPA3 TO FPA0 
D759  0F54                      CLR  FP0SGN        ;FORCE FPA0 MANTISSA TO BE POSITIVE 
D75B  960A                      LDA  RELFLG        ;GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3 
D75D  8D0C                      BSR  L83A6         ;CALCULATE VALUE OF COS(FPA0) 
D75F  0D4F                      TST  FP0EXP        ;CHECK EXPONENT OF FPA0 
D761  1027FA7E                  LBEQ LBA92         ;'OV' ERROR IF COS(X)=0
D765  8E004A                    LDX  #V4A          ;POINT X TO FPA5 
D768  7ED2E0          L83A3     JMP  LBB8F         ;DIVIDE (X) BY FPA0 - SIN(X)/COS(X) 
D76B  3402            L83A6     PSHS A             ;SAVE SIGN FLAG ON STACK 
D76D  7ED6F3                    JMP  LBFA6         ;EXPAND POLYNOMIAL 
                                                     
D770  81490FDAA2      L83AB     FCB  $81,$49,$0F,$DA,$A2 ;1.57079633 (PI/2) 
                                                     
                      * ATN                          
                      * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE                      
                      * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED  
                      * TO EVALUATE THE EXPRESSION DEPENDING UPON                      
                      * WHETHER OR NOT THE ARGUMENT;SQUARED IS > OR < 1.0                      
                                                     
                      * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .                      
                      * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)                      
                                                     
D775  9654            ATN       LDA  FP0SGN        ;* GET THE SIGN OF THE MANTISSA AND 
D777  3402                      PSHS A             ;* SAVE IT ON THE STACK 
D779  2A02                      BPL  L83B8         ;BRANCH IF POSITIVE MANTISSA 
D77B  8D24                      BSR  L83DC         ;CHANGE SIGN OF FPA0 
D77D  964F            L83B8     LDA  FP0EXP        ;* GET EXPONENT OF FPA0 AND 
D77F  3402                      PSHS A             ;* SAVE IT ON THE STACK 
D781  8181                      CMPA #$81          ;IS FPAO < 1.0? 
D783  2505                      BLO  L83C5         ;YES 
D785  8ED216                    LDX  #LBAC5        ;POINT X TO FP CONSTANT 1.0 
D788  8DDE                      BSR  L83A3         ;GET RECIPROCAL OF FPA0 
D78A  8ED7A5          L83C5     LDX  #L83E0        ;POINT (X) TO TAYLOR SERIES COEFFICIENTS 
D78D  BDD641                    JSR  LBEF0         ;EXPAND POLYNOMIAL 
D790  3502                      PULS A             ;GET EXPONENT OF ARGUMENT 
D792  8181                      CMPA #$81          ;WAS ARGUMENT < 1.0? 
D794  2506                      BLO  L83D7         ;YES 
D796  8ED770                    LDX  #L83AB        ;POINT (X) TO FP NUMBER (PI/2) 
D799  BDD10A                    JSR  LB9B9         ;SUBTRACT FPA0 FROM (PI/2) 
D79C  3502            L83D7     PULS A             ;* GET SIGN OF INITIAL ARGUMENT MANTISSA 
D79E  4D                        TSTA               ;* AND SET FLAGS ACCORDING TO IT 
D79F  2A03                      BPL  L83DF         ;RETURN IF ARGUMENT WAS POSITIVE 
D7A1  7ED63A          L83DC     JMP  LBEE9         ;CHANGE MANTISSA SIGN OF FPA0 
D7A4  39              L83DF     RTS                  
                      *                              
                      * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT                      
D7A5  0B              L83E0     FCB  $0B           ;TWELVE COEFFICIENTS 
D7A6  76B383BDD3      L83E1     FCB  $76,$B3,$83,$BD,$D3 ;-6.84793912E-04 1/23 
D7AB  791EF4A6F5      L83E6     FCB  $79,$1E,$F4,$A6,$F5 ;+4.85094216E-03 1/21 
D7B0  7B83FCB010      L83EB     FCB  $7B,$83,$FC,$B0,$10 ;-0.0161117018 
D7B5  7C0C1F67CA      L83F0     FCB  $7C,$0C,$1F,$67,$CA ;0.0342096381 
D7BA  7CDE53CBC1      L83F5     FCB  $7C,$DE,$53,$CB,$C1 ;-0.0542791328 
D7BF  7D1464704C      L83FA     FCB  $7D,$14,$64,$70,$4C ;0.0724571965 
D7C4  7DB7EA517A      L83FF     FCB  $7D,$B7,$EA,$51,$7A ;-0.0898023954 
D7C9  7D6330887E      L8404     FCB  $7D,$63,$30,$88,$7E ;0.110932413 
D7CE  7E9244993A      L8409     FCB  $7E,$92,$44,$99,$3A ;-0.142839808 
D7D3  7E4CCC91C7      L840E     FCB  $7E,$4C,$CC,$91,$C7 ;0.199999121 
D7D8  7FAAAAAA13      L8413     FCB  $7F,$AA,$AA,$AA,$13 ;-0.333333316 
D7DD  8100000000      L8418     FCB  $81,$00,$00,$00,$00 ;1 
                      *                              
                      *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)                      
                      *                              
D7E2  03              L841D     FCB  3                   ;FOUR COEFFICIENTS 
D7E3  7F5E56CB79      L841E     FCB  $7F,$5E,$56,$CB,$79 ;0.434255942 
D7E8  80139B0B64      L8423     FCB  $80,$13,$9B,$0B,$64 ;0.576584541 
D7ED  8076389316      L8428     FCB  $80,$76,$38,$93,$16 ;0.961800759 
D7F2  8238AA3B20      L842D     FCB  $82,$38,$AA,$3B,$20 ;2.88539007 
                                                     
D7F7  803504F334      L8432     FCB  $80,$35,$04,$F3,$34 ;1/SQR(2) 
                                                     
D7FC  813504F334      L8437     FCB  $81,$35,$04,$F3,$34 ;SQR(2) 
                                                     
D801  8080000000      L843C     FCB  $80,$80,$00,$00,$00 ;-0.5 
                                                     
D806  80317217F8      L8441     FCB  $80,$31,$72,$17,$F8 ;LN(2) 
                      *                              
                      * LOG - NATURAL LOGARITHM (LN)                      
                                                     
                      * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING                      
                      * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC                      
                      * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF                      
                      * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS                      
                      * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF                      
                      * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE                      
                      * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION                      
D80B  BDD3BE          LOG       JSR  LBC6D         ;CHECK STATUS OF FPA0 
D80E  102FF3C4                  LBLE LB44A         ;'FC' ERROR IF NEGATIVE OR ZERO
D812  8ED7F7                    LDX  #L8432        ;POINT (X) TO FP NUMBER (1/SQR(2)) 
D815  964F                      LDA  FP0EXP        ;*GET EXPONENT OF ARGUMENT 
D817  8080                      SUBA #$80          ;*SUBTRACT OFF THE BIAS AND 
D819  3402                      PSHS A             ;*SAVE IT ON THE STACK 
D81B  8680                      LDA  #$80            
D81D  974F                      STA  FP0EXP          
D81F  BDD113                    JSR  LB9C2         ;ADD FPA0 TO (X) 
D822  8ED7FC                    LDX  #L8437        ;POINT X TO SQR(2) 
D825  BDD2E0                    JSR  LBB8F         ;DIVIDE SQR(2) BY FPA0 
D828  8ED216                    LDX  #LBAC5        ;POINT X TO FP VALUE OF 1.00 
D82B  BDD10A                    JSR  LB9B9         ;SUBTRACT FPA0 FROM (X) 
                      *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT  
D82E  8ED7E2                    LDX  #L841D        ;POINT X TO TABLE OF COEFFICIENTS 
D831  BDD641                    JSR  LBEF0         ;EXPAND POLYNOMIAL 
D834  8ED801                    LDX  #L843C        ;POINT X TO FP VALUE OF (-.5) 
D837  BDD113                    JSR  LB9C2         ;ADD FPA0 TO X 
D83A  3504                      PULS B             ;GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS) 
D83C  BDD4EA                    JSR  LBD99         ;ADD ACCB TO FPA0 
D83F  8ED806                    LDX  #L8441        ;POINT X TO LN(2) 
D842  7ED21B                    JMP  LBACA         ;MULTIPLY FPA0 * LN(2) 
                                                     
                      * SQR                          
D845  BDD3B0          SQR       JSR  LBC5F         ;MOVE FPA0 TO FPA1 
D848  8ED611                    LDX  #LBEC0        ;POINT (X) TO FP NUMBER (.5) 
D84B  BDD365                    JSR  LBC14         ;COPY A PACKED NUMBER FROM (X) TO FPA0 
                                                     
                      * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS                      
                      * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION                      
                      * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818                      
D84E  2767            L8489     BEQ  EXP           ;DO A NATURAL EXPONENTIATION IF EXPONENT = 0 
D850  4D                        TSTA               ;*CHECK VALUE BEING EXPONENTIATED 
D851  2603                      BNE  L8491         ;*AND BRANCH IF IT IS <> 0 
D853  7ED18B                    JMP  LBA3A         ;FPA0=0 IF RAISING ZERO TO A POWER 
D856  8E004A          L8491     LDX  #V4A          ;* PACK FPA0 AND SAVE 
D859  BDD386                    JSR  LBC35         ;* IT IN FPA5 (ARGUMENT'S EXPONENT)
D85C  5F                        CLRB               ;ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE 
D85D  9661                      LDA  FP1SGN        ;*CHECK THE SIGN OF ARGUMENT 
D85F  2A10                      BPL  L84AC         ;*BRANCH IF POSITIVE 
D861  BDD43F                    JSR  INT           ;CONVERT EXPONENT INTO AN INTEGER 
D864  8E004A                    LDX  #V4A          ;POINT X TO FPA5 (ORIGINAL EXPONENT) 
D867  9661                      LDA  FP1SGN        ;GET MANTISSA SIGN OF FPA1 (ARGUMENT) 
D869  BDD3F1                    JSR  LBCA0         ;*COMPARE FPA0 TO (X) AND 
D86C  2603                      BNE  L84AC         ;*BRANCH IF NOT EQUAL 
D86E  43                        COMA               ;TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE 
D86F  D601                      LDB  CHARAC        ;GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG) 
D871  BDD39D          L84AC     JSR  LBC4C         ;COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN 
D874  3404                      PSHS B             ;PUT RESULT SIGN FLAG ON THE STACK 
D876  BDD80B                    JSR  LOG             
D879  8E004A                    LDX  #V4A          ;POINT (X) TO FPA5 
D87C  BDD21B                    JSR  LBACA         ;MULTIPLY FPA0 BY FPA5 
D87F  8D36                      BSR  EXP           ;CALCULATE E**(FPA0) 
D881  3502                      PULS A             ;* GET RESULT SIGN FLAG FROM THE STACK 
D883  46                        RORA               ;* AND BRANCH IF NEGATIVE  
D884  1025FDB2                  LBCS LBEE9         ;CHANGE SIGN OF FPA0 MANTISSA 
D888  39                        RTS                  
                                                     
                      * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION                      
D889  8138AA3B29      L84C4     FCB  $81,$38,$AA,$3B,$29 ;1.44269504 ( CF ) 
                      *                              
                      * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X                      
                      *                              
D88E  07              L84C9     FCB  7                   ;EIGHT COEFFICIENTS 
D88F  7134583E56      L84CA     FCB  $71,$34,$58,$3E,$56 ;2.14987637E-05: 1/(7!*(CF**7)) 
D894  74167EB31B      L84CF     FCB  $74,$16,$7E,$B3,$1B ;1.4352314E-04 : 1/(6!*(CF**6)) 
D899  772FEEE385      L84D4     FCB  $77,$2F,$EE,$E3,$85 ;1.34226348E-03: 1/(5!*(CF**5)) 
D89E  7A1D841C2A      L84D9     FCB  $7A,$1D,$84,$1C,$2A ;9.61401701E-03: 1/(4!*(CF**4)) 
D8A3  7C6359580A      L84DE     FCB  $7C,$63,$59,$58,$0A ;0.0555051269 
D8A8  7E75FDE7C6      L84E3     FCB  $7E,$75,$FD,$E7,$C6 ;0.240226385 
D8AD  8031721810      L84E8     FCB  $80,$31,$72,$18,$10 ;0.693147186 
D8B2  8100000000      L84ED     FCB  $81,$00,$00,$00,$00 ;1 
                      *                              
                      * EXP ( E**X)                      
                      * THE EXPONENTIAL FUNCTION IS;EVALUATED BY FIRST MULTIPLYING THE                      
                      * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN                      
                      * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A                      
                      * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE                      
                      * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT                      
                      * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.                      
                                                     
D8B7  8ED889          EXP       LDX  #L84C4        ;POINT X TO THE CORRECTION FACTOR 
D8BA  BDD21B                    JSR  LBACA         ;MULTIPLY FPA0 BY (X) 
D8BD  BDD380                    JSR  LBC2F         ;PACK FPA0 AND STORE IT IN FPA3 
D8C0  964F                      LDA  FP0EXP        ;*GET EXPONENT OF FPA0 AND 
D8C2  8188                      CMPA #$88          ;*COMPARE TO THE MAXIMUM VALUE 
D8C4  2503                      BLO  L8504         ;BRANCH IF FPA0 < 128 
D8C6  7ED2AD          L8501     JMP  LBB5C         ;SET FPA0 = 0 OR 'OV' ERROR
D8C9  BDD43F          L8504     JSR  INT           ;CONVERT FPA0 TO INTEGER 
D8CC  9601                      LDA  CHARAC        ;GET LS BYTE OF INTEGER 
D8CE  8B81                      ADDA #$81          ;* WAS THE ARGUMENT =127, IF SO 
D8D0  27F4                      BEQ  L8501         ;* THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
                      *              * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW  
D8D2  4A                        DECA               ;DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE 
D8D3  3402                      PSHS A             ;SAVE EXPONENT OF INTEGER PORTION ON STACK 
D8D5  8E0040                    LDX  #V40          ;POINT (X) TO FPA3 
D8D8  BDD10A                    JSR  LB9B9         ;SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT 
D8DB  8ED88E                    LDX  #L84C9        ;POINT X TO COEFFICIENTS 
D8DE  BDD650                    JSR  LBEFF         ;EVALUATE POLYNOMIAL FOR FRACTIONAL PART 
D8E1  0F62                      CLR  RESSGN        ;FORCE THE MANTISSA TO BE POSITIVE 
D8E3  3502                      PULS A             ;GET INTEGER EXPONENT FROM STACK 
D8E5  BDD299                    JSR  LBB48         ;* CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE 
                      *              * INTEGER AND FRACTIONAL PARTS  
D8E8  39                        RTS                  
                                                     
                      * FIX                          
D8E9  BDD3BE          FIX       JSR  LBC6D         ;CHECK STATUS OF FPA0 
D8EC  2B03                      BMI  L852C         ;BRANCH IF FPA0 = NEGATIVE 
D8EE  7ED43F          L8529     JMP  INT           ;CONVERT FPA0 TO INTEGER 
D8F1  0354            L852C     COM  FP0SGN        ;TOGGLE SIGN OF FPA0 MANTISSA 
D8F3  8DF9                      BSR  L8529         ;CONVERT FPA0 TO INTEGER 
D8F5  7ED63A                    JMP  LBEE9         ;TOGGLE SIGN OF FPA0 
                                                     
                      * EDIT                         
D8F8  BDDD26          EDIT      JSR  L89AE         ;GET LINE NUMBER FROM BASIC 
D8FB  3262                      LEAS $02,S         ;PURGE RETURN ADDRESS OFF OF THE STACK  
D8FD  8601            L8538     LDA  #$01          ;'LIST' FLAG
D8FF  9798                      STA  VD8           ;SET FLAG TO LIST LINE 
D901  BDC4A7                    JSR  LAD01         ;GO FIND THE LINE NUMBER IN PROGRAM 
D904  1025ED7F                  LBCS LAED2         ;ERROR #7;'UNDEFINED LINE #'
D908  BDCF43                    JSR  LB7C2         ;GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1 
D90B  1F20                      TFR  Y,D           ;PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD 
D90D  8300F5                    SUBD #LINBUF+2     ;SUBTRACT OUT THE START OF LINE  
D910  D797                      STB  VD7           ;SAVE LENGTH OF LINE 
D912  DC2B            L854D     LDD  BINVAL        ;GET THE HEX VALUE OF LINE NUMBER 
D914  BDD51D                    JSR  LBDCC         ;LIST THE LINE NUMBER ON THE SCREEN 
D917  BDD0FD                    JSR  LB9AC         ;PRINT A SPACE 
D91A  8E00F4                    LDX  #LINBUF+1     ;POINT X TO BUFFER 
D91D  D698                      LDB  VD8           ;* CHECK TO SEE IF LINE IS TO BE 
D91F  2625                      BNE  L8581         ;* LISTED TO SCREEN - BRANCH IF IT IS 
D921  5F              L855C     CLRB               ;RESET DIGIT ACCUMULATOR - DEFAULT VALUE 
D922  BDDA4C          L855D     JSR  L8687         ;GET KEY STROKE 
D925  BDE1F1                    JSR  L90AA         ;SET CARRY IF NOT NUMERIC 
D928  250B                      BLO  L8570         ;BRANCH IF NOT NUMERIC 
D92A  8030                      SUBA #'0'          ;MASK OFF ASCII  
D92C  3402                      PSHS A             ;SAVE IT ON STACK  
D92E  860A                      LDA  #10           ;NUMBER BEING CONVERTED IS BASE 10 
D930  3D                        MUL                ;MULTIPLY ACCUMULATED VALUE BY BASE (10)  
D931  EBE0                      ADDB ,S+           ;ADD DIGIT TO ACCUMULATED VALUE  
D933  20ED                      BRA  L855D         ;CHECK FOR ANOTHER DIGIT 
D935  C001            L8570     SUBB #$01          ;* REPEAT PARAMETER IN ACCB; IF IT  
D937  C901                      ADCB #$01          ;*IS 0, THEN MAKE IT '1'
D939  8141                      CMPA #'A'          ;ABORT?          
D93B  2605                      BNE  L857D         ;NO 
D93D  BDD0AD                    JSR  LB958         ;PRINT CARRIAGE RETURN TO SCREEN 
D940  20BB                      BRA  L8538         ;RESTART EDIT PROCESS - CANCEL ALL CHANGES 
D942  814C            L857D     CMPA #'L'          ;LIST?           
D944  260B                      BNE  L858C         ;NO 
D946  8D31            L8581     BSR  L85B4         ;LIST THE LINE 
D948  0F98                      CLR  VD8           ;RESET THE LIST FLAG TO 'NO LIST'
D94A  BDD0AD                    JSR  LB958         ;PRINT CARRIAGE RETURN 
D94D  20C3                      BRA  L854D         ;GO INTERPRET ANOTHER EDIT COMMAND 
D94F  3262            L858A     LEAS $02,S         ;PURGE RETURN ADDRESS OFF OF THE STACK  
D951  810D            L858C     CMPA #CR           ;ENTER KEY?      
D953  260D                      BNE  L859D         ;NO 
D955  8D22                      BSR  L85B4         ;ECHO THE LINE TO THE SCREEN 
D957  BDD0AD          L8592     JSR  LB958         ;PRINT CARRIAGE RETURN 
D95A  8E00F4                    LDX  #LINBUF+1     ;* RESET BASIC'S INPUT POINTER
D95D  9F83                      STX  CHARAD        ;* TO THE LINE INPUT BUFFER 
D95F  7EC450                    JMP  LACA8         ;GO PUT LINE BACK IN PROGRAM 
D962  8145            L859D     CMPA #'E'          ;EXIT?           
D964  27F1                      BEQ  L8592         ;YES - SAME AS ENTER EXCEPT NO ECHO 
D966  8151                      CMPA #'Q'          ;QUIT?           
D968  2606                      BNE  L85AB         ;NO 
D96A  BDD0AD                    JSR  LB958         ;PRINT CARRIAGE RETURN TO SCREEN 
D96D  7EC427                    JMP  LAC73         ;GO TO COMMAND LEVEL - MAKE NO CHANGES 
D970  8D02            L85AB     BSR  L85AF         ;INTERPRET THE REMAINING COMMANDS AS SUBROUTINES 
D972  20AD                      BRA  L855C         ;GO INTERPRET ANOTHER EDIT COMMAND 
D974  8120            L85AF     CMPA #SPACE        ;SPACE BAR?      
D976  2610                      BNE  L85C3         ;NO 
D978  8C              L85B3     FCB  SKP2          ;SKIP TWO BYTES 
                      * DISPLAY THE NEXT ACCB BYTES;OF THE LINE IN THE BUFFER TO THE SCREEN                      
                      *                              
D979  C6F9            L85B4     LDB  #LBUFMX-1     ;250 BYTES MAX IN BUFFER 
D97B  A684            L85B6     LDA  ,X            ;GET A CHARACTER FROM BUFFER 
D97D  2708                      BEQ  L85C2         ;EXIT IF IT'S A 0
D97F  BDC017                    JSR  PUTCHR        ;SEND CHAR TO CONSOLE OUT 
D982  3001                      LEAX $01,X         ;MOVE POINTER UP ONE  
D984  5A                        DECB               ;DECREMENT CHARACTER COUNTER  
D985  26F4                      BNE  L85B6         ;LOOP IF NOT DONE 
D987  39              L85C2     RTS                  
D988  8144            L85C3     CMPA #'D'          ;DELETE?         
D98A  2648                      BNE  L860F         ;NO 
D98C  6D84            L85C7     TST  ,X            ;* CHECK FOR END OF LINE 
D98E  27F7                      BEQ  L85C2         ;* AND BRANCH IF SO 
D990  8D04                      BSR  L85D1         ;REMOVE A CHARACTER 
D992  5A                        DECB               ;DECREMENT REPEAT PARAMETER  
D993  26F7                      BNE  L85C7         ;BRANCH IF NOT DONE 
D995  39                        RTS                  
                      * REMOVE ONE CHARACTER FROM BUFFER                      
D996  0A97            L85D1     DEC  VD7           ;DECREMENT LENGTH OF BUFFER 
D998  311F                      LEAY -1,X        ;POINT Y TO ONE BEFORE CURRENT BUFFER POINTER  
D99A  3121            L85D5     LEAY $01,Y         ;INCREMENT TEMPORARY BUFFER POINTER  
D99C  A621                      LDA  $01,Y         ;GET NEXT CHARACTER 
D99E  A7A4                      STA  ,Y            ;PUT IT IN CURRENT POSITION 
D9A0  26F8                      BNE  L85D5         ;BRANCH IF NOT END OF LINE 
D9A2  39                        RTS                  
D9A3  8149            L85DE     CMPA #'I'          ;INSERT?         
D9A5  2713                      BEQ  L85F5         ;YES 
D9A7  8158                      CMPA #'X'          ;EXTEND?         
D9A9  270D                      BEQ  L85F3         ;YES 
D9AB  8148                      CMPA #'H'          ;HACK?           
D9AD  265C                      BNE  L8646         ;NO 
D9AF  6F84                      CLR  ,X            ;TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG 
D9B1  1F10                      TFR  X,D           ;PUT CURRENT BUFFER POINTER IN ACCD 
D9B3  8300F5                    SUBD #LINBUF+2     ;SUBTRACT INITIAL POINTER POSITION  
D9B6  D797                      STB  VD7           ;SAVE NEW BUFFER LENGTH 
D9B8  8DBF            L85F3     BSR  L85B4         ;DISPLAY THE LINE ON THE SCREEN 
D9BA  BDDA4C          L85F5     JSR  L8687         ;GET A KEYSTROKE 
D9BD  810D                      CMPA #CR           ;ENTER KEY?      
D9BF  278E                      BEQ  L858A         ;YES - INTERPRET ANOTHER COMMAND - PRINT LINE 
D9C1  811B                      CMPA #ESC          ;ESCAPE?         
D9C3  2725                      BEQ  L8625         ;YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
D9C5  8108                      CMPA #BS           ;BACK SPACE?     
D9C7  2622                      BNE  L8626         ;NO 
D9C9  8C00F4                    CMPX #LINBUF+1     ;COMPARE POINTER TO START OF BUFFER  
D9CC  27EC                      BEQ  L85F5         ;DO NOT ALLOW BS IF AT START 
D9CE  8D45                      BSR  L8650         ;MOVE POINTER BACK ONE, BS TO SCREEN 
D9D0  8DC4                      BSR  L85D1         ;REMOVE ONE CHARACTER FROM BUFFER 
D9D2  20E6                      BRA  L85F5         ;GET INSERT SUB COMMAND 
D9D4  8143            L860F     CMPA #'C'          ;CHANGE?         
D9D6  26CB                      BNE  L85DE         ;NO 
D9D8  6D84            L8613     TST  ,X            ;CHECK CURRENT BUFFER CHARACTER 
D9DA  270E                      BEQ  L8625         ;BRANCH IF END OF LINE 
D9DC  BDDA4C                    JSR  L8687         ;GET A KEYSTROKE 
D9DF  2502                      BLO  L861E         ;BRANCH IF LEGITIMATE KEY 
D9E1  20F5                      BRA  L8613         ;TRY AGAIN IF ILLEGAL KEY 
D9E3  A780            L861E     STA  ,X+           ;INSERT NEW CHARACTER INTO BUFFER 
D9E5  8D37                      BSR  L8659         ;SEND NEW CHARACTER TO SCREEN 
D9E7  5A                        DECB               ;DECREMENT REPEAT PARAMETER  
D9E8  26EE                      BNE  L8613         ;BRANCH IF NOT DONE 
D9EA  39              L8625     RTS                  
D9EB  D697            L8626     LDB  VD7           ;GET LENGTH OF LINE 
D9ED  C1F9                      CMPB #LBUFMX-1     ;COMPARE TO MAXIMUM LENGTH  
D9EF  2602                      BNE  L862E         ;BRANCH IF NOT AT MAXIMUM 
D9F1  20C7                      BRA  L85F5         ;IGNORE INPUT IF LINE AT MAXIMUM LENGTH 
D9F3  3410            L862E     PSHS X             ;SAVE CURRENT BUFFER POINTER  
D9F5  6D80            L8630     TST  ,X+           ;* SCAN THE LINE UNTIL END OF 
D9F7  26FC                      BNE  L8630         ;* LINE (0) IS FOUND 
D9F9  E682            L8634     LDB  ,-X           ;DECR TEMP LINE POINTER AND GET A CHARACTER 
D9FB  E701                      STB  $01,X         ;PUT CHARACTER BACK DOWN ONE SPOT 
D9FD  ACE4                      CMPX ,S            ;HAVE WE REACHED STARTING POINT?  
D9FF  26F8                      BNE  L8634         ;NO - KEEP GOING 
DA01  3262                      LEAS $02,S         ;PURGE BUFFER POINTER FROM STACK  
DA03  A780                      STA  ,X+           ;INSERT NEW CHARACTER INTO THE LINE 
DA05  8D17                      BSR  L8659         ;SEND A CHARACTER TO CONSOLE OUT 
DA07  0C97                      INC  VD7           ;ADD ONE TO BUFFER LENGTH 
DA09  20AF                      BRA  L85F5         ;GET INSERT SUB COMMAND 
DA0B  8108            L8646     CMPA #BS           ;BACKSPACE?      
DA0D  2612                      BNE  L865C         ;NO 
DA0F  8D04            L864A     BSR  L8650         ;MOVE POINTER BACK 1, SEND BS TO SCREEN 
DA11  5A                        DECB               ;DECREMENT REPEAT PARAMETER  
DA12  26FB                      BNE  L864A         ;LOOP UNTIL DONE 
DA14  39                        RTS                  
DA15  8C00F4          L8650     CMPX #LINBUF+1     ;COMPARE POINTER TO START OF BUFFER  
DA18  27D0                      BEQ  L8625         ;DO NOT ALLOW BS IF AT START 
DA1A  301F                      LEAX -1,X        ;MOVE POINTER BACK ONE  
DA1C  8608                      LDA  #BS           ;BACK SPACE 
DA1E  7EC017          L8659     JMP  PUTCHR        ;SEND TO CONSOLE OUT 
DA21  814B            L865C     CMPA #'K'          ;KILL?           
DA23  2705                      BEQ  L8665         ;YES 
DA25  8053                      SUBA #'S'          ;SEARCH?         
DA27  2701                      BEQ  L8665         ;YES 
DA29  39                        RTS                  
DA2A  3402            L8665     PSHS A             ;SAVE KILL/SEARCH FLAG ON STACK  
DA2C  8D1E                      BSR  L8687         ;* GET A KEYSTROKE (TARGET CHARACTER) 
DA2E  3402                      PSHS A             ;* AND SAVE IT ON STACK  
DA30  A684            L866B     LDA  ,X            ;GET CURRENT BUFFER CHARACTER 
DA32  2716                      BEQ  L8685         ;AND RETURN IF END OF LINE 
DA34  6D61                      TST  $01,S         ;CHECK KILL/SEARCH FLAG 
DA36  2606                      BNE  L8679         ;BRANCH IF KILL 
DA38  8DE4                      BSR  L8659         ;SEND A CHARACTER TO CONSOLE OUT 
DA3A  3001                      LEAX 1,X           ;INCREMENT BUFFER POINTER  
DA3C  2003                      BRA  L867C         ;CHECK NEXT INPUT CHARACTER 
DA3E  BDD996          L8679     JSR  L85D1         ;REMOVE ONE CHARACTER FROM BUFFER 
DA41  A684            L867C     LDA  ,X            ;GET CURRENT INPUT CHARACTER 
DA43  A1E4                      CMPA ,S            ;COMPARE TO TARGET CHARACTER  
DA45  26E9                      BNE  L866B         ;BRANCH IF NO MATCH 
DA47  5A                        DECB               ;DECREMENT REPEAT PARAMETER  
DA48  26E6                      BNE  L866B         ;BRANCH IF NOT DONE 
DA4A  35A0            L8685     PULS Y,PC          ;THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A  
                      *                              
                      * GET A KEYSTRKE                      
DA4C  BDC003          L8687     JSR  LA171         ;CALL CONSOLE IN : DEV NBR=SCREEN 
DA4F  817F                      CMPA #$7F          ;GRAPHIC CHARACTER?  
DA51  24F9                      BCC  L8687         ;YES - GET ANOTHER CHAR 
DA53  815F                      CMPA #$5F          ;SHIFT UP ARROW (QUIT INSERT)  
DA55  2602                      BNE  L8694         ;NO 
DA57  861B                      LDA  #ESC          ;REPLACE W/ESCAPE CODE 
DA59  810D            L8694     CMPA #CR           ;ENTER KEY       
DA5B  270E                      BEQ  L86A6         ;YES 
DA5D  811B                      CMPA #ESC          ;ESCAPE?         
DA5F  270A                      BEQ  L86A6         ;YES 
DA61  8108                      CMPA #BS           ;BACKSPACE?      
DA63  2706                      BEQ  L86A6         ;YES 
DA65  8120                      CMPA #SPACE        ;SPACE           
DA67  25E3                      BLO  L8687         ;GET ANOTHER CHAR IF CONTROL CHAR 
DA69  1A01                      ORCC #$01          ;SET CARRY       
DA6B  39              L86A6     RTS                  
                                                     
                      * TRON                         
DA6C  86              TRON      FCB  SKP1LD        ;SKIP ONE BYTE AND LDA #$4F 
                                                     
                      * TROFF                        
DA6D  4F              TROFF     CLRA               ;TROFF FLAG 
DA6E  978C                      STA  TRCFLG        ;TRON/TROFF FLAG:0=TROFF, <> 0=TRON 
DA70  39                        RTS                  
                                                     
                      * POS                          
                                                     
DA71  8600            POS       LDA  #0            ;GET DEVICE NUMBER 
DA73  D679                      LDB  LPTPOS        ;GET PRINT POSITION 
DA75  1D              LA5E8     SEX                ;CONVERT ACCB TO 2 DIGIT SIGNED INTEGER 
DA76  7ECC80                    JMP  GIVABF        ;CONVERT ACCD TO FLOATING POINT 
                                                     
                                                     
                      * VARPTR                       
DA79  BDC9FB          VARPT     JSR  LB26A         ;SYNTAX CHECK FOR '('
DA7C  DC1F                      LDD  ARYEND        ;GET ADDR OF END OF ARRAYS 
DA7E  3406                      PSHS B,A           ;SAVE IT ON STACK 
DA80  BDCAE3                    JSR  LB357         ;GET VARIABLE DESCRIPTOR 
DA83  BDC9F8                    JSR  LB267         ;SYNTAX CHECK FOR ')'
DA86  3506                      PULS A,B           ;GET END OF ARRAYS ADDR BACK 
DA88  1E10                      EXG  X,D           ;SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR 
DA8A  9C1F                      CMPX ARYEND        ;COMPARE TO NEW END OF ARRAYS 
DA8C  2651                      BNE  L8724         ;'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
DA8E  7ECC80                    JMP  GIVABF        ;CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER 
                                                     
                      * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT                      
DA91  9D7C            L86D6     JSR  GETNCH        ;GET INPUT CHAR FROM BASIC 
DA93  BDC9FB                    JSR  LB26A         ;SYNTAX CHECK FOR '('
DA96  BDCAE3                    JSR  LB357         ;* GET VARIABLE DESCRIPTOR ADDRESS AND 
DA99  3410                      PSHS X             ;* SAVE IT ON THE STACK 
DA9B  EC02                      LDD  $02,X         ;POINT ACCD TO START OF OLDSTRING 
DA9D  109321                    CMPD FRETOP        ;COMPARE TO START OF CLEARED SPACE 
DAA0  2304                      BLS  L86EB         ;BRANCH IF <= 
DAA2  9327                      SUBD MEMSIZ        ;SUBTRACT OUT TOP OF CLEARED SPACE 
DAA4  2312                      BLS  L86FD         ;BRANCH IF STRING IN STRING SPACE 
DAA6  E684            L86EB     LDB  ,X            ;GET LENGTH OF OLDSTRING 
DAA8  BDCCF9                    JSR  LB56D         ;RESERVE ACCB BYTES IN STRING SPACE 
DAAB  3410                      PSHS X             ;SAVE RESERVED SPACE STRING ADDRESS ON STACK 
DAAD  AE62                      LDX  $02,S         ;POINT X TO OLDSTRING DESCRIPTOR 
DAAF  BDCDCF                    JSR  LB643         ;MOVE OLDSTRING INTO STRING SPACE 
DAB2  3550                      PULS X,U           ;* GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING 
DAB4  AF42                      STX  $02,U         ;* ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS 
DAB6  3440                      PSHS U             ;SAVE OLDSTRING DESCRIPTOR ADDRESS 
DAB8  BDCEC4          L86FD     JSR  LB738         ;SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION 
DABB  3404                      PSHS B             ;SAVE POSITION PARAMETER ON STACK 
DABD  5D                        TSTB               ;* CHECK POSITION PARAMETER AND BRANCH  
DABE  271F                      BEQ  L8724         ;* IF START OF STRING 
DAC0  C6FF                      LDB  #$FF          ;DEFAULT REPLACEMENT LENGTH = $FF 
DAC2  8129                      CMPA #')'          ;* CHECK FOR END OF MID$ STATEMENT AND 
DAC4  2703                      BEQ  L870E         ;* BRANCH IF AT END OF STATEMENT 
DAC6  BDCEC4                    JSR  LB738         ;SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION 
DAC9  3404            L870E     PSHS B             ;SAVE LENGTH PARAMETER ON STACK 
DACB  BDC9F8                    JSR  LB267         ;SYNTAX CHECK FOR ')'
DACE  C6AE                      LDB  #TOK_EQUALS   ;TOKEN FOR = 
DAD0  BDCA00                    JSR  LB26F         ;SYNTAX CHECK FOR '='
DAD3  8D2E                      BSR  L8748         ;EVALUATE REPLACEMENT STRING 
DAD5  1F13                      TFR  X,U           ;SAVE REPLACEMENT STRING ADDRESS IN U 
DAD7  AE62                      LDX  $02,S         ;POINT X TO OLOSTRING DESCRIPTOR ADDRESS 
DAD9  A684                      LDA  ,X            ;GET LENGTH OF OLDSTRING 
DADB  A061                      SUBA $01,S         ;SUBTRACT POSITION PARAMETER 
DADD  2403                      BCC  L8727         ;INSERT REPLACEMENT STRING INTO OLDSTRING 
DADF  7ECBD6          L8724     JMP  LB44A         ;'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
DAE2  4C              L8727     INCA               ;* NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT 
                      *                            ;* (INCLUSIVE) OF THE POSITION PARAMETER 
DAE3  A1E4                      CMPA ,S              
DAE5  2402                      BCC  L872E         ;BRANCH IF NEW STRING WILL FIT IN OLDSTRING 
DAE7  A7E4                      STA  ,S            ;IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT 
DAE9  A661            L872E     LDA  $01,S         ;GET POSITION PARAMETER 
DAEB  1E89                      EXG  A,B           ;ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER 
DAED  AE02                      LDX  $02,X         ;POINT X TO OLDSTRING ADDRESS 
DAEF  5A                        DECB               ;* BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
                      *                            ;* WANTS IT TO START AT ZERO 
DAF0  3A                        ABX                ;POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO 
DAF1  4D                        TSTA               ;* IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO 
DAF2  270D                      BEQ  L8746         ;* THEN RETURN 
DAF4  A1E4                      CMPA ,S              
DAF6  2302                      BLS  L873F         ;ADJUSTED LENGTH PARAMETER, THEN BRANCH 
DAF8  A6E4                      LDA  ,S            ;OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE 
DAFA  1F89            L873F     TFR  A,B           ;SAVE NUMBER OF BYTES TO MOVE IN ACCB 
DAFC  1E31                      EXG  U,X           ;SWAP SOURCE AND DESTINATION POINTERS 
DAFE  BDC1B1                    JSR  LA59A         ;MOVE (B) BYTES FROM (X) TO (U) 
DB01  3596            L8746     PULS A,B,X,PC        
DB03  BDC8E7          L8748     JSR  LB156         ;EVALUATE EXPRESSION 
DB06  7ECDE0                    JMP  LB654         ;*'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
                      *                            ;*TO STRING, ACCB = LENGTH 
                                                     
                      * STRING                       
DB09  BDC9FB          STRING    JSR  LB26A         ;SYNTAX CHECK FOR '('
DB0C  BDCE97                    JSR  LB70B         ;EVALUATE EXPRESSION; ERROR IF > 255 
DB0F  3404                      PSHS B             ;SAVE LENGTH OF STRING 
DB11  BDC9FE                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DB14  BDC8E7                    JSR  LB156         ;EVALUATE EXPRESSION 
DB17  BDC9F8                    JSR  LB267         ;SYNTAX CHECK FOR ')'
DB1A  9606                      LDA  VALTYP        ;GET VARIABLE TYPE 
DB1C  2605                      BNE  L8768         ;BRANCH IF STRING 
DB1E  BDCE9A                    JSR  LB70E         ;CONVERT FPA0 INTO AN INTEGER IN ACCB 
DB21  2003                      BRA  L876B         ;SAVE THE STRING IN STRING SPACE 
DB23  BDCE30          L8768     JSR  LB6A4         ;GET FIRST BYTE OF STRING 
DB26  3404            L876B     PSHS B             ;SAVE FIRST BYTE OF EXPRESSION 
DB28  E661                      LDB  $01,S         ;GET LENGTH OF STRING 
DB2A  BDCC9B                    JSR  LB50F         ;RESERVE ACCB BYTES IN STRING SPACE 
DB2D  3506                      PULS A,B           ;GET LENGTH OF STRING AND CHARACTER 
DB2F  2705                      BEQ  L877B         ;BRANCH IF NULL STRING 
DB31  A780            L8776     STA  ,X+           ;SAVE A CHARACTER IN STRING SPACE 
DB33  5A                        DECB               ;DECREMENT LENGTH 
DB34  26FB                      BNE  L8776         ;BRANCH IF NOT DONE 
DB36  7ECE27          L877B     JMP  LB69B         ;PUT STRING DESCRIPTOR ONTO STRING STACK 
                                                     
                      * INSTR                        
DB39  BDC9FB          INSTR     JSR  LB26A         ;SYNTAX CHECK FOR '('
DB3C  BDC8E7                    JSR  LB156         ;EVALUATE EXPRESSION 
DB3F  C601                      LDB  #$01          ;DEFAULT POSITION = 1 (SEARCH START) 
DB41  3404                      PSHS B             ;SAVE START 
DB43  9606                      LDA  VALTYP        ;GET VARIABLE TYPE 
DB45  2610                      BNE  L879C         ;BRANCH IF STRING 
DB47  BDCE9A                    JSR  LB70E         ;CONVERT FPA0 TO INTEGER IN ACCB 
DB4A  E7E4                      STB  ,S            ;SAVE START SEARCH VALUE 
DB4C  2791                      BEQ  L8724         ;BRANCH IF START SEARCH AT ZERO 
DB4E  BDC9FE                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DB51  BDC8E7                    JSR  LB156         ;EVALUATE EXPRESSION - SEARCH STRING 
DB54  BDC8D7                    JSR  LB146         ;'TM' ERROR IF NUMERIC
DB57  9E52            L879C     LDX  FPA0+2        ;SEARCH STRING DESCRIPTOR ADDRESS 
DB59  3410                      PSHS X             ;SAVE ON THE STACK 
DB5B  BDC9FE                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DB5E  BDDB03                    JSR  L8748         ;EVALUATE TARGET STRING EXPRESSION 
DB61  3414                      PSHS X,B           ;SAVE ADDRESS AND LENGTH ON STACK 
DB63  BDC9F8                    JSR  LB267         ;SYNTAX CHECK FOR ')' 
DB66  AE63                      LDX  $03,S         ;* LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS 
DB68  BDCDE5                    JSR  LB659         ;* AND GET THE LENGTH ANDADDRESS OF SEARCH STRING 
DB6B  3404                      PSHS B             ;SAVE LENGTH ON STACK 
                      *                              
                      * AT THIS POINT THE STACK HAS;THE FOLLOWING INFORMATION                      
                      * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET                      
                      * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION                      
DB6D  E166                      CMPB $06,S         ;COMPARE LENGTH OF SEARCH STRING TO START 
DB6F  2523                      BLO  L87D9         ;POSITION; RETURN 0 IF LENGTH < START 
DB71  A661                      LDA  $01,S         ;GET LENGTH OF TARGET STRING 
DB73  271C                      BEQ  L87D6         ;BRANCH IF TARGET STRING = NULL 
DB75  E666                      LDB  $06,S         ;GET START POSITION 
DB77  5A                        DECB               ;MOVE BACK ONE 
DB78  3A                        ABX                ;POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START  
DB79  3184            L87BE     LEAY ,X            ;POINT Y TO SEARCH POSITION 
DB7B  EE62                      LDU  $02,S         ;POINT U TO START OF TARGET 
DB7D  E661                      LDB  $01,S         ;LOAD ACCB WITH LENGTH OF TARGET 
DB7F  A6E4                      LDA  ,S            ;LOAD ACCA WITH LENGTH OF SEARCH 
DB81  A066                      SUBA $06,S         ;SUBTRACT SEARCH POSITION FROM SEARCH LENGTH 
DB83  4C                        INCA               ;ADD ONE 
DB84  A161                      CMPA $01,S         ;COMPARE TO TARGET LENGTH 
DB86  250C                      BLO  L87D9         ;RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
DB88  A680            L87CD     LDA  ,X+           ;GET A CHARACTER FROM SEARCH STRING 
DB8A  A1C0                      CMPA ,U+           ;COMPARE IT TO TARGET STRING 
DB8C  260C                      BNE  L87DF         ;BRANCH IF NO MATCH 
DB8E  5A                        DECB               ;DECREMENT TARGET LENGTH 
DB8F  26F7                      BNE  L87CD         ;CHECK ANOTHER CHARACTER 
DB91  E666            L87D6     LDB  $06,S         ;GET MATCH POSITION 
DB93  21              L87D8     FCB  SKP1          ;SKIP NEXT BYTE 
DB94  5F              L87D9     CLRB               ;MATCH ADDRESS = 0 
DB95  3267                      LEAS $07,S         ;CLEAN UP THE STACK 
DB97  7ECC7F                    JMP  LB4F3         ;CONVERT ACCB TO FP NUMBER 
DB9A  6C66            L87DF     INC  $06,S         ;INCREMENT SEARCH POSITION 
DB9C  3021                      LEAX 1,Y           ;MOVE X TO NEXT SEARCH POSITION 
DB9E  20D9                      BRA  L87BE         ;KEEP LOOKING FOR A MATCH 
                                                     
                      * EXTENDED BASIC RVEC19 HOOK CODE                      
DBA0  8126            XVEC19    CMPA #'&'          ;* 
DBA2  265C                      BNE  L8845         ;* RETURN IF NOT HEX OR OCTAL VARIABLE 
DBA4  3262                      LEAS $02,S         ;PURGE RETURN ADDRESS FROM STACK 
                      * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
DBA6  0F52            L87EB     CLR  FPA0+2        ;* CLEAR BOTTOM TWO 
DBA8  0F53                      CLR  FPA0+3        ;* BYTES OF FPA0 
DBAA  8E0052                    LDX  #FPA0+2       ;BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR) 
DBAD  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DBAF  814F                      CMPA #'O'            
DBB1  2712                      BEQ  L880A         ;YES 
DBB3  8148                      CMPA #'H'            
DBB5  2723                      BEQ  L881F         ;YES 
DBB7  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DBB9  200C                      BRA  L880C         ;DEFAULT TO OCTAL (&O) 
DBBB  8138            L8800     CMPA #'8'            
DBBD  1022EE47                  LBHI LB277           
DBC1  C603                      LDB  #$03          ;BASE 8 MULTIPLIER 
DBC3  8D2A                      BSR  L8834         ;ADD DIGIT TO TEMPORARY ACCUMULATOR 
                      * EVALUATE AN &O VARIABLE                      
DBC5  9D7C            L880A     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DBC7  25F2            L880C     BLO  L8800         ;BRANCH IF NUMERIC 
DBC9  0F50            L880E     CLR  FPA0          ;* CLEAR 2 HIGH ORDER 
DBCB  0F51                      CLR  FPA0+1        ;* BYTES OF FPA0 
DBCD  0F06                      CLR  VALTYP        ;SET VARXABLE TYPE TO NUMERIC 
DBCF  0F63                      CLR  FPSBYT        ;ZERO OUT SUB BYTE OF FPA0 
DBD1  0F54                      CLR  FP0SGN        ;ZERO OUT MANTISSA SIGN OF FPA0 
DBD3  C6A0                      LDB  #$A0          ;* SET EXPONENT OF FPA0 
DBD5  D74F                      STB  FP0EXP        ;* 
DBD7  7ED16D                    JMP  LBA1C         ;GO NORMALIZE FPA0 
                      * EVALUATE AN &H VARIABLE                      
DBDA  9D7C            L881F     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DBDC  250B                      BLO  L882E         ;BRANCH IF NUMERIC 
DBDE  BDCB2E                    JSR  LB3A2         ;SET CARRY IF NOT ALPHA 
DBE1  25E6                      BLO  L880E         ;BRANCH IF NOT ALPHA OR NUMERIC 
DBE3  8147                      CMPA #'G'          ;CHECK FOR LETTERS A-F 
DBE5  24E2                      BCC  L880E         ;BRANCH IF >= G (ILLEGAL HEX LETTER) 
DBE7  8007                      SUBA #7            ;SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9 
DBE9  C604            L882E     LDB  #$04          ;BASE 16 DIGIT MULTIPLIER = 2**4 
DBEB  8D02                      BSR  L8834         ;ADD DIGIT TO TEMPORARY ACCUMULATOR 
DBED  20EB                      BRA  L881F         ;KEEP EVALUATING VARIABLE 
DBEF  6801            L8834     ASL  $01,X         ;* MULTIPLY TEMPORARY 
DBF1  6984                      ROL  ,X            ;* ACCUMULATOR BY TWO 
DBF3  1025F5EC                  LBCS LBA92         ;'OV' OVERFLOW ERROR
DBF7  5A                        DECB               ;DECREMENT SHIFT COUNTER 
DBF8  26F5                      BNE  L8834         ;MULTIPLY TEMPORARY ACCUMULATOR AGAIN 
DBFA  8030                      SUBA #'0'          ;MASK OFF ASCII 
DBFC  AB01                      ADDA $01,X         ;* ADD DIGIT TO TEMPORARY 
DBFE  A701                      STA  $01,X         ;* ACCUMULATOR AND SAVE IT 
DC00  39              L8845     RTS                  
                                                     
DC01  3540            XVEC15    PULS U             ;PULL RETURN ADDRESS AND SAVE IN U REGISTER 
DC03  0F06                      CLR  VALTYP        ;SET VARIABLE TYPE TO NUMERIC 
DC05  9E83                      LDX  CHARAD        ;CURRENT INPUT POINTER TO X 
DC07  9D7C                      JSR  GETNCH        ;GET CHARACTER FROM BASIC 
DC09  8126                      CMPA #'&'          ;HEX AND OCTAL VARIABLES ARE PRECEEDED BY & 
DC0B  2799                      BEQ  L87EB         ;PROCESS A '&' VARIABLE
DC0D  81B0                      CMPA #TOK_FN       ;TOKEN FOR FN 
DC0F  275E                      BEQ  L88B4         ;PROCESS FN CALL 
DC11  81FF                      CMPA #$FF          ;CHECK FOR SECONDARY TOKEN 
DC13  2608                      BNE  L8862         ;NOT SECONDARY 
DC15  9D7C                      JSR  GETNCH        ;GET CHARACTER FROM BASIC 
DC17  8183                      CMPA #TOK_USR      ;TOKEN FOR USR 
DC19  102700AB                  LBEQ L892C         ;PROCESS USR CALL 
DC1D  9F83            L8862     STX  CHARAD        ;RESTORE BASIC'S INPUT POINTER
DC1F  6EC4                      JMP  ,U            ;RETURN TO CALLING ROUTINE 
DC21  9E68            L8866     LDX  CURLIN        ;GET CURRENT LINE NUMBER 
DC23  3001                      LEAX 1,X           ;IN DIRECT MODE? 
DC25  26D9                      BNE  L8845         ;RETURN IF NOT IN DIRECT MODE 
DC27  C616                      LDB  #2*11         ;'ILLEGAL DIRECT STATEMENT' ERROR
DC29  7EC408          L886E     JMP  LAC46         ;PROCESS ERROR 
                                                     
DC2C  AE9F0083        DEF       LDX  [CHARAD]      ;GET TWO INPUT CHARS 
DC30  8CFF83                    CMPX #TOK_FF_USR   ;TOKEN FOR USR 
DC33  10270074                  LBEQ L890F         ;BRANCH IF DEF USR 
DC37  8D23                      BSR  L88A1         ;GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME 
DC39  8DE6                      BSR  L8866         ;DON'T ALLOW DEF FN IF IN DIRECT MODE
DC3B  BDC9FB                    JSR  LB26A         ;SYNTAX CHECK FOR '('
DC3E  C680                      LDB  #$80          ;* GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE 
DC40  D708                      STB  ARYDIS        ;* AND SAVE IT IN THE ARRAY DISABLE FLAG 
DC42  BDCAE3                    JSR  LB357         ;GET VARIABLE DESCRIPTOR 
DC45  8D25                      BSR  L88B1         ;'TM' ERROR IF STRING
DC47  BDC9F8                    JSR  LB267         ;SYNTAX CHECK FOR ')'
DC4A  C6AE                      LDB  #TOK_EQUALS   ;TOKEN FOR '='
DC4C  BDCA00                    JSR  LB26F         ;DO A SYNTAX CHECK FOR = 
DC4F  9E4B                      LDX  V4B           ;GET THE ADDRESS OF THE FN NAME DESCRIPTOR 
DC51  DC83                      LDD  CHARAD        ;* GET THE CURRENT INPUT POINTER ADDRESS AND 
DC53  ED84                      STD  ,X            ;* SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR 
DC55  DC39                      LDD  VARPTR        ;= GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT 
DC57  ED02                      STD  $02,X         ;= VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME 
DC59  7EC695                    JMP  DATA          ;MOVE INPUT POINTER TO END OF LINE OR SUBLINE 
DC5C  C6B0            L88A1     LDB  #TOK_FN       ;TOKEN FOR FN 
DC5E  BDCA00                    JSR  LB26F         ;DO A SYNTAX CHECK FOR FN 
DC61  C680                      LDB  #$80          ;* GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG 
DC63  D708                      STB  ARYDIS        ;* AND SAVE IT IN ARRAY VARIABLE FLAG 
DC65  8A80                      ORA  #$80          ;SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE 
DC67  BDCAE8                    JSR  LB35C         ;* GET THE DESCRIPTOR ADDRESS OF THIS 
DC6A  9F4B                      STX  V4B           ;* VARIABLE AND SAVE IT IN V4B 
DC6C  7EC8D4          L88B1     JMP  LB143         ;'TM' ERROR IF STRING VARIABLE
                      * EVALUATE AN FN CALL                      
DC6F  8DEB            L88B4     BSR  L88A1         ;* GET THE DESCRIPTOR OF THE FN NAME 
DC71  3410                      PSHS X             ;* VARIABLE AND SAVE IT ON THE STACK 
DC73  BDC9F3                    JSR  LB262         ;SYNTAX CHECK FOR '(' & EVALUATE EXPR
DC76  8DF4                      BSR  L88B1         ;'TM' ERROR IF STRING VARIABLE
DC78  3540                      PULS U             ;POINT U TO FN NAME DESCRIPTOR 
DC7A  C632                      LDB  #2*25         ;'UNDEFINED FUNCTION CALL' ERROR
DC7C  AE42                      LDX  $02,U         ;POINT X TO ARGUMENT VARIABLE DESCRIPTOR 
DC7E  27A9                      BEQ  L886E         ;BRANCH TO ERROR HANDLER 
DC80  109E83                    LDY  CHARAD        ;SAVE CURRENT INPUT POINTER IN Y 
DC83  EEC4                      LDU  ,U            ;* POINT U TO START OF FN FORMULA AND 
DC85  DF83                      STU  CHARAD        ;* SAVE IT IN INPUT POINTER 
DC87  A604                      LDA  $04,X         ;= GET FP VALUE OF 
DC89  3402                      PSHS A             ;= ARGUMENT VARIABLE, CURRENT INPUT 
DC8B  EC84                      LDD  ,X            ;= POINTER, AND ADDRESS OF START 
DC8D  EE02                      LDU  $02,X         ;= OF FN FORMULA AND SAVE 
DC8F  3476                      PSHS U,Y,X,B,A     ;= THEM ON THE STACK 
DC91  BDD386                    JSR  LBC35         ;PACK FPA0 AND SAVE IT IN (X) 
DC94  BDC8D2          L88D9     JSR  LB141         ;EVALUATE FN EXPRESSION 
DC97  3576                      PULS A,B,X,Y,U     ;RESTORE REGISTERS 
DC99  ED84                      STD  ,X            ;* GET THE FP 
DC9B  EF02                      STU  $02,X         ;* VALUE OF THE ARGUMENT 
DC9D  3502                      PULS A             ;* VARIABLE OFF OF THE 
DC9F  A704                      STA  $04,X         ;* STACK AND RE-SAVE IT 
DCA1  9D82                      JSR  GETCCH        ;GET FINAL CHARACTER OF THE FN FORMULA 
DCA3  1026ED61                  LBNE LB277         ;'SYNTAX' ERROR IF NOT END OF LINE
DCA7  109F83                    STY  CHARAD        ;RESTORE INPUT POINTER 
DCAA  39              L88EF     RTS                  
                                                     
                                                     
                                                     
                      * DEF USR                      
DCAB  9D7C            L890F     JSR  GETNCH        ;SKIP PAST SECOND BYTE OF DEF USR TOKEN 
DCAD  8D09                      BSR  L891C         ;GET FN NUMBER 
DCAF  3410                      PSHS X             ;SAVE FN EXEC ADDRESS STORAGE LOC 
DCB1  8D2D                      BSR  L8944         ;CALCULATE EXEC ADDRESS 
DCB3  3540                      PULS U             ;GET FN EXEC ADDRESS STORAGE LOC 
DCB5  AFC4                      STX  ,U            ;SAVE EXEC ADDRESS 
DCB7  39                        RTS                  
DCB8  5F              L891C     CLRB               ;DEFAULT TO USR0 IF NO ARGUMENT 
DCB9  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DCBB  2406                      BCC  L8927         ;BRANCH IF NOT NUMERIC 
DCBD  8030                      SUBA #'0'          ;MASK OFF ASCII 
DCBF  1F89                      TFR  A,B           ;SAVE USR NUMBER IN ACCB 
DCC1  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DCC3  9E8D            L8927     LDX  USRADR        ;GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS 
DCC5  58                        ASLB               ;X2 - 2 BYTES/USR ADDRESS 
DCC6  3A                        ABX                ;ADD OFFSET TO START ADDRESS OF STORAGE LOCs 
DCC7  39                        RTS                  
                      * PROCESS A USR CALL                      
DCC8  8DEE            L892C     BSR  L891C         ;GET STORAGE LOC OF EXEC ADDRESS FOR USR N 
DCCA  AE84                      LDX  ,X            ;* GET EXEC ADDRESS AND 
DCCC  3410                      PSHS X             ;* PUSH IT ONTO STACK 
DCCE  BDC9F3                    JSR  LB262         ;SYNTAX CHECK FOR '(' & EVALUATE EXPR
DCD1  8E004F                    LDX  #FP0EXP       ;POINT X TO FPA0 
DCD4  9606                      LDA  VALTYP        ;GET VARIABLE TYPE 
DCD6  2707                      BEQ  L8943         ;BRANCH IF NUMERIC, STRING IF <> 0 
DCD8  BDCDE3                    JSR  LB657         ;GET LENGTH & ADDRESS OF STRING VARIABLE 
DCDB  9E52                      LDX  FPA0+2        ;GET POINTER TO STRING DESCRIPTOR 
DCDD  9606                      LDA  VALTYP        ;GET VARIABLE TYPE 
DCDF  39              L8943     RTS                ;JUMP TO USR ROUTINE (PSHS X ABOVE) 
DCE0  C6AE            L8944     LDB  #TOK_EQUALS   ;TOKEN FOR '='
DCE2  BDCA00                    JSR  LB26F         ;DO A SYNTAX CHECK FOR = 
DCE5  7ECEC9                    JMP  LB73D         ;EVALUATE EXPRESSION, RETURN VALUE IN X 
                                                     
                                                     
                                                     
                      * DEL                          
DCE8  1027EEEA        DEL       LBEQ LB44A         ;FC' ERROR IF NO ARGUMENT
DCEC  BDC71C                    JSR  LAF67         ;CONVERT A DECIMAL BASiC NUMBER TO BINARY 
DCEF  BDC4A7                    JSR  LAD01         ;FIND RAM ADDRESS OF START OF A BASIC LINE 
DCF2  9F93                      STX  VD3           ;SAVE RAM ADDRESS OF STARTING LINE NUMBER 
DCF4  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DCF6  2710                      BEQ  L8990         ;BRANCH IF END OF LINE 
DCF8  81A7                      CMPA #TOK_MINUS    ;TOKEN FOR '-'
DCFA  263B                      BNE  L89BF         ;TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
DCFC  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DCFE  2704                      BEQ  L898C         ;IF END OF LINE, USE DEFAULT ENDING LINE NUMBER 
DD00  8D24                      BSR  L89AE         ;* CONVERT ENDING LINE NUMBER TO BINARY 
DD02  2004                      BRA  L8990         ;* AND SAVE IT IN BINVAL 
DD04  86FF            L898C     LDA  #$FF          ;= USE $FFXX AS DEFAULT ENDING 
DD06  972B                      STA  BINVAL        ;= LINE NUMBER - SAVE IT IN BINVAL 
DD08  DE93            L8990     LDU  VD3           ;POINT U TO STARTING LINE NUMBER ADDRESS 
DD0A  8C              L8992     FCB  SKP2          ;SKIP TWO BYTES 
DD0B  EEC4            L8993     LDU  ,U            ;POINT U TO START OF NEXT LINE 
DD0D  ECC4                      LDD  ,U            ;CHECK FOR END OF PROGRAM 
DD0F  2706                      BEQ  L899F         ;BRANCH IF END OF PROGRAM 
DD11  EC42                      LDD  $02,U         ;LOAD ACCD WITH THIS LINE'S NUMBER
DD13  932B                      SUBD BINVAL        ;SUBTRACT ENDING LINE NUMBER ADDRESS 
DD15  23F4                      BLS  L8993         ;BRANCH IF = < ENDING LINE NUMBER 
DD17  9E93            L899F     LDX  VD3           ;GET STARTING LINE NUMBER 
DD19  8D15                      BSR  L89B8         ;MOVE (U) TO (X) UNTIL END OF PROGRAM 
DD1B  BDC4C7                    JSR  LAD21         ;RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
DD1E  9E93                      LDX  VD3           ;GET STARTING LINE NUMBER ADDRESS 
DD20  BDC497                    JSR  LACF1         ;RECOMPUTE START OF NEXT LINE ADDRESSES 
DD23  7EC427                    JMP  LAC73         ;JUMP TO BASIC'S MAIN COMMAND LOOP
DD26  BDC71C          L89AE     JSR  LAF67         ;GO GET LINE NUMBER CONVERTED TO BINARY 
DD29  7EC1BA                    JMP  LA5C7         ;MAKE SURE THERE'S NO MORE ON THIS LINE
DD2C  A6C0            L89B4     LDA  ,U+           ;GET A BYTE FROM (U) 
DD2E  A780                      STA  ,X+           ;MOVE THE BYTE TO (X) 
DD30  11931B          L89B8     CMPU VARTAB        ;COMPARE TO END OF BASIC 
DD33  26F7                      BNE  L89B4         ;BRANCH IF NOT AT END 
DD35  9F1B                      STX  VARTAB        ;SAVE (X) AS NEW END OF BASIC 
DD37  39              L89BF     RTS                  
                                                     
                                                     
DD38  BDDC21          L89C0     JSR  L8866         ;'BS' ERROR IF IN DIRECT MODE
DD3B  9D7C                      JSR  GETNCH        ;GET A CHAR FROM BASIC 
DD3D  8122            L89D2     CMPA #'"'          ;CHECK FOR PROMPT STRING 
DD3F  260B                      BNE  L89E1         ;BRANCH IF NO PROMPT STRING 
DD41  BDC9D5                    JSR  LB244         ;STRIP OFF PROMPT STRING & PUT IT ON STRING STACK 
DD44  C63B                      LDB  #';'          ;* 
DD46  BDCA00                    JSR  LB26F         ;* DO A SYNTAX CHECK FOR; 
DD49  BDD0F0                    JSR  LB99F         ;REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT 
DD4C  327E            L89E1     LEAS -2,S        ;RESERVE TWO STORAGE SLOTS ON STACK 
DD4E  BDC7D1                    JSR  LB035         ;INPUT A LINE FROM CURRENT INPUT DEVICE 
DD51  3262                      LEAS 2,S         ;CLEAN UP THE STACK 
DD53  BDCAE3                    JSR  LB357         ;SEARCH FOR A VARIABLE 
DD56  9F3B                      STX  VARDES        ;SAVE POINTER TO VARIABLE DESCRIPTOR 
DD58  BDC8D7                    JSR  LB146         ;'TM' ERROR IF VARIABLE TYPE = NUMERIC
DD5B  8E00F3                    LDX  #LINBUF       ;POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED 
DD5E  4F                        CLRA               ;TERMINATOR CHARACTER 0 (END OF LINE) 
DD5F  BDCCA8                    JSR  LB51A         ;PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE 
DD62  7EC759                    JMP  LAFA4         ;REMOVE DESCRIPTOR FROM STRING STACK 
DD65  BDC71C          L89FC     JSR  LAF67         ;STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE 
DD68  9E2B                      LDX  BINVAL        ;GET BINARY VALUE 
DD6A  39                        RTS                  
DD6B  9E91            L8A02     LDX  VD1           ;GET CURRENT OLD NUMBER BEING RENUMBERED 
DD6D  9F2B            L8A04     STX  BINVAL        ;SAVE THE LINE NUMBER BEING SEARCHED FOR 
DD6F  7EC4A7                    JMP  LAD01         ;GO FIND THE LINE NUMBER IN BASIC PROGRAM 
                                                     
                      * RENUM                        
DD72  BDC4CC          RENUM     JSR  LAD26         ;ERASE VARIABLES 
DD75  CC000A                    LDD  #10           ;DEFAULT LINE NUMBER INTERVAL 
DD78  DD95                      STD  VD5           ;SAVE DEFAULT RENUMBER START LINE NUMBER 
DD7A  DD8F                      STD  VCF           ;SAVE DEFAULT INTERVAL 
DD7C  5F                        CLRB               ;NOW ACCD = 0 
DD7D  DD91                      STD  VD1           ;DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING 
DD7F  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DD81  2406                      BCC  L8A20         ;BRANCH IF NOT NUMERIC 
DD83  8DE0                      BSR  L89FC         ;CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY 
DD85  9F95                      STX  VD5           ;SAVE LINE NUMBER WHERE RENUMBERING STARTS 
DD87  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DD89  271B            L8A20     BEQ  L8A3D         ;BRANCH IF END OF LINE 
DD8B  BDC9FE                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DD8E  2406                      BCC  L8A2D         ;BRANCH IF NEXT CHARACTER NOT NUMERIC 
DD90  8DD3                      BSR  L89FC         ;CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY 
DD92  9F91                      STX  VD1           ;SAVE NEW RENUMBER LINE 
DD94  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DD96  270E            L8A2D     BEQ  L8A3D         ;BRANCH IF END OF LINE 
DD98  BDC9FE                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
DD9B  2406                      BCC  L8A3A         ;BRANCH IF NEXT CHARACTER NOT NUMERIC 
DD9D  8DC6                      BSR  L89FC         ;CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY 
DD9F  9F8F                      STX  VCF           ;SAVE NEW INTERVAL 
DDA1  2749                      BEQ  L8A83         ;'FC' ERROR
DDA3  BDC1BA          L8A3A     JSR  LA5C7         ;CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
DDA6  8DC3            L8A3D     BSR  L8A02         ;GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED 
DDA8  9F93                      STX  VD3           ;SAVE ADDRESS 
DDAA  9E95                      LDX  VD5           ;GET NEXT RENUMBERED LINE NUMBER TO USE 
DDAC  8DBF                      BSR  L8A04         ;FIND THE LINE NUMBER IN THE BASIC PROGRAM 
DDAE  9C93                      CMPX VD3           ;COMPARE TO ADDRESS OF OLD LINE NUMBER 
DDB0  253A                      BLO  L8A83         ;'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
DDB2  8D1C                      BSR  L8A67         ;MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE 
DDB4  BDDE46                    JSR  L8ADD         ;CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
DDB7  BDC495                    JSR  LACEF         ;RECALCULATE NEXT LINE RAM ADDRESSES 
DDBA  8DAF                      BSR  L8A02         ;GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED 
DDBC  9F93                      STX  VD3           ;SAVE IT 
DDBE  8D3A                      BSR  L8A91         ;MAKE SURE LINE NUMBERS EXIST 
DDC0  8D0F                      BSR  L8A68         ;INSERT NEW LINE NUMBERS IN LINE HEADERS 
DDC2  8D36                      BSR  L8A91         ;INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS 
DDC4  BDDEE1                    JSR  L8B7B         ;CONVERT PACKED BINARY LINE NUMBERS TO ASCII 
DDC7  BDC4CC                    JSR  LAD26         ;ERASE VARIABLES 
DDCA  BDC495                    JSR  LACEF         ;RECALCULATE NEXT LINE RAM ADDRESS 
DDCD  7EC427                    JMP  LAC73         ;GO BACK TO BASIC'S MAIN LOOP
DDD0  86              L8A67     FCB  SKP1LD        ;SKIP ONE BYTE - LDA #$4F 
DDD1  4F              L8A68     CLRA               ;NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS 
DDD2  9798                      STA  VD8           ;SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS 
DDD4  9E93                      LDX  VD3           ;GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED 
DDD6  DC95                      LDD  VD5           ;GET THE CURRENT RENUMBERED LINE NUMBER 
DDD8  8D15                      BSR  L8A86         ;RETURN IF END OF PROGRAM 
DDDA  0D98            L8A71     TST  VD8           ;CHECK NEW LINE NUMBER FLAG 
DDDC  2602                      BNE  L8A77         ;BRANCH IF NOT INSERTING NEW LINE NUMBERS 
DDDE  ED02                      STD  $02,X         ;STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM 
DDE0  AE84            L8A77     LDX  ,X            ;POINT X TO THE NEXT LINE IN BASIC 
DDE2  8D0B                      BSR  L8A86         ;RETURN IF END OF PROGRAM 
DDE4  D38F                      ADDD VCF           ;ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER 
DDE6  2504                      BLO  L8A83         ;'FC' ERROR IF LINE NUMBER > $FFFF
DDE8  81FA                      CMPA #MAXLIN       ;LARGEST LINE NUMBER = $F9FF 
DDEA  25EE                      BLO  L8A71         ;BRANCH IF LEGAL LINE NUMBER 
DDEC  7ECBD6          L8A83     JMP  LB44A         ;'FC' ERROR IF LINE NUMBER MS BYTE > $F9
                      * TEST THE TWO BYTES POINTED TO BY (X).                      
                      * NORMAL RETURN IF <> 0. IF =;0 (END OF                      
                      * PROGRAM) RETURN IS PULLED OFF STACK AND                      
                      * YOU RETURN TO PREVIOUS SUBROUTINE CALL.                      
DDEF  3406            L8A86     PSHS B,A           ;SAVE ACCD 
DDF1  EC84                      LDD  ,X            ;TEST THE 2 BYTES POINTED TO BY X 
DDF3  3506                      PULS A,B           ;RESTORE ACCD 
DDF5  2602                      BNE  L8A90         ;BRANCH IF NOT END OF PROGRAM 
DDF7  3262                      LEAS $02,S         ;PURGE RETURN ADDRESS FROM STACK 
DDF9  39              L8A90     RTS                  
DDFA  9E19            L8A91     LDX  TXTTAB        ;GET START OF BASIC PROGRAM 
DDFC  301F                      LEAX -1,X        ;MOVE POINTER BACK ONE 
DDFE  3001            L8A95     LEAX 1,X         ;MOVE POINTER UP ONE 
DE00  8DED                      BSR  L8A86         ;RETURN IF END OF PROGRAM 
DE02  3003            L8A99     LEAX 3,X         ;SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER 
DE04  3001            L8A9B     LEAX 1,X         ;MOVE POINTER TO NEXT CHARACTER 
DE06  A684                      LDA  ,X            ;CHECK CURRENT CHARACTER 
DE08  27F4                      BEQ  L8A95         ;BRANCH IF END OF LINE 
DE0A  9F0F                      STX  TEMPTR        ;SAVE CURRENT POINTER 
DE0C  4A                        DECA               ;= 
DE0D  270C                      BEQ  L8AB2         ;=BRANCH IF START OF PACKED NUMERIC LINE 
DE0F  4A                        DECA               ;* 
DE10  272A                      BEQ  L8AD3         ;*BRANCH IF LINE NUMBER EXISTS 
DE12  4A                        DECA               ;= 
DE13  26EF                      BNE  L8A9B         ;=MOVE TO NEXT CHARACTER IF > 3 
DE15  8603            L8AAC     LDA  #$03          ;* SET 1ST BYTE = 3 TO INDICATE LINE 
DE17  A780                      STA  ,X+           ;* NUMBER DOESN'T CURRENTLY EXIST
DE19  20E7                      BRA  L8A99         ;GO GET ANOTHER CHARACTER 
DE1B  EC01            L8AB2     LDD  $01,X         ;GET MS BYTE OF LINE NUMBER 
DE1D  6A02                      DEC  $02,X         ;DECREMENT ZERO CHECK BYTE 
DE1F  2701                      BEQ  L8AB9         ;BRANCH IF MS BYTE <> 0 
DE21  4F                        CLRA               ;CLEAR MS BYTE 
DE22  E603            L8AB9     LDB  $03,X         ;GET LS BYTE OF LINE NUMBER 
DE24  6A04                      DEC  $04,X         ;DECREMENT ZERO CHECK FLAG 
DE26  2701                      BEQ  L8AC0         ;BRANCH IF IS BYTE <> 0 
DE28  5F                        CLRB               ;CLEAR LS BYTE 
DE29  ED01            L8AC0     STD  $01,X         ;SAVE BINARY LINE NUMBER 
DE2B  DD2B                      STD  BINVAL        ;SAVE TRIAL LINE NUMBER 
DE2D  BDC4A7                    JSR  LAD01         ;FIND RAM ADDRESS OF A BASIC LINE NUMBER 
DE30  9E0F            L8AC7     LDX  TEMPTR        ;GET BACK POINTER TO START OF PACKED LINE NUMBER 
DE32  25E1                      BLO  L8AAC         ;BRANCH IF NO LINE NUMBER MATCH FOUND 
DE34  DC47                      LDD  V47           ;GET START ADDRESS OF LINE NUMBER 
DE36  6C80                      INC  ,X+           ;* SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR 
                      *              * EXISTENCE OF;LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS  
                                                     
DE38  ED84                      STD  ,X            ;SAVE RAM ADDRESS OF CORRECT LINE NUMBER 
DE3A  20C6                      BRA  L8A99         ;GO GET ANOTHER CHARACTER 
DE3C  6F84            L8AD3     CLR  ,X            ;CLEAR CARRY FLAG AND 1ST BYTE 
DE3E  AE01                      LDX  $01,X         ;POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER 
DE40  AE02                      LDX  $02,X         ;PUT CORRECT LINE NUMBER INTO (X) 
DE42  9F47                      STX  V47           ;SAVE IT TEMPORARILY 
DE44  20EA                      BRA  L8AC7         ;GO INSERT IT INTO BASIC LINE 
DE46  9E19            L8ADD     LDX  TXTTAB        ;GET BEGINNING OF BASIC PROGRAM 
DE48  2004                      BRA  L8AE5           
DE4A  9E83            L8AE1     LDX  CHARAD        ;*GET CURRENT INPUT POINTER 
DE4C  3001                      LEAX 1,X         ;*AND BUMP IT ONE 
DE4E  8D9F            L8AE5     BSR  L8A86         ;RETURN IF END OF PROGRAM 
DE50  3002                      LEAX 2,X         ;SKIP PAST NEXT LINE ADDRESS 
DE52  3001            L8AE9     LEAX 1,X         ;ADVANCE POINTER BY ONE 
DE54  9F83            L8AEB     STX  CHARAD        ;SAVE NEW BASIC INPUT POINTER 
DE56  9D7C            L8AED     JSR  GETNCH        ;GET NEXT CHARACTER FROM BASIC 
DE58  4D              L8AEF     TSTA               ;CHECK THE CHARACTER 
DE59  27EF                      BEQ  L8AE1         ;BRANCH IF END OF LINE 
DE5B  2AF9                      BPL  L8AED         ;BRANCH IF NOT A TOKEN 
DE5D  9E83                      LDX  CHARAD        ;GET CURRENT INPUT POINTER 
DE5F  81FF                      CMPA #$FF          ;IS THIS A SECONDARY TOKEN? 
DE61  27EF                      BEQ  L8AE9         ;YES - IGNORE IT 
DE63  81A2                      CMPA #TOK_THEN     ;TOKEN FOR THEN? 
DE65  2712                      BEQ  L8B13         ;YES 
DE67  8184                      CMPA #TOK_ELSE     ;TOKEN FOR ELSE? 
DE69  270E                      BEQ  L8B13         ;YES 
DE6B  8181                      CMPA #TOK_GO       ;TOKEN FOR GO? 
DE6D  26E7                      BNE  L8AED         ;NO 
DE6F  9D7C                      JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DE71  81A0                      CMPA #TOK_TO       ;TOKEN FOR TO? 
DE73  2704                      BEQ  L8B13         ;YES 
DE75  81A1                      CMPA #TOK_SUB      ;TOKEN FOR SUB? 
DE77  26DB                      BNE  L8AEB         ;NO 
DE79  9D7C            L8B13     JSR  GETNCH        ;GET A CHARACTER FROM BASIC 
DE7B  2504                      BLO  L8B1B         ;BRANCH IF NUMERIC 
DE7D  9D82            L8B17     JSR  GETCCH        ;GET CURRENT BASIC INPUT CHARRACTER 
DE7F  20D7                      BRA  L8AEF         ;KEEP CHECKING THE LINE 
DE81  9E83            L8B1B     LDX  CHARAD        ;GET CURRENT INPUT ADDRESS 
DE83  3410                      PSHS X             ;SAVE IT ON THE STACK 
DE85  BDC71C                    JSR  LAF67         ;CONVERT DECIMAL BASIC NUMBER TO BINARY 
DE88  9E83                      LDX  CHARAD        ;GET CURRENT INPUT POINTER 
DE8A  A682            L8B24     LDA  ,-X           ;GET PREVIOUS INPUT CHARACTER 
DE8C  BDE1F1                    JSR  L90AA         ;CLEAR CARRY IF NUMERIC INPUT VALUE 
DE8F  25F9                      BLO  L8B24         ;BRANCH IF NON-NUMERIC 
DE91  3001                      LEAX 1,X         ;MOVE POINTER UP ONE 
DE93  1F10                      TFR  X,D           ;NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER 
DE95  E061                      SUBB 1,S         ;SUBTRACT PRE-NUMERIC POINTER LS BYTE 
DE97  C005                      SUBB #$05          ;MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE 
                      *                              
DE99  2720                      BEQ  L8B55         ;BRANCH IF EXACTLY 5 
DE9B  250A                      BLO  L8B41         ;BRANCH IF < 5 
DE9D  3384                      LEAU ,X            ;TRANSFER X TO U 
DE9F  50                        NEGB               ;NEGATE B 
DEA0  3085                      LEAX B,X           ;MOVE X BACK B BYTES 
DEA2  BDDD30                    JSR  L89B8         ;*MOVE BYTES FROM (U) TO (X) UNTIL 
                      *         *U   = END OF BASIC; (I) = NEW END OF BASIC  
DEA5  2014                      BRA  L8B55           
                      * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER                      
DEA7  9F47            L8B41     STX  V47           ;SAVE END OF NUMERIC VALUE 
DEA9  9E1B                      LDX  VARTAB        ;GET END OF BASIC PROGRAM 
DEAB  9F43                      STX  V43           ;SAVE IT 
DEAD  50                        NEGB               ;NEGATE B 
DEAE  3085                      LEAX B,X           ;ADD IT TO END OF NUMERIC POiNTER 
DEB0  9F41                      STX  V41           ;SAVE POINTER 
DEB2  9F1B                      STX  VARTAB        ;STORE END OF BASIC PROGRAM 
DEB4  BDC3E0                    JSR  LAC1E         ;ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM 
DEB7  9E45                      LDX  V45           ;* GET AND SAVE THE 
DEB9  9F83                      STX  CHARAD        ;* NEW CURRENT INPUT POINTER 
DEBB  3510            L8B55     PULS X             ;RESTORE POINTER TO START OF NUMERIC VALUE 
DEBD  8601                      LDA  #$01          ;NEW LINE NUMBER FLAG 
DEBF  A784                      STA  ,X            ;* SAVE NEW LINE FLAG 
DEC1  A702                      STA  $02,X         ;* 
DEC3  A704                      STA  $04,X         ;* 
DEC5  D62B                      LDB  BINVAL        ;GET MS BYTE OF BINARY LINE NUMBER 
DEC7  2604                      BNE  L8B67         ;BRANCH IF IT IS NOT ZERO 
DEC9  C601                      LDB  #$01          ;SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL 
                      *              THINK IT IS THE END OF A LINE  
DECB  6C02                      INC  $02,X         ;IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO 
DECD  E701            L8B67     STB  $01,X         ;SAVE MS BYTE OF BINARY LINE NUMBER 
DECF  D62C                      LDB  BINVAL+1      ;GET IS BYTE OF BINARY LINE NUMBER 
DED1  2604                      BNE  L8B71         ;BRANCH IF NOT A ZERO BYTE 
DED3  C601                      LDB  #$01          ;SAVE A 1 IF BYTE IS A 0 
DED5  6C04                      INC  $04,X         ;IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0 
DED7  E703            L8B71     STB  $03,X         ;SAVE LS BYTE OF BINARY LINE NUMBER 
DED9  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DEDB  812C                      CMPA #','          ;IS IT A COMMA? 
DEDD  279A                      BEQ  L8B13         ;YES - PROCESS ANOTHER NUMERIC VALUE 
DEDF  209C                      BRA  L8B17         ;NO - GO GET AND PROCESS AN INPUT CHARACTER 
DEE1  9E19            L8B7B     LDX  TXTTAB        ;POINT X TO START OF BASIC PROGRAM 
DEE3  301F                      LEAX -1,X        ;MOVE POINTER BACK ONE 
DEE5  3001            L8B7F     LEAX 1,X         ;MOVE POINTER UP ONE 
DEE7  EC02                      LDD  2,X         ;GET ADDRESS OF NEXT LINE 
DEE9  DD68                      STD  CURLIN        ;SAVE IT IN CURLIN 
DEEB  BDDDEF                    JSR  L8A86         ;RETURN IF END OF PROGRAM 
DEEE  3003                      LEAX 3,X         ;SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER 
DEF0  3001            L8B8A     LEAX 1,X         ;MOVE POINTER UP ONE 
DEF2  A684            L8B8C     LDA  ,X            ;GET CURRENT CHARACTER 
DEF4  27EF                      BEQ  L8B7F         ;BRANCH IF END OF LINE 
DEF6  4A                        DECA               ;INPUT CHARACTER = 1? - VALID LINE NUMBER 
DEF7  271B                      BEQ  L8BAE         ;YES 
DEF9  8002                      SUBA #$02          ;INPUT CHARACTER 3? - UL LINE NUMBER 
DEFB  26F3                      BNE  L8B8A         ;NO 
DEFD  3410                      PSHS X             ;SAVE CURRENT POSITION OF INPUT POINTER 
DEFF  8EDF3E                    LDX  #L8BD9-1      ;POINT X TO 'UL' MESSAGE
DF02  BDD0ED                    JSR  LB99C         ;PRINT STRING TO THE SCREEN 
DF05  AEE4                      LDX  ,S            ;GET INPUT POINTER 
DF07  EC01                      LDD  $01,X         ;GET THE UNDEFINED LINE NUMBER 
DF09  BDD51D                    JSR  LBDCC         ;CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT 
DF0C  BDD516                    JSR  LBDC5         ;PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
DF0F  BDD0AD                    JSR  LB958         ;SEND A CR TO CONSOLE OUT 
DF12  3510                      PULS X             ;GET INPUT POINTER BACK 
DF14  3410            L8BAE     PSHS X             ;SAVE CURRENT POSITION OF INPUT POINTER 
DF16  EC01                      LDD  $01,X         ;LOAD ACCD WITH BINARY VALUE OF LINE NUMBER 
DF18  DD52                      STD  FPA0+2        ;SAVE IN BOTTOM 2 BYTES OF FPA0 
DF1A  BDDBC9                    JSR  L880E         ;ADJUST REST OF FPA0 AS AN INTEGER 
DF1D  BDD52A                    JSR  LBDD9         ;CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER 
DF20  3540                      PULS U             ;LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER 
DF22  C605                      LDB  #$05          ;EACH EXPANDED LINE NUMBER USES 5 BYTES 
DF24  3001            L8BBE     LEAX $01,X         ;MOVE POINTER FORWARD ONE 
DF26  A684                      LDA  ,X            ;GET AN ASCII BYTE 
DF28  2705                      BEQ  L8BC9         ;BRANCH IF END OF NUMBER 
DF2A  5A                        DECB               ;DECREMENT BYTE COUNTER 
DF2B  A7C0                      STA  ,U+           ;STORE ASCII NUMBER IN BASIC LINE 
DF2D  20F5                      BRA  L8BBE         ;CHECK FOR ANOTHER DIGIT 
DF2F  30C4            L8BC9     LEAX ,U            ;TRANSFER NEW LINE POINTER TO (X) 
DF31  5D                        TSTB               ;DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?  
DF32  27BE                      BEQ  L8B8C         ;YES - GO GET ANOTHER INPUT CHARACTER 
DF34  31C4                      LEAY ,U            ;SAVE NEW LINE POINTER IN Y 
DF36  33C5                      LEAU B,U           ;POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK 
DF38  BDDD30                    JSR  L89B8         ;MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM 
DF3B  30A4                      LEAX ,Y            ;LOAD (X) WITH NEW LINE POINTER 
DF3D  20B3                      BRA  L8B8C         ;GO GET ANOTHER INPUT CHARACTER 
                                                     
DF3F  554C20          L8BD9     FCC  "UL "         ;UNKNOWN LINE NUMBER MESSAGE 
DF42  00                        FCB  0               
                                                     
                                                     
DF43  BDCECC          HEXDOL    JSR  LB740         ;CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER 
DF46  8E01F0                    LDX  #STRBUF+2     ;POINT TO TEMPORARY BUFFER 
DF49  C604                      LDB  #$04          ;CONVERT 4 NIBBLES 
DF4B  3404            L8BE5     PSHS B             ;SAVE NIBBLE COUNTER 
DF4D  5F                        CLRB               ;CLEAR CARRY FLAG 
DF4E  8604                      LDA  #$04          ;4 SHIFTS 
DF50  0853            L8BEA     ASL  FPA0+3        ;* SHIFT BOTTOM TWO BYTES OF 
DF52  0952                      ROL  FPA0+2        ;* FPA0 LEFT ONE BIT (X2) 
DF54  59                        ROLB               ;IF OVERFLOW, ACCB <> 0 
DF55  4A                        DECA               ;* DECREMENT SHIFT COUNTER AND 
DF56  26F8                      BNE  L8BEA         ;* BRANCH IF NOT DONE 
DF58  5D                        TSTB               ;CHECK FOR OVERFLOW  
DF59  260A                      BNE  L8BFF         ;BRANCH IF OVERFLOW 
DF5B  A6E4                      LDA  ,S            ;* GET NIBBLE COUNTER, 
DF5D  4A                        DECA               ;* DECREMENT IT AND 
DF5E  2705                      BEQ  L8BFF         ;* BRANCH IF DONE 
DF60  8C01F0                    CMPX #STRBUF+2     ;DO NOT DO A CONVERSION UNTIL A NON-ZERO 
DF63  270C                      BEQ  L8C0B         ;BYTE IS FOUND - LEADING ZERO SUPPRESSION 
DF65  CB30            L8BFF     ADDB #'0'          ;ADD IN ASCII ZERO 
DF67  C139                      CMPB #'9'          ;COMPARE TO ASCII 9 
DF69  2302                      BLS  L8C07         ;BRANCH IF < 9 
DF6B  CB07                      ADDB #7            ;ADD ASCII OFFSET IF HEX LETTER 
DF6D  E780            L8C07     STB  ,X+           ;STORE HEX VALUE AND ADVANCE POINTER 
DF6F  6F84                      CLR  ,X            ;CLEAR NEXT BYTE - END OF STRING FLAG 
DF71  3504            L8C0B     PULS B             ;* GET NIBBLE COUNTER, 
DF73  5A                        DECB               ;* DECREMENT IT AND 
DF74  26D5                      BNE  L8BE5         ;* BRANCH IF NOT DONE 
DF76  3262                      LEAS $02,S         ;PURGE RETURN ADDRESS OFF OF STACK 
DF78  8E01EF                    LDX  #STRBUF+1     ;RESET POINTER 
DF7B  7ECCA4                    JMP  LB518         ;SAVE STRING ON STRING STACK 
                      * PROCESS EXCLAMATION POINT                      
DF7E  8601            L8E37     LDA  #$01          ;* SET SPACES 
DF80  9799                      STA  VD9           ;* COUNTER = 1 
                      * PROCESS STRING ITEM - LIST                      
DF82  5A              L8E3B     DECB               ;DECREMENT FORMAT STRING LENGTH COUNTER 
DF83  BDE11F                    JSR  L8FD8         ;SEND A '+' TO CONSOLE OUT IF VDA <>0 
DF86  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
DF88  10270093                  LBEQ L8ED8         ;EXIT PRINT USING IF END OF LINE 
DF8C  D793                      STB  VD3           ;SAVE REMAINDER FORMAT STRING LENGTH 
DF8E  BDC8E7                    JSR  LB156         ;EVALUATE EXPRESSION 
DF91  BDC8D7                    JSR  LB146         ;'TM' ERROR IF NUMERIC VARIABLE
DF94  9E52                      LDX  FPA0+2        ;* GET ITEM - LIST DESCRIPTOR ADDRESS 
DF96  9F4D                      STX  V4D           ;* AND SAVE IT IN V4D 
DF98  D699                      LDB  VD9           ;GET SPACES COUNTER 
DF9A  BDCE39                    JSR  LB6AD         ;PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK 
DF9D  BDD0F0                    JSR  LB99F         ;PRINT THE FORMATTED STRING TO CONSOLE OUT 
                      * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH                      
DFA0  9E52                      LDX  FPA0+2        ;POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS 
DFA2  D699                      LDB  VD9           ;GET SPACES COUNTER 
DFA4  E084                      SUBB ,X            ;SUBTRACT LENGTH OF FORMATTED STRING 
DFA6  5A              L8E5F     DECB               ;DECREMENT DIFFERENCE 
DFA7  102B014F                  LBMI L8FB3         ;GO INTERPRET ANOTHER ITEM - LIST 
DFAB  BDD0FD                    JSR  LB9AC         ;PAD FORMAT STRING WITH A SPACE 
DFAE  20F6                      BRA  L8E5F         ;KEEP PADDING 
                      * PERCENT SIGN - PROCESS A %SPACES% COMMAND                      
DFB0  D793            L8E69     STB  VD3           ;* SAVE THE CURRENT FORMAT STRING 
DFB2  9F0F                      STX  TEMPTR        ;* COUNTER AND POINTER 
DFB4  8602                      LDA  #$02          ;INITIAL SPACES COUNTER = 2 
DFB6  9799                      STA  VD9           ;SAVE IN SPACES COUNTER 
DFB8  A684            L8E71     LDA  ,X            ;GET A CHARACTER FROM FORMAT STRING 
DFBA  8125                      CMPA #'%'          ;COMPARE TO TERMINATOR CHARACTER 
DFBC  27C4                      BEQ  L8E3B         ;BRANCH IF END OF SPACES COMMAND 
DFBE  8120                      CMPA #' '          ;BLANK 
DFC0  2607                      BNE  L8E82         ;BRANCH IF ILLEGAL CHARACTER 
DFC2  0C99                      INC  VD9           ;ADD ONE TO SPACES COUNTER 
DFC4  3001                      LEAX $01,X         ;MOVE FORMAT POINTER UP ONE 
DFC6  5A                        DECB               ;DECREMENT LENGTH COUNTER 
DFC7  26EF                      BNE  L8E71         ;BRANCH IF NOT END OF FORMAT STRING 
DFC9  9E0F            L8E82     LDX  TEMPTR        ;* RESTORE CURRENT FORMAT STRING COUNTER 
DFCB  D693                      LDB  VD3           ;* AND POINTER TO POSITION BEFORE SPACES COMMAND 
DFCD  8625                      LDA  #'%'          ;SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
                      * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING                      
DFCF  BDE11F          L8E88     JSR  L8FD8         ;SEND A '+' TO CONSOLE OUT IF VDA <> 0
DFD2  BDC017                    JSR  PUTCHR        ;SEND CHARACTER TO CONSOLE OUT 
DFD5  2029                      BRA  L8EB9         ;GET NEXT CHARACTER IN FORMAT STRING 
                                                     
                      * PRINT RAM HOOK                      
DFD7  81B1            XVEC9     CMPA #TOK_USING    ;USING TOKEN 
DFD9  2701                      BEQ  L8E95         ;BRANCH IF PRINT USING 
DFDB  39                        RTS                  
                                                     
                      * PRINT USING                      
                      * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE                      
                      * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE                      
                      * BIT 3 = PRE SIGN FORCE; BIT;2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE                      
DFDC  3262            L8E95     LEAS $02,S         ;PURGE RETURN ADDRESS OFF THE STACK 
DFDE  BDC8E9                    JSR  LB158         ;EVALUATE FORMAT STRING 
DFE1  BDC8D7                    JSR  LB146         ;'TM' ERROR IF VARIABLE TYPE = NUMERIC
DFE4  C63B                      LDB  #';'          ;CHECK FOR ITEM LIST SEPARATOR 
DFE6  BDCA00                    JSR  LB26F         ;SYNTAX CHECK FOR ; 
DFE9  9E52                      LDX  FPA0+2        ;* GET FORMAT STRING DESCRIPTOR ADDRESS 
DFEB  9F95                      STX  VD5           ;* AND SAVE IT IN VD5 
DFED  2006                      BRA  L8EAE         ;GO PROCESS FORMAT STRING 
DFEF  9697            L8EA8     LDA  VD7           ;*CHECK NEXT PRINT ITEM FLAG AND 
DFF1  2708                      BEQ  L8EB4         ;*'FC' ERROR IF NO FURTHER PRINT ITEMS
DFF3  9E95                      LDX  VD5           ;RESET FORMAT STRING POINTER TO START OF STRING 
DFF5  0F97            L8EAE     CLR  VD7           ;RESET NEXT PRINT ITEM FLAG 
DFF7  E684                      LDB  ,X            ;GET LENGTH OF FORMAT STRING 
DFF9  2603                      BNE  L8EB7         ;INTERPRET FORMAT STRING IF LENGTH > 0 
DFFB  7ECBD6          L8EB4     JMP  LB44A         ;'FC' ERROR IF FORMAT STRING = NULL
DFFE  AE02            L8EB7     LDX  $02,X         ;POINT X TO START OF FORMAT STRING 
                      * INTERPRET THE FORMAT STRING                      
E000  0F9A            L8EB9     CLR  VDA           ;CLEAR THE STATUS BYTE 
E002  0F99            L8EBB     CLR  VD9           ;CLEAR LEFT DIGIT COUNTER 
E004  A680                      LDA  ,X+           ;GET A CHARACTER FROM FORMAT STRING 
E006  8121                      CMPA #'!'          ;EXCLAMATION POINT? 
E008  1027FF72                  LBEQ L8E37         ;YES - STRING TYPE FORMAT 
E00C  8123                      CMPA #'#'          ;NUMBER SIGN? (DIGIT LOCATOR) 
E00E  275B                      BEQ  L8F24         ;YES - NUMERIC TYPE FORMAT 
E010  5A                        DECB               ;DECREMENT FORMAT STRING LENGTH 
E011  2616                      BNE  L8EE2         ;BRANCH IF NOT DONE 
E013  BDE11F                    JSR  L8FD8         ;SEND A '+' TO CONSOLE OUT IF VDA <> 0
E016  BDC017                    JSR  PUTCHR        ;SEND CHARACTER TO CONSOLE OUT 
E019  9D82            L8ED2     JSR  GETCCH        ;GET CURRENT CHARACTER FROM BASIC 
E01B  26D2                      BNE  L8EA8         ;BRANCH IF NOT END OF LINE 
E01D  9697                      LDA  VD7           ;GET NEXT PRINT ITEM FLAG 
E01F  2603            L8ED8     BNE  L8EDD         ;BRANCH IF MORE PRINT ITEMS 
E021  BDD0AD                    JSR  LB958         ;SEND A CARRIAGE RETURN TO CONSOLE OUT 
E024  9E95            L8EDD     LDX  VD5           ;POINT X TO FORMAT STRING DESCRIPTOR 
E026  7ECDE5                    JMP  LB659         ;RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING 
E029  812B            L8EE2     CMPA #'+'          ;CHECK FOR '+' (PRE-SIGN FORCE)
E02B  2609                      BNE  L8EEF         ;NO PLUS 
E02D  BDE11F                    JSR  L8FD8         ;SEND A '+' TO CONSOLE OUT IF VDA <> 0
E030  8608                      LDA  #$08          ;* LOAD THE STATUS BYTE WITH 8; 
E032  979A                      STA  VDA           ;* PRE-SIGN FORCE FLAG 
E034  20CC                      BRA  L8EBB         ;INTERPRET THE REST OF THE FORMAT STRING 
E036  812E            L8EEF     CMPA #'.'          ;DECIMAL POINT? 
E038  274E                      BEQ  L8F41         ;YES 
E03A  8125                      CMPA #'%'          ;PERCENT SIGN? 
E03C  1027FF70                  LBEQ L8E69         ;YES 
E040  A184                      CMPA ,X            ;COMPARE THE PRESENT FORMAT STRING INPUT 
                      *              CHARACTER TO THE NEXT ONE IN THE STRING  
E042  268B            L8EFB     BNE  L8E88         ;NO MATCH - ILLEGAL CHARACTER 
                      * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING                      
E044  8124                      CMPA #'$'          ;DOLLAR SIGN? 
E046  2719                      BEQ  L8F1A         ;YES - MAKE THE DOLLAR SIGN FLOAT 
E048  812A                      CMPA #'*'          ;ASTERISK? 
E04A  26F6                      BNE  L8EFB         ;NO - ILLEGAL CHARACTER 
E04C  969A                      LDA  VDA           ;* GRAB THE STATUS BYTE AND BET BIT 5 
E04E  8A20                      ORA  #$20          ;* TO INDICATE THAT THE OUTPUT WILL 
E050  979A                      STA  VDA           ;* BE LEFT PADDED WITH ASTERISKS 
E052  C102                      CMPB #2            ;* CHECK TO SEE IF THE $$ ARE THE LAST TWO 
E054  2511                      BLO  L8F20         ;* CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO 
E056  A601                      LDA  $01,X         ;GET THE NEXT CHARACTER AFTER ** 
E058  8124                      CMPA #'$'          ;CHECK FOR **$ 
E05A  260B                      BNE  L8F20         ;CHECK FOR MORE CHARACTERS 
E05C  5A                        DECB               ;DECREMENT STRING LENGTH COUNTER 
E05D  3001                      LEAX $01,X         ;MOVE FORMAT STRING POINTER UP ONE 
E05F  0C99                      INC  VD9           ;ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND 
                      *              FLOATING DOLLAR SIGN COMBINATION  
E061  969A            L8F1A     LDA  VDA           ;* GET THE STATUS BYTE AND SET 
E063  8A10                      ORA  #$10          ;* BIT 4 TO INDICATE A 
E065  979A                      STA  VDA           ;* FLOATING DOLLAR SIGN 
E067  3001            L8F20     LEAX $01,X         ;MOVE FORMAT STRING POINTER UP ONE 
E069  0C99                      INC  VD9           ;ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD) 
                      * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING                      
E06B  0F98            L8F24     CLR  VD8           ;CLEAR THE RIGHT DIGIT COUNTER 
E06D  0C99            L8F26     INC  VD9           ;ADD ONE TO LEFT DIGIT COUNTER 
E06F  5A                        DECB               ;DECREMENT FORMAT STRING LENGTH COUNTER 
E070  2749                      BEQ  L8F74         ;BRANCH IF END OF FORMAT STRING 
E072  A680                      LDA  ,X+           ;GET THE NEXT FORMAT CHARACTER 
E074  812E                      CMPA #'.'          ;DECIMAL POINT? 
E076  271E                      BEQ  L8F4F         ;YES 
E078  8123                      CMPA #'#'          ;NUMBER SIGN? 
E07A  27F1                      BEQ  L8F26         ;YES 
E07C  812C                      CMPA #','          ;COMMA? 
E07E  2621                      BNE  L8F5A         ;NO 
E080  969A                      LDA  VDA           ;* GET THE STATUS BYTE 
E082  8A40                      ORA  #$40          ;* AND SET BIT 6 WHICH IS THE 
E084  979A                      STA  VDA           ;* COMMA SEPARATOR FLAG 
E086  20E5                      BRA  L8F26         ;PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT 
                      * PROCESS DECIMAL POINT IF NO;DIGITS TO LEFT OF IT                      
E088  A684            L8F41     LDA  ,X            ;GET NEXT FORMAT CHARACTER 
E08A  8123                      CMPA #'#'          ;IS IT A NUMBER SIGN? 
E08C  1026FF3F                  LBNE L8E88         ;NO 
E090  8601                      LDA  #1            ;* SET THE RIGHT DIGIT COUNTER TO 1 - 
E092  9798                      STA  VD8           ;* ALLOW ONE SPOT FOR DECIMAL POINT 
E094  3001                      LEAX $01,X         ;MOVE FORMAT POINTER UP ONE 
                      * PROCESS DIGITS TO RIGHT OF DECIMAL POINT                      
E096  0C98            L8F4F     INC  VD8           ;ADD ONE TO RIGHT DIGIT COUNTER 
E098  5A                        DECB               ;DECREMENT FORMAT LENGTH COUNTER 
E099  2720                      BEQ  L8F74         ;BRANCH IF END OF FORMAT STRING 
E09B  A680                      LDA  ,X+           ;GET A CHARACTER FROM FORMAT STRING 
E09D  8123                      CMPA #'#'          ;IS IT NUMBER SIGN? 
E09F  27F5                      BEQ  L8F4F         ;YES - KEEP CHECKING 
                      * CHECK FOR EXPONENTIAL FORCE                      
E0A1  815E            L8F5A     CMPA #$5E          ;CHECK FOR UP ARROW 
E0A3  2616                      BNE  L8F74         ;NO UP ARROW 
E0A5  A184                      CMPA ,X            ;IS THE NEXT CHARACTER AN UP ARROW? 
E0A7  2612                      BNE  L8F74         ;NO 
E0A9  A101                      CMPA $01,X         ;AND THE NEXT CHARACTER? 
E0AB  260E                      BNE  L8F74         ;NO 
E0AD  A102                      CMPA $02,X         ;HOW ABOUT THE 4TH CHARACTER? 
E0AF  260A                      BNE  L8F74         ;NO, ALSO 
E0B1  C104                      CMPB #4            ;* CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE 
E0B3  2506                      BLO  L8F74         ;* FORMAT STRING AND BRANCH IF NOT 
E0B5  C004                      SUBB #4            ;* MOVE POINTER UP 4 AND SUBTRACT 
E0B7  3004                      LEAX $04,X         ;* FOUR FROM LENGTH 
E0B9  0C9A                      INC  VDA           ;INCREMENT STATUS BYTE - EXPONENTIAL FORM  
                                                     
                      * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING                      
E0BB  301F            L8F74     LEAX -1,X        ;MOVE POINTER BACK ONE 
E0BD  0C99                      INC  VD9           ;ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE 
E0BF  969A                      LDA  VDA           ;* PRE-SIGN 
E0C1  8508                      BITA #$08          ;* FORCE AND 
E0C3  2618                      BNE  L8F96         ;* BRANCH IF SET 
E0C5  0A99                      DEC  VD9           ;DECREMENT LEFT DIGIT ' NO PRE-SIGN FORCE
E0C7  5D                        TSTB               ;* CHECK LENGTH;COUNTER AND BRANCH  
E0C8  2713                      BEQ  L8F96         ;* IF END OF FORMAT STRING 
E0CA  A684                      LDA  ,X            ;GET NEXT FORMAT STRING CHARACTER 
E0CC  802D                      SUBA #'-'          ;CHECK FOR MINUS SIGN 
E0CE  2706                      BEQ  L8F8F         ;BRANCH IF MINUS SIGN 
E0D0  81FE                      CMPA #$FE          ;* WAS CMPA #('+')-('-') 
E0D2  2609                      BNE  L8F96         ;BRANCH IF NO PLUS SIGN 
E0D4  8608                      LDA  #$08          ;GET THE PRE-SIGN FORCE FLAG 
E0D6  8A04            L8F8F     ORA  #$04          ;'OR' IN POST-SIGN FORCE FLAG
E0D8  9A9A                      ORA  VDA           ;'OR' IN THE STATUS BYTE
E0DA  979A                      STA  VDA           ;SAVE THE STATUS BYTE 
E0DC  5A                        DECB               ;DECREMENT FORMAT STRING LENGTH 
                                                     
                      * EVALUATE NUMERIC ITEM-LIST                      
E0DD  9D82            L8F96     JSR  GETCCH        ;GET CURRENT CHARACTER 
E0DF  1027FF3C                  LBEQ L8ED8         ;BRANCH IF END OF LINE 
E0E3  D793                      STB  VD3           ;SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED 
E0E5  BDC8D2                    JSR  LB141         ;EVALUATE EXPRESSION 
E0E8  9699                      LDA  VD9           ;GET THE LEFT DIGIT COUNTER 
E0EA  9B98                      ADDA VD8           ;ADD IT TO THE RIGHT DIGIT COUNTER 
E0EC  8111                      CMPA #17           ;* 
E0EE  1022EAE4                  LBHI LB44A         ;*'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
E0F2  BDE12C                    JSR  L8FE5         ;CONVERT ITEM-LIST TO FORMATTED ASCII STRING 
E0F5  301F                      LEAX -1,X        ;MOVE BUFFER POINTER BACK ONE 
E0F7  BDD0ED                    JSR  LB99C         ;DISPLAY THE FORMATTED STRING TO CONSOLE OUT 
E0FA  0F97            L8FB3     CLR  VD7           ;RESET NEXT PRINT ITEM FLAG 
E0FC  9D82                      JSR  GETCCH        ;GET CURRENT INPUT CHARACTER 
E0FE  270D                      BEQ  L8FC6         ;BRANCH IF END OF LINE 
E100  9797                      STA  VD7           ;SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG 
E102  813B                      CMPA #';'          ;* CHECK FOR ; - ITEM-LIST SEPARATOR AND 
E104  2705                      BEQ  L8FC4         ;* BRANCH IF SEMICOLON 
E106  BDC9FE                    JSR  LB26D         ;SYNTAX CHECK FOR COMMA 
E109  2002                      BRA  L8FC6         ;PROCESS NEXT PRINT ITEM 
E10B  9D7C            L8FC4     JSR  GETNCH        ;GET NEXT INPUT CHARACTER 
E10D  9E95            L8FC6     LDX  VD5           ;GET FORMAT STRING DESCRIPTOR ADDRESS 
E10F  E684                      LDB  ,X            ;GET LENGTH OF FORMAT STRING 
E111  D093                      SUBB VD3           ;SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM 
E113  AE02                      LDX  $02,X         ;*GET FORMAT STRING START ADDRESS AND ADVANCE 
E115  3A                        ABX                ;*POINTER TO START OF UNUSED FORMAT STRING  
E116  D693                      LDB  VD3           ;* GET AMOUNT OF UNUSED FORMAT STRING 
E118  1026FEE4                  LBNE L8EB9         ;* REINTERPRET FORMAT STRING FROM THAT POINT 
E11C  7EE019                    JMP  L8ED2         ;REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY 
                      *         USED ON LAST PRINT ITEM  
                                                     
                      * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
E11F  3402            L8FD8     PSHS A             ;RESTORE ACCA AND RETURN 
E121  862B                      LDA  #'+'          ;GET ASCII PLUS SIGN 
E123  0D9A                      TST  VDA           ;* CHECK THE STATUS BYTE AND 
E125  2703                      BEQ  L8FE3         ;* RETURN IF = 0 
E127  BDC017                    JSR  PUTCHR        ;SEND A CHARACTER TO CONSOLE OUT 
E12A  3582            L8FE3     PULS A,PC          ;RETURN ACCA AND RETURN 
                                                     
                      * CONVERT ITEM-LIST TO DECIMAL ASCII STRING                      
E12C  CE01F2          L8FE5     LDU  #STRBUF+4     ;POINT U TO STRING BUFFER 
E12F  C620                      LDB  #SPACE        ;BLANK 
E131  969A                      LDA  VDA           ;* GET THE STATUS FLAG AND 
E133  8508                      BITA #$08          ;* CHECK FOR A PRE-SIGN FORCE 
E135  2702                      BEQ  L8FF2         ;* BRANCH IF NO PRE-SIGN FORCE 
E137  C62B                      LDB  #'+'          ;PLUS SIGN 
E139  0D54            L8FF2     TST  FP0SGN        ;CHECK THE SIGN OF FPA0 
E13B  2A04                      BPL  L8FFA         ;BRANCH IF POSITIVE 
E13D  0F54                      CLR  FP0SGN        ;FORCE FPA0 SIGN TO BE POSITIVE 
E13F  C62D                      LDB  #'-'          ;MINUS SIGN 
E141  E7C0            L8FFA     STB  ,U+           ;SAVE THE SIGN IN BUFFER 
E143  C630                      LDB  #'0'          ;* PUT A ZERO INTO THE BUFFER 
E145  E7C0                      STB  ,U+           ;* 
E147  8401                      ANDA #$01          ;* CHECK THE EXPONENTIAL FORCE FLAG IN 
E149  10260107                  LBNE L910D         ;* THE STATUS BYTE - BRANCH IF ACTIVE 
E14D  8ED511                    LDX  #LBDC0        ;POINT X TO FLOATING POINT 1E + 09 
E150  BDD3F1                    JSR  LBCA0         ;COMPARE FPA0 TO (X) 
E153  2B15                      BMI  L9023         ;BRANCH IF FPA0 < 1E+09 
E155  BDD52A                    JSR  LBDD9         ;CONVERT FP NUMBER TO ASCII STRING 
E158  A680            L9011     LDA  ,X+           ;* ADVANCE POINTER TO END OF 
E15A  26FC                      BNE  L9011         ;* ASCII STRING (ZERO BYTE) 
E15C  A682            L9015     LDA  ,-X           ;MOVE THE 
E15E  A701                      STA  $01,X         ;ENTIRE STRING 
E160  8C01F1                    CMPX #STRBUF+3     ;UP ONE 
E163  26F7                      BNE  L9015         ;BYTE 
E165  8625                      LDA  #'%'          ;* INSERT A % SIGN AT START OF 
E167  A784                      STA  ,X            ;* STRING - OVERFLOW ERROR 
E169  39                        RTS                  
                                                     
E16A  964F            L9023     LDA  FP0EXP        ;GET EXPONENT OF FPA0 
E16C  9747                      STA  V47           ;AND SAVE IT IN V74 
E16E  2703                      BEQ  L902C         ;BRANCH IF FPA0 = 0 
E170  BDE314                    JSR  L91CD         ;CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT 
                      *              PLACES TO LEFT;OF DECIMAL POINT  
E173  9647            L902C     LDA  V47           ;GET BASE 10 EXPONENT OFFSET 
E175  102B0081                  LBMI L90B3         ;BRANCH IF FPA0 < 100,000,000 
E179  40                        NEGA               ;* CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT - 
E17A  9B99                      ADDA VD9           ;* SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS 
E17C  8009                      SUBA #$09          ;* 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER 
E17E  BDE231                    JSR  L90EA         ;PUT ACCA ZEROES IN STRING BUFFER 
E181  BDE3AA                    JSR  L9263         ;INITIALIZE DECIMAL POINT AND COMMA COUNTERS 
E184  BDE349                    JSR  L9202         ;CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER 
E187  9647                      LDA  V47           ;* GET BASE 10 EXPONENT AND PUT THAT MANY 
E189  BDE3C8                    JSR  L9281         ;* ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT 
E18C  9647                      LDA  V47           ;WASTED INSTRUCTION - SERVES NO PURPOSE 
E18E  BDE390                    JSR  L9249         ;CHECK FOR DECIMAL POINT 
E191  9698                      LDA  VD8           ;GET THE RIGHT DIGIT COUNTER 
E193  2602                      BNE  L9050         ;BRANCH IF RIGHT DIGlT COUNTER <> 0 
E195  335F                      LEAU -1,U          ;MOVE BUFFER POINTER BACK ONE - DELETE 
                      *                            ;DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED  
E197  4A              L9050     DECA               ;SUBTRACT ONE (DECIMAL POINT) 
E198  BDE231                    JSR  L90EA         ;PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES) 
E19B  BDE2CC          L9054     JSR  L9185         ;INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN 
E19E  4D                        TSTA               ;WAS THERE A POST-SIGN? 
E19F  2706                      BEQ  L9060         ;NO 
E1A1  C12A                      CMPB #'*'          ;IS THE FIRST CHARACTER AN $? 
E1A3  2702                      BEQ  L9060         ;YES 
E1A5  E7C0                      STB  ,U+           ;STORE THE POST-SIGN 
E1A7  6FC4            L9060     CLR  ,U            ;CLEAR THE LAST CHARACTER IN THE BUFFER 
                      *                              
                      * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE                      
                      * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT                      
E1A9  8E01F1                    LDX  #STRBUF+3     ;POINT X TO THE START OF THE BUFFER  
E1AC  3001            L9065     LEAX $01,X         ;MOVE BUFFER POINTER UP ONE 
E1AE  9F0F                      STX  TEMPTR        ;SAVE BUFFER POINTER IN TEMPTR 
E1B0  963A                      LDA  VARPTR+1      ;* GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT 
E1B2  9010                      SUBA TEMPTR+1      ;* CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER - 
E1B4  9099                      SUBA VD9           ;* THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING 
                      *              * TO THE FIRST;DIGIT OF THE FORMAT STRING  
E1B6  2738                      BEQ  L90A9         ;RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT 
E1B8  A684                      LDA  ,X            ;GET THE CURRENT BUFFER CHARACTER 
E1BA  8120                      CMPA #SPACE        ;SPACE? 
E1BC  27EE                      BEQ  L9065         ;YES - ADVANCE POINTER 
E1BE  812A                      CMPA #'*'          ;ASTERISK? 
E1C0  27EA                      BEQ  L9065         ;YES - ADVANCE POINTER 
E1C2  4F                        CLRA               ;A ZERO ON THE STACK IS END OF DATA POINTER 
E1C3  3402            L907C     PSHS A             ;PUSH A CHARACTER ONTO THE STACK 
E1C5  A680                      LDA  ,X+           ;GET NEXT CHARACTER FROM BUFFER 
E1C7  812D                      CMPA #'-'          ;MINUS SIGN? 
E1C9  27F8                      BEQ  L907C         ;YES 
E1CB  812B                      CMPA #'+'          ;PLUS SIGN? 
E1CD  27F4                      BEQ  L907C         ;YES 
E1CF  8124                      CMPA #'$'          ;DOLLAR SIGN? 
E1D1  27F0                      BEQ  L907C         ;YES 
E1D3  8130                      CMPA #'0'          ;ZERO? 
E1D5  260E                      BNE  L909E         ;NO - ERROR 
E1D7  A601                      LDA  $01,X         ;GET CHARACTER FOLLOWING ZERO 
E1D9  8D16                      BSR  L90AA         ;CLEAR CARRY IF NUMERIC 
E1DB  2508                      BLO  L909E         ;BRANCH IF NOT A NUMERIC CHARACTER - ERROR 
E1DD  3502            L9096     PULS A             ;* PULL A CHARACTER OFF OF THE STACK 
E1DF  A782                      STA  ,-X           ;* AND PUT IT BACK IN THE STRING BUFFER 
E1E1  26FA                      BNE  L9096         ;* KEEP GOING UNTIL ZERO FLAG 
E1E3  20C7                      BRA  L9065         ;KEEP CLEANING UP THE INPUT BUFFER 
E1E5  3502            L909E     PULS A               
E1E7  4D                        TSTA               ;* THE STACK AND EXIT WHEN 
E1E8  26FB                      BNE  L909E         ;* ZERO FLAG FOUND 
E1EA  9E0F                      LDX  TEMPTR        ;GET THE STRING BUFFER START POINTER 
E1EC  8625                      LDA  #'%'          ;* PUT A % SIGN BEFORE THE ERROR POSITION TO 
E1EE  A782                      STA  ,-X           ;* INDICATE AN ERROR 
E1F0  39              L90A9     RTS                  
                      *                              
                      * CLEAR CARRY IF NUMERIC                      
E1F1  8130            L90AA     CMPA #'0'          ;ASCII ZERO 
E1F3  2504                      BLO  L90B2         ;RETURN IF ACCA < ASCII 0 
E1F5  803A                      SUBA #$3A          ;*  #'9'+1 
E1F7  80C6                      SUBA #$C6          ;* #-('9'+1)  CARRY CLEAR IF NUMERIC 
E1F9  39              L90B2     RTS                  
                      *                              
                      * PROCESS AN ITEM-LIST WHICH IS < 100,000,000                      
E1FA  9698            L90B3     LDA  VD8           ;GET RIGHT DIGIT COUNTER 
E1FC  2701                      BEQ  L90B8         ;BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT 
E1FE  4A                        DECA               ;SUBTRACT ONE FOR DECIMAL POINT 
E1FF  9B47            L90B8     ADDA V47           ;*ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE 
                      *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED  
                      *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT  
E201  2B01                      BMI  L90BD         ;IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED 
E203  4F                        CLRA               ;FORCE SHIFT COUNTER = 0 
E204  3402            L90BD     PSHS A             ;SAVE INITIAL SHIFT COUNTER ON THE STACK 
E206  2A0A            L90BF     BPL  L90CB         ;EXIT ROUTINE IF POSITIVE 
E208  3402                      PSHS A             ;SAVE SHIFT COUNTER ON STACK 
E20A  BDD2D3                    JSR  LBB82         ;DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT 
E20D  3502                      PULS A             ;GET SHIFT COUNTER FROM THE STACK 
E20F  4C                        INCA               ;BUMP SHIFT COUNTER UP BY ONE 
E210  20F4                      BRA  L90BF         ;CHECK FOR FURTHER DIVISION 
E212  9647            L90CB     LDA  V47           ;* GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER 
E214  A0E0                      SUBA ,S+           ;* AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE 
E216  9747                      STA  V47           ;* FPA0 WAS SHIFTED ABOVE 
E218  8B09                      ADDA #$09          ;* ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO 
E21A  2B19                      BMI  L90EE         ;* ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM 
E21C  9699                      LDA  VD9           ;*DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL 
E21E  8009                      SUBA #$09          ;*POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL 
E220  9047                      SUBA V47           ;*POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9 
E222  8D0D                      BSR  L90EA         ;*(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER 
E224  BDE3AA                    JSR  L9263         ;INITIALIZE DECIMAL POINT AND COMMA COUNTERS 
E227  201D                      BRA  L90FF         ;PROCESS THE REMAINDER OF THE PRINT ITEM 
                      *                              
                      * PUT (ACCA+1) ASCII ZEROES IN BUFFER                      
E229  3402            L90E2     PSHS A             ;SAVE ZERO COUNTER 
E22B  8630                      LDA  #'0'          ;* INSERT A ZERO INTO 
E22D  A7C0                      STA  ,U+           ;* THE BUFFER 
E22F  3502                      PULS A             ;RESTORE ZERO COUNTER 
                                                     
                      * PUT ACCA ASCII ZEROES INTO THE BUFFER                      
E231  4A              L90EA     DECA               ;DECREMENT ZERO COUNTER 
E232  2AF5                      BPL  L90E2         ;BRANCH IF NOT DONE 
E234  39                        RTS                  
                                                     
E235  9699            L90EE     LDA  VD9           ;* GET THE LEFT DIGIT COUNTER AND PUT 
E237  8DF8                      BSR  L90EA         ;* THAT MANY ZEROES IN THE STRiNG BUFFER 
E239  BDE394                    JSR  L924D         ;PUT THE DECIMAL POINT IN THE STRING BUFFER 
E23C  86F7                      LDA  #-9           ;*DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT 
E23E  9047                      SUBA V47           ;*AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9 
E240  8DEF                      BSR  L90EA         ;*(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER 
E242  0F45                      CLR  V45           ;CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT 
E244  0F97                      CLR  VD7           ;CLEAR THE COMMA COUNTER - SUPPRESS COMMAS 
E246  BDE349          L90FF     JSR  L9202         ;DECODE FPA0 INTO A DECIMAL ASCII STRING 
E249  9698                      LDA  VD8           ;GET THE RIGHT DIGIT COUNTER 
E24B  2602                      BNE  L9108         ;BRANCH IF RIGHT DIGIT COUNTER <> 0 
E24D  DE39                      LDU  VARPTR        ;RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT 
E24F  9B47            L9108     ADDA V47           ;*ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY 
                      * *FILLER ZEROES TO BE OUTPUT;TO THE RIGHT OF LAST SIGNIFICANT DATA                      
                      *         *SIGNIFICANT DATA            
E251  16FF43                    LBRA L9050         ;INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC 
                      *                              
                      * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT                      
E254  964F            L910D     LDA  FP0EXP        ;* GET EXPONENT OF FPA0 AND 
E256  3402                      PSHS A             ;* SAVE IT ON THE STACK 
E258  2703                      BEQ  L9116         ;BRANCH IF FPA0 = 0 
E25A  BDE314                    JSR  L91CD         ;*CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT 
                      *         *DIGITS TO THE LEFT;OF THE DECIMAL POINT  
E25D  9698            L9116     LDA  VD8           ;GET THE RIGHT DIGIT COUNTER 
E25F  2701                      BEQ  L911B         ;BRANCH IF NO FORMATTED DIGITS TO THE RIGHT 
E261  4A                        DECA               ;SUBTRACT ONE FOR THE DECIMAL POINT 
E262  9B99            L911B     ADDA VD9           ;ADD TO THE LEFT DIGIT COUNTER 
E264  7F01F1                    CLR  STRBUF+3      ;CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION 
E267  D69A                      LDB  VDA           ;* GET THE STATUS BYTE FOR A 
E269  C404                      ANDB #$04          ;* POST-BYTE FORCE; BRANCH IF 
E26B  2603                      BNE  L9129         ;* A POST-BYTE FORCE 
E26D  7301F1                    COM  STRBUF+3      ;TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE 
E270  BB01F1          L9129     ADDA STRBUF+3      ;SUBTRACT 1 IF NO POST BYTE FORCE 
E273  8009                      SUBA #$09          ;*SUBTRACT 9 (DUE TO THE CONVERSION TO 9 
                      *         *SIGNIFICANT DIGITS;TO LEFT OF DECIMAL POINT)  
E275  3402                      PSHS A             ;* SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER 
                      *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF  
                      *         FORMATTED PLACES TO;THE RIGHT OF THE DECIMAL POINT.  
E277  2A0A            L9130     BPL  L913C         ;NO MORE SHIFTS WHEN ACCA >= 0 
E279  3402                      PSHS A             ;SAVE SHIFT COUNTER 
E27B  BDD2D3                    JSR  LBB82         ;DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE 
E27E  3502                      PULS A             ;RESTORE THE SHIFT COUNTER 
E280  4C                        INCA               ;ADD 1 TO SHIFT COUNTER 
E281  20F4                      BRA  L9130         ;CHECK FOR FURTHER SHIFTING (DIVISION) 
E283  A6E4            L913C     LDA  ,S            ;*GET THE INITIAL VALUE OF THE SHIFT COUNTER 
E285  2B01                      BMI  L9141         ;*AND BRANCH IF SHIFTING HAS TAKEN PLACE 
E287  4F                        CLRA               ;RESET ACCA IF NO SHIFTING HAS TAKEN PLACE 
E288  40              L9141     NEGA               ;*CALCULATE THE POSITION OF THE DECIMAL POINT BY 
E289  9B99                      ADDA VD9           ;*NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER 
E28B  4C                        INCA               ;*PLUS ONE AND THE POST-BYTE POSlTION, IF USED 
E28C  BB01F1                    ADDA STRBUF+3      ;* 
E28F  9745                      STA  V45           ;SAVE DECIMAL POINT COUNTER 
E291  0F97                      CLR  VD7           ;CLEAR COMMA COUNTER - NO COMMAS INSERTED 
E293  BDE349                    JSR  L9202         ;CONVERT FPA0 INTO ASCII DECIMAL STRING 
E296  3502                      PULS A             ;* GET THE INITIAL VALUE OF SHIFT COUNTER AND 
E298  BDE3C8                    JSR  L9281         ;* INSERT THAT MANY ZEROES INTO THE BUFFER 
E29B  9698                      LDA  VD8           ;*GET THE RIGHT DIGIT COUNTER AND BRANCH 
E29D  2602                      BNE  L915A         ;*IF NOT ZERO 
E29F  335F                      LEAU -1,U        ;MOVE BUFFER POINTER BACK ONE 
                                                     
                      * CALCULATE VALUE OF EXPONENT;AND PUT IN STRING BUFFER                      
E2A1  E6E0            L915A     LDB  ,S+           ;GET ORIGINAL EXPONENT OF FPA0 
E2A3  2709                      BEQ  L9167         ;BRANCH IF EXPONENT = 0 
E2A5  D647                      LDB  V47           ;GET BASE 10 EXPONENT 
E2A7  CB09                      ADDB #$09          ;ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION 
E2A9  D099                      SUBB VD9           ;SUBTRACT LEFT DIGIT COUNTER 
E2AB  F001F1                    SUBB STRBUF+3      ;ADD ONE TO EXPONENT IF POST-SIGN FORCE 
E2AE  862B            L9167     LDA  #'+'          ;PLUS SIGN 
E2B0  5D                        TSTB               ;TEST EXPONENT   
E2B1  2A03                      BPL  L916F         ;BRANCH IF POSITIVE EXPONENT 
E2B3  862D                      LDA  #'-'          ;MINUS SIGN 
E2B5  50                        NEGB               ;CONVERT EXPONENT TO POSITIVE NUMBER 
E2B6  A741            L916F     STA  $01,U         ;PUT SIGN OF EXPONENT IN STRING BUFFER 
E2B8  8645                      LDA  #'E'          ;* PUT AN 'E' (EXPONENTIATION FLAG) IN
E2BA  A7C1                      STA  ,U++          ;* BUFFER AND SKIP OVER THE SIGN 
E2BC  862F                      LDA  #$2F          ;* WAS LDA #'0'-1 
                      *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA                      
E2BE  4C              L9177     INCA               ;ADD ONE TO TENS DIGIT COUNTER 
E2BF  C00A                      SUBB #10           ;*SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS 
E2C1  24FB                      BCC  L9177         ;* DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY 
E2C3  CB3A                      ADDB #$3A          ;WAS ADDB #'9'+1 
E2C5  EDC1                      STD  ,U++          ;SAVE EXPONENT IN BUFFER 
E2C7  6FC4                      CLR  ,U            ;CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR 
E2C9  7EE19B                    JMP  L9054         ;INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC. 
                                                     
                      * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN                      
E2CC  8E01F2          L9185     LDX  #STRBUF+4     ;POINT X TO START OF PRINT ITEM BUFFER 
E2CF  E684                      LDB  ,X            ;* GET SIGN BYTE OF ITEM-LIST BUFFER 
E2D1  3404                      PSHS B             ;* AND SAVE IT ON THE STACK 
E2D3  8620                      LDA  #SPACE        ;DEFAULT PAD WITH BLANKS 
E2D5  D69A                      LDB  VDA           ;* GET STATUS BYTE AND CHECK FOR 
E2D7  C520                      BITB #$20          ;* ASTERISK LEFT PADDING 
E2D9  3504                      PULS B             ;GET SIGN BYTE AGAIN 
E2DB  2708                      BEQ  L919E         ;BRANCH IF NO PADDING 
E2DD  862A                      LDA  #'*'          ;PAD WITH ASTERISK 
E2DF  C120                      CMPB #SPACE        ;WAS THE FIRST BYTE A BLANK (POSITIVE)? 
E2E1  2602                      BNE  L919E         ;NO 
E2E3  1F89                      TFR  A,B           ;TRANSFER PAD CHARACTER TO ACCB 
E2E5  3404            L919E     PSHS B             ;SAVE FIRST CHARACTER ON STACK 
E2E7  A780            L91A0     STA  ,X+           ;STORE PAD CHARACTER IN BUFFER 
E2E9  E684                      LDB  ,X            ;GET NEXT CHARACTER IN BUFFER 
E2EB  2710                      BEQ  L91B6         ;INSERT A ZERO IF END OF BUFFER 
E2ED  C145                      CMPB #'E'          ;* CHECK FOR AN 'E' AND
E2EF  270C                      BEQ  L91B6         ;* PUT A ZERO BEFORE IT 
E2F1  C130                      CMPB #'0'          ;* REPLACE LEADING ZEROES WITH 
E2F3  27F2                      BEQ  L91A0         ;* PAD CHARACTERS 
E2F5  C12C                      CMPB #','          ;* REPLACE LEADING COMMAS 
E2F7  27EE                      BEQ  L91A0         ;* WITH PAD CHARACTERS 
E2F9  C12E                      CMPB #'.'          ;* CHECK FOR DECIMAL POINT 
E2FB  2604                      BNE  L91BA         ;* AND DON'T PUT A ZERO BEFORE IT
E2FD  8630            L91B6     LDA  #'0'          ;* REPLACE PREVIOUS CHARACTER 
E2FF  A782                      STA  ,-X           ;* WITH A ZERO 
E301  969A            L91BA     LDA  VDA           ;* GET STATUS BYTE, CHECK 
E303  8510                      BITA #$10          ;* FOR FLOATING $ 
E305  2704                      BEQ  L91C4         ;* BRANCH IF NO FLOATING $ 
E307  C624                      LDB  #'$'          ;* STORE A $ IN 
E309  E782                      STB  ,-X           ;* BUFFER 
E30B  8404            L91C4     ANDA #$04          ;CHECK PRE-SIGN FLAG 
E30D  3504                      PULS B             ;GET SIGN CHARACTER 
E30F  2602                      BNE  L91CC         ;RETURN IF POST-SIGN REQUIRED 
E311  E782                      STB  ,-X           ;STORE FIRST CHARACTER 
E313  39              L91CC     RTS                  
                      *                              
                      * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.                      
                      * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).                      
E314  3440            L91CD     PSHS U             ;SAVE BUFFER POINTER 
E316  4F                        CLRA               ;INITIAL EXPONENT OFFSET = 0 
E317  9747            L91D0     STA  V47           ;SAVE EXPONENT OFFSET 
E319  D64F                      LDB  FP0EXP        ;GET EXPONENT OF FPA0 
E31B  C180                      CMPB #$80          ;* COMPARE TO EXPONENT OF .5 
E31D  2211                      BHI  L91E9         ;* AND BRANCH IF FPA0 > = 1.0 
                                                     
                      * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1                      
E31F  8ED511                    LDX  #LBDC0        ;POINT X TO FP NUMBER (1E+09) 
E322  BDD21B                    JSR  LBACA         ;MULTIPLY FPA0 BY 1E+09 
E325  9647                      LDA  V47           ;GET EXPONENT OFFSET 
E327  8009                      SUBA #$09          ;SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE) 
E329  20EC                      BRA  L91D0         ;CHECK TO SEE IF > 1.0 
E32B  BDD2D3          L91E4     JSR  LBB82         ;DIVIDE FPA0 BY 10 
E32E  0C47                      INC  V47           ;INCREMENT EXPONENT OFFSET 
E330  8ED50C          L91E9     LDX  #LBDBB        ;POINT X TO FP NUMBER (999,999,999) 
E333  BDD3F1                    JSR  LBCA0         ;COMPARE FPA0 TO X 
E336  2EF3                      BGT  L91E4         ;BRANCH IF FPA0 > 999,999,999 
E338  8ED507          L91F1     LDX  #LBDB6        ;POINT X TO FP NUMBER (99,999,999.9) 
E33B  BDD3F1                    JSR  LBCA0         ;COMPARE FPA0 TO X 
E33E  2E07                      BGT  L9200         ;RETURN IF 999,999,999 > FPA0 > 99,999,999.9 
E340  BDD2BB                    JSR  LBB6A         ;MULTIPLY FPA0 BY 10 
E343  0A47                      DEC  V47           ;DECREMENT EXPONENT OFFSET 
E345  20F1                      BRA  L91F1         ;KEEP UNNORMALIZING 
E347  35C0            L9200     PULS U,PC          ;RESTORE BUFFER POINTER AND RETURN 
                      *                              
                      * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT                      
                      * INTO A DECIMAL ASCII STRING;IN THE BUFFER                      
E349  3440            L9202     PSHS U             ;SAVE BUFFER POINTER 
E34B  BDD105                    JSR  LB9B4         ;ADD .5 TO FPA0 (ROUND OFF) 
E34E  BDD419                    JSR  LBCC8         ;CONVERT FPA0 TO INTEGER FORMAT 
E351  3540                      PULS U             ;RESTORE BUFFER POINTER 
                      *                              
                      * CONVERT FPA0 INTO A DECIMAL;ASCII STRING                      
E353  8ED616                    LDX  #LBEC5        ;POINT X TO UNNORMALIZED POWERS OF 10 
E356  C680                      LDB  #$80          ;INITIALIZE DIGIT COUNTER TO 0 + $80. 
                      * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA                      
                      * IS NEGATIVE. WHEN YOU 'ADD';A NEGATIVE MANTISSA, IT IS
                      * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB                      
                      * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
E358  8D36            L9211     BSR  L9249         ;CHECK FOR COMMA INSERTION 
E35A  9653            L9213     LDA  FPA0+3        ;* 'ADD' A POWER OF 10 MANTISSA TO FPA0.
E35C  AB03                      ADDA $03,X         ;* IF THE MANTISSA IS NEGATIVE, A SUBTRACTION 
E35E  9753                      STA  FPA0+3        ;* WILL BE WHAT REALLY TAKES PLACE. 
E360  9652                      LDA  FPA0+2        ;* 
E362  A902                      ADCA $02,X         ;* 
E364  9752                      STA  FPA0+2        ;* 
E366  9651                      LDA  FPA0+1        ;* 
E368  A901                      ADCA $01,X         ;* 
E36A  9751                      STA  FPA0+1        ;* 
E36C  9650                      LDA  FPA0          ;* 
E36E  A984                      ADCA ,X            ;* 
E370  9750                      STA  FPA0          ;* 
E372  5C                        INCB               ;ADD ONE TO DIGIT COUNTER 
E373  56                        RORB               ;ROTATE CARRY INTO BIT 7  
E374  59                        ROLB               ;* SET OVERFLOW FLAG - BRANCH IF CARRY SET AND 
E375  28E3                      BVC  L9213         ;* ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA 
E377  2403                      BCC  L9235         ;BRANCH IF SUBTRACTING MANTISSA 
E379  C00B                      SUBB #10+1         ;WAS SUBB #10+1 
E37B  50                        NEGB               ;* IF ADDING MANTISSA 
E37C  CB2F            L9235     ADDB #$2F          ;WAS ADDB #'0'-1 
E37E  3004                      LEAX $04,X         ;MOVE TO NEXT POWER OF 10 MANTISSA 
E380  1F98                      TFR  B,A           ;SAVE DIGIT IN ACCA 
E382  847F                      ANDA #$7F          ;MASK OFF ADD/SUBTRACT FLAG (BIT 7) 
E384  A7C0                      STA  ,U+           ;STORE DIGIT IN BUFFER 
E386  53                        COMB               ;TOGGLE ADD/SUBTRACT FLAG 
E387  C480                      ANDB #$80          ;MASK OFF EVERYTHING BUT ADD/SUB FLAG 
E389  8CD63A                    CMPX #LBEE9        ;COMPARE TO END OF UNNORMALIZED POWERS OF 10 
E38C  26CA                      BNE  L9211         ;BRANCH IF NOT DONE 
E38E  6FC4                      CLR  ,U            ;PUT A ZERO AT END OF INTEGER 
                                                     
                      * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION                      
E390  0A45            L9249     DEC  V45           ;DECREMENT DECIMAL POINT COUNTER 
E392  2609                      BNE  L9256         ;NOT TIME FOR DECIMAL POINT 
E394  DF39            L924D     STU  VARPTR        ;SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT 
E396  862E                      LDA  #'.'          ;* STORE A DECIMAL 
E398  A7C0                      STA  ,U+           ;* POINT IN THE OUTPUT BUFFER 
E39A  0F97                      CLR  VD7           ;* CLEAR COMMA COUNTER - NOW IT WILL TAKE 255 
                      *                            ;* DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED 
E39C  39                        RTS                  
E39D  0A97            L9256     DEC  VD7           ;DECREMENT COMMA COUNTER 
E39F  2608                      BNE  L9262         ;RETURN IF NOT TIME FOR COMMA 
E3A1  8603                      LDA  #$03          ;* RESET COMMA COUNTER TO 3; THREE 
E3A3  9797                      STA  VD7           ;* DIGITS BETWEEN COMMAS 
E3A5  862C                      LDA  #','          ;* PUT A COMMA INTO 
E3A7  A7C0                      STA  ,U+           ;* THE BUFFER 
E3A9  39              L9262     RTS                  
                                                     
                      * INITIALIZE DECIMAL POINT AND COMMA COUNTERS                      
E3AA  9647            L9263     LDA  V47           ;GET THE BASE 10 EXPONENT OFFSET 
E3AC  8B0A                      ADDA #10           ;* ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
E3AE  9745                      STA  V45           ;* OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER 
E3B0  4C                        INCA               ;ADD ONE FOR THE DECIMAL POINT 
E3B1  8003            L926A     SUBA #$03          ;* DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE 
E3B3  24FC                      BCC  L926A         ;* THE REMAINDER IN ACCA 
E3B5  8B05                      ADDA #$05          ;CONVERT REMAINDER INTO A NUMBER FROM 1-3 
E3B7  9797                      STA  VD7           ;SAVE COMMA COUNTER 
E3B9  969A                      LDA  VDA           ;GET STATUS BYTE 
E3BB  8440                      ANDA #$40          ;CHECK FOR COMMA FLAG 
E3BD  2602                      BNE  L927A         ;BRANCH IF COMMA FLAG ACTIVE 
E3BF  9797                      STA  VD7           ;CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA 
E3C1  39              L927A     RTS                  
                      *                              
                      * INSERT ACCA ZEROES INTO THE;BUFFER                      
E3C2  3402            L927B     PSHS A             ;SAVE ZEROES COUNTER 
E3C4  8DCA                      BSR  L9249         ;CHECK FOR DECIMAL POINT 
E3C6  3502                      PULS A             ;RESTORE ZEROES COUNTER 
E3C8  4A              L9281     DECA               ;* DECREMENT ZEROES COUNTER AND 
E3C9  2B0A                      BMI  L928E         ;* RETURN IF < 0 
E3CB  3402                      PSHS A             ;SAVE ZEROES COUNTER 
E3CD  8630                      LDA  #'0'          ;* PUT A ZERO INTO 
E3CF  A7C0                      STA  ,U+           ;* THE BUFFER 
E3D1  A6E0                      LDA  ,S+           ;RESTORE THE ZEROES COUNTER 
E3D3  26ED                      BNE  L927B         ;BRANCH IF NOT DONE 
E3D5  39              L928E     RTS                  
                                                     
                                                     
                      * LINE                         
E3D6  8189            LINE      CMPA #TOK_INPUT    ;'INPUT' TOKEN
E3D8  1027F95C                  LBEQ L89C0         ;GO DO 'LINE INPUT' COMMAND
E3DC  7ECA08                    JMP  LB277         ;'SYNTAX ERROR' IF NOT "LINE INPUT"
                                                     
                       IF MON09
                       ELSE
                                FILL $FF,$FFF0-*  ;FILL ROM TO RSV WITH FF's
                       ENDIF
                      
                       IF MON09
                       ELSE
                      
                      * END OF EXTENDED BASIC                      
                      * INTERRUPT VECTORS                      
                                ORG  $FFF0           
                      LBFF0     FDB  $0000         ;RESERVED 
                      LBFF2     FDB  SW3VEC        ;SWI3 
                      LBFF4     FDB  SW2VEC        ;SWI2 
                      LBFF6     FDB  FRQVEC        ;FIRQ 
                      LBFF8     FDB  IRQVEC        ;IRQ 
                      LBFFA     FDB  SWIVEC        ;SWI 
                      LBFFC     FDB  NMIVEC        ;NMI 
                      LBFFE     FDB  RESVEC        ;RESET 
                       ENDIF
