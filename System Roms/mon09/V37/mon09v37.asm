;******************************************************************************
;*
;* MON09: A software debug monitor for the 6809
;* TODO: UPDATE FOR HB63C09M - 
;* 	 what follows describes Dave Dunfields portable 		
;* The monitor is currently setup to run on a system which has 8K of ROM
;* (for MON09) at the top of the memory may ($E000-$FFFF), and 48K of RAM
;* from $2000-$DFFF. The 8K block from $0000-$1FFF is used for I/O devices
;* etc. MON09 uses 160 bytes of memory at the very top of available RAM,
;* and the user stack pointer is initialized to point to the beginning of
;* this area, allowing the user stack to grow downward into free user RAM.
;*
;* Console and Host I/O device drivers are included for both 6551 and 6552
;* type uarts, which are selected by the set symbol 'utype', and conditionally
;* assembled into the code. THIS FILE MUST BE PROCESSED WITH 'MACRO' PRIOR
;* TO ASSEMBLING WITH ASM09!!! You can modify the I/O drivers to support a
;* different uart device if you wish. The serial I/O drivers are at the very
;* end of the monitor source code (Just before the interrupt vectors).
;*
;* Copyright 1985-2007 Dave Dunfield
;* All rights reserved.
;*
;* Additional modifications for the HB63C09 by Dave Collins, Z80Dad
; VERSION 3.7
; 2024-0331:	
;		DC	REMOVED OPTION ROM BUILDING FROM CODE FOR TINYBASIC, AND FORTH DUE TO 
;			SIZE CONSTRAINTS (IT IS TRIVIAL TO UNCOMMENT THEM)
;		DC	CHANGED ADDRESS RANGES TO SUPPORT THE HB63C09
;		DC	FIXED 'WRAP AROUND' BUG FROM ORIGINAL DUNFIELD SOURCE WHICH WOULD CAUSE
;			MEMORY SR TO OUTPUT FOREVER IF YOU TRIED TO DISPLAY AN ADDRESS
;			FROM 0xFFF0 TO THE END OF MEMORY.  THIS SLIGHTLY CHANGES THE BEHAVIOR, 
;			AS NOW, THE START ADDRESS WILL ALIGN WITH THE BEGINNING OF A 16 BYTE
;			BLOCK (STARTING AT A NUMBER WITH THE BOTTOM 4 BITS BEING CLEAR.)
;			SINCE THE SR ALWAYS OUTPUTS 16 BYTES THIS ALIGNS THE LAST INCREMENT OF X 
; 			WITH ZERO SO THAT WE CAN CATCH THE REGISTER ROLLING OVER AND THE SR 
;			DOES NOT RUN FOREVER.  ITS ARGUABLE THIS IS THE CORRECT FUNCTIONALITY
;			OF THE DISPLAY MEMORY SR AS IT ALWAYS OUTPUTS 16 BYTES REGARDLESS OF 
;			THE LAST ADDRESS IN THE RANGE.
;		DC	FOUND AN ISSUE WITH LOAD SR WITH THE SRECORD FORMAT.  THE SUBROTINE NEEDED 
;			TO IGNORE RECORD TYPE 5 - COUNT. SINCE IT IS A 16 BIT ADDRESS BUS. THE OTHER
;			COUNT RECORD TYPES WONT NEED TO BE TESTED FOR. (FIXED)
;		DC	FIXED CRLF HANDLER MOSTLY. OCCASIONALLY IT WILL DUMP A SPURIOUS CR ONTO THE 
;			PROMPT THIS DEPENDS ON HOW THE FILE WAS TERMINATED BY THE COMPLIER. RECORD 
;			TYPE 9 IGNORES ANY START ADDRESS THAT IS PLACED THERE, THIS WAS ALWAYS THE 
;			CASE HOWEVER NOW IT READS THE CHARACTERS IN UNTIL THE END OF THE LINE.
;		DC	SWITCHED BASIC ROM TO A MODIFIED DIGICOOLTHINGS ROM, SEE BASIC ROM SOURCE
;			FOR DETAILS.
;2025-0104:			
;		DC      DISABLED CPU DETECTION UNTIL I CAN FIGURE OUT WHY THIS CRASHES  
;			WHEN SWITCHING TO NATIVE MODE. THIS MUST BE SWITCHED MANUALLY BY 
;			YOUR PROGRAM.
;		DC 	DISABLED ILL OP HANDLER THIS MAY BE RELATED TO THE ABOVE
; 
;* Additional modifications for the 6809SBC by Johnny Quest.
;*
;******************************************************************************
; VERSION 3.6
; 2021-0904:	JQ	ON ILLOP/DIV INTERRUPT, CORRECTED BUG WHERE THE HANDLER
;					 JUMPS TO THE BREAKPOINT DISPLAY TO EXIT BUT THE 'BRKREG'
;					 IS LOCATED WITHIN THE BREAKPOINT ROUTINE, WHICH CAUSES
;					 CONFUSIION AND EVENTUAL HANG.
;				JQ	SEEMS THAT DETECTION OF A 6309 AND SETTING IT TO 'NATIVE'
;					 MODE CAUSES PROBLEMS, SO THE MODE REGISTER IS NOT TOUCHED
;					 AND THE HD6309 IS LEFT IN 'EMULATION MODE'.
;				JQ	CORRECTED BUG IN 'CHGREG' WHERE CHANGING REGISTER 'D' WAS NOT
;					 RECOGNIZED AS A 16-BIT REGISTER.
;******************************************************************************
; VERSION 3.5
; 2021-0824:	JQ	ON ILLOP/DIV INTERRUPT, INFORMS WHICH ONE CAUSED IT.
;				JQ	IF 6309 IS DETECTED, THE MODE REGISTER IS SET TO 'NATIVE'.
; 2021-0823:	JQ	ADDED SUPPORT FOR DETECTING IF THE HOST MCU IS AN MC6809
;					 OR AN HD6309 AND EMITS THE PROPER SIGN-ON MESSAGE.
;				JQ	ADDED A BUILD DATE AND TIME TO THE SIGN-ON MESSAGE. THE
;					 LINUX "build.sh" SCRIPT CREATES A SEPARATE ASSEMBLY FILE
;					 THAT IS "INCLUDED" IN THE MAIN ASSEMBLY FILE.
;				JQ	BE AWARE THAT THE DISASSEMBLER DOES NOT YET SUPPORT THE
;					 6309 EXTENDED INSTRUCTIONS.
; 2021-0419:	JQ	ADDED SUPPORT FOR MERGING THE BINARY IMAGES OF THE
;					 LANGUAGE SUPPORT MODULES DIRECTLY INTO THE MON09
;					 IMAGE FILE. USE CONDITIONAL ASSEMBLY TO ENABLE/DISABLE.
;					 CONSTRUCTED MASTER BUILD SCRIPT TO ASSEMBLE THE VARIOUS
;					 LANGUAGE MODULES INTO A MASTER FIRMWARE IMAGE FILE. THUS,
;					 INCLUDING THEM INTO THE MON09 IMAGE AS DATA STATEMENTS
;					 IS UNNESSESARY.
; 2021-0412:	JQ	CHANGED THE MANNER IN WHICH NMI IS HANDLED SO THAT THE
;					 VECTOR CAN BE SET IN MEMORY JUST AS THE FIRQ, IRQ, SWI2
;					 AND SWI3 HANDLERS DO. IF AN NMI VECTOR IS NOT SPECIFIED,
;					 MON09 DEFAULTS TO THE INTERNAL NMI HANDLER, WHICH IS SHOWN
;					 BY THE 'DV' COMMAND. ADDED ADDITIONAL BYTES TO THE DATA
;					 TABLES AND AN NMI HANDLER. USE CONDITIONAL STATEMENT TO
;					 ENABLE IT.
;				JQ	ADDED HD6309 ILLOP INSTRUCTION HANDLER. IF NO VECTOR
;					 SPECIFIED, DEFAULTS TO THE MON09 ILLOP HANDLER. USE
;					 CONDITIONAL STATEMENT TO ENABLE IT.
;				JQ	ADDED 'JUMP' COMMAND TO ACCESS THE FP BASIC, TINY BASIC
;					 AND FORTH MODULES IN ROM. USE CONDITIONAL STATEMENT TO
;					 ENABLE IT.
;				JQ	ADDED JUMP TABLE OF 'HOOKS' THAT PROVIDES A SUMMARY OF
;					 USER ACCESSIBLE MON09 ROM ENTRY ADDRESSES AND IRQ RE-
;					 VECTORING ADDRESSES IN DATA RAM. IT IS INTENDED TO BE
;					 EASILY IDENTIFIED AND EXTRACTED FROM THE SYMBOL TABLE
;					 TO BE 'INCLUDED' IN THE USER'S PROGRAM FILE. SINCE THE
;					 TABLE IS LOCATED AT
;				JQ	IN 'FILMEM' ROUTINE, ADDED CODE TO LIMIT THE USER
;					 SPECIFIED ENDING ADDRESS SO AS NOT TO OVERWRITE MON09
;					 DATA IN RAM. THIS EFFECTIVELY LIMITS THE 'FM' COMMAND
;					 TO RAM ONLY ON THE 6809SBC.
;
;******************************************************************************
; VERSION 3.4
; 2021-0404:	JQ	MODIFIED FOR USE WITH 6809SBC PROJECT USING 6850 ACIA.
;					 ASSEMBLES WITH LWASM V4.18, WHICH SUPPORTS MACROS AND
;					 CONDITIONAL ASSEMBLY STATEMENTS.
;
;******************************************************************************
;MODS BY JQ
VERSION		EQU	37		VERSION TIMES 10
JQ_DETMCU	EQU	0		SET TO '1' TO ENABLE DETECTION OF MCU TYPE
JQ_NMIRAM	EQU	0		SET TO '1' TO ENABLE NMI HANDLER IN RAM
JQ_ILLOP	EQU	0		SET TO '1' TO ENABLE 6309 ILLOP HANDLER
JQ_JMPMOD	EQU	1		SET TO '1' TO ENABLE JUMP TO MODULES
JQ_EMBEDBIN	EQU	0		SET TO '1' TO EMBED MODULE BINARY IMAGES
JQ_EFORTH	EQU	0		SET TO '1' TO USE EFORTH, ELSE Z79FORTH
;
; TO-DO
JQ_EEPROM	EQU	0		SET TO '1' TO ENABLE EEPROM WRITING

;
;TNYBASSTRT	EQU	$8C00			START ADDRESS OF TINY BASIC IN ROM
;TNYBASEND	EQU	TNYBASSTRT+$1000	END ADDRESS OF TINY BASIC IN ROM

;FTHIMGSTRT	EQU	$9C00			START ADDRESS OF FORTH IMAGE IN ROM
;FTHIMGEND	EQU	FTHIMGSTRT+$2000	END ADDRESS OF FORTH IMAGE IN ROM
; IFNE JQ_EFORTH				IF USING EFORTH
;FORTHCOLD	EQU	$0100			DESTINATION ADDRESS IN RAM (COLD START)
; ELSE
;FORTHCOLD	EQU	FTHIMGSTRT		DESTINATION ADDRESS IN RAM (COLD START)
; ENDC						IF USING EFORTH

FPBASSTRT	EQU	$C000			START ADDRESS OF FP BASIC IN ROM
FPBASEND	EQU	FPBASSTRT+$2600		END ADDRESS OF FP BASIC IN ROM
;
;== HARDWARE CONSTANTS =================================================
CODE		EQU	$E437	MON09 code goes here
RAMSTRT		EQU	$0000	START OF RAM
RAMEND		EQU	$9FFF	END OF RAM

ROMSTRT		EQU	$C000	START OF ROM
ROMEND		EQU	$10000	END OF ROM

 IFNE JQ_ILLOP			JQ ILLOP ENHANCEMENTS
VECTTBL		EQU	$FFF0
 ELSE
VECTTBL		EQU	$FFF2
 ENDC				JQ ILLOP ENHANCEMENTS

LOC		EQU	RAMEND-CODE	OFFSET -> RAM OR ROM CODE LOCATION

STACK	EQU	RAMEND-1	MON09 Stack (Top of RAM)

;MODS BY JQ
RAM		SET	RAMEND-160	MON09 data goes here
 IFNE JQ_NMIRAM				NO JQ NMI ENHANCEMENTS
RAM		SET	RAM-2		MON09 NMI VECTOR STORAGE
 ENDC					NO JQ NMI ENHANCEMENTS
 IFNE JQ_ILLOP				JQ ILLOP ENHANCEMENTS
RAM		SET	RAM-2		MON09 ILLOP VECTOR STORAGE
 ENDC					NO JQ ILLOP ENHANCEMENTS
 IFNE JQ_EEPROM				JQ EEPROM WRITE ENHANCEMENTS
RAM		SET	RAM-2		MON09 E2P PAGE-BYTE COUNTER STORAGE
 ENDC					JQ EEPROM WRITE ENHANCEMENTS
;
;== 6850 ACIA CONSTANTS ===============================================
SER1	EQU	$A000		Serial Port 1 (Console)
SER2	EQU	$A000		Serial Port 2 (Aux)

RDRF	EQU	1		BIT MASK POSITION FOR RDRF FLAG
TDRE	EQU	2		BIT MASK POSITION FOR TDRE FLAG

CTRL1	EQU	$03		MASTER RESET
CTRL2	EQU	$15		115.2K BAUD @8N1
;
;======================================================================
;*
	ORG	RAM		Internal MON09 variables
;*
;* MON09 INTERNAL MEMORY
;*
SWIADR	RMB	2		SWI VECTOR ADDRESS
SWI2ADR	RMB	2		SWI2 VECTOR ADDRESS
SWI3ADR	RMB	2		SWI3 VECTOR ADDRESS
IRQADR	RMB	2		IRQ VECTOR ADDRESS
FIRQADR	RMB	2		FIRQ VECTOR ADDRESS
;MODS BY JQ
 IFNE JQ_NMIRAM			USE LOCAL NMI HANDLER
NMIADR	RMB	2		NMI VECTOR ADDRESS
 ENDC
 IFNE JQ_ILLOP			USE LOCAL ILLOP HANDLER
ILOPADR	RMB	2		6309 ILLOP VECTOR ADDRESS
 ENDC
 IFNE JQ_EEPROM			JQ EEPROM WRITE ENHANCEMENTS
E2PCNT	RMB	1		EEPROM PAGE-BYTE COUNTER
 ENDC				JQ EEPROM WRITE ENHANCEMENTS
;
IOCON	RMB	1		I/O CONFIGURATION BYTE
UART1	RMB	2		UART 1 ADDRESS
UART2	RMB	2		UART 2 ADDRESS
SAVCC	RMB	1		SAVED CONDITION CODE REGISTER
SAVA	RMB	1		SAVED 6809 A REGISTER
SAVB	RMB	1		SAVED 6809 B REGISTER
SAVDP	RMB	1		SAVED DIRECT PAGE REGISTER
SAVX	RMB	2		SAVED X REGISTER
SAVY	RMB	2		SAVED Y REGISTER
SAVU	RMB	2		SAVED U REGISTER
SAVPC	RMB	2		SAVED PROGRAM COUNTER
SAVS	RMB	2		SAVED S REGISTER
TEMP	RMB	2		TEMPORARY STORAGE
STPFLG	RMB	1		REGISTER DISPLAY WHILE STEPPING FLAG
PTRSAV	RMB	2		SINGLE STEP AND DISASSEMBLER CODE POINTER
INSTYP	RMB	1		DISASSEMBLED INSTRUCTION TYPE
POSBYT	RMB	1		POSTBYTE STORAGE AREA
BRKTAB	RMB	24		BREAKPOINT TABLE
DSPBUF	RMB	50		DISASSEMBLER DISPLAY BUFFER
INSRAM	RMB	7		INSTRUCTION EXECUTION ADDRESS

;**********************************************************************
 IFNE JQ_EMBEDBIN		;EMBED MODULE BINARY IMAGES WITH MON09 IMAGE
;*
	; INCLUDE BINARY IMAGES OF ADDITONAL LANGUAGE MODULES
	; NOTE: THE MASTER FIRMWARE BUILD SCRIPT HANDLES
	;       COMBINING THE VARIOUS LANGUAGE MODULES INTO
	;       THE PROPER ADDRESSES IN THE FINAL HEX AND BIN
	;       FILES.
;*
;========> START OF MICRO BASIC PLUS BINARY IMAGE <==========
		ORG	TNYBASSTRT	START ADDRESS OF TINY BASIC IN ROM
		JMP	MONITOR		COLD START MON09
		FILL $FF,FTHIMGSTRT-*

;========> START OF FORTH BINARY IMAGE <=====================
		ORG	FTHIMGSTRT	START ADDRESS OF FORTH IMAGE IN ROM
;		JMP	MONITOR		COLD START MON09
	INCLUDEBIN	../../forth/eForth/ef09.bin
		FILL $FF,FPBASSTRT-*

;========> START OF FP BASIC BINARY IMAGE <==================
		ORG	FPBASSTRT	START ADDRESS OF FP BASIC IN ROM
;		JMP	MONITOR		COLD START MON09
	INCLUDEBIN	../../basic/exbasrom/ExBasROM.bin
		FILL $FF,CODE-*
;
;**********************************************************************
 ENDC				;EMBED MODULE BINARY IMAGES WITH MON09 IMAGE
;*
	ORG	CODE		MONITOR CODE STARTS HERE

	JMP	RESET		JUMP TO MON09 COLD-START

;===============================================================================
; TRAMPOLINE JUMP TABLE CONTAINING MON09 ROM ENTRY POINTS FOR USER PROGRAMS
;===============================================================================
MON09_GETCHR	JMP	GETCHR			;Reads character from selected input device, returns
						; in ACCA.
MON09_GETECH	JMP	GETECH			;Reads and echos char. from selected input device,
						; converts it to capital, and returns in ACCA.
MON09_GETNIB	JMP	GETNIB			;Gets a single hex nibble from selected input device,
						; and returns in ACCA. Sets 'Z' flag if successful.
MON09_GETBYT	JMP	GETBYT			;Gets a single hex byte from selected  input  device,
						; and returns in ACCA. Sets 'Z' flag is successful.
MON09_GETADR	JMP	GETADR			;Gets a hex word from selected input device, and
						; returns in D accumulator. Sets 'Z' if successful.
MON09_GETRNG	JMP	GETRNG			;Gets an address range from selected input device,
						; first address is returned in 'X', and second address
						; is returned in 'D'. Sets 'Z' if successful.
MON09_CHKCHR	JMP	CHKCHR			;Checks for character from terminal, and  returns  in
						; ACCA if found, otherwise returns $FF. Sets 'Z' flag
						; If character is found, and is the escape character.
MON09_PUTCHR	JMP	PUTCHR			;Writes character in ACCA to all enabled output devs.
MON09_SPACE	JMP	SPACE			;Writes a space to all enabled output devices.
MON09_LFCR	JMP	LFCR			;Writes a line-feed, Carriage-return pair to all
						; enabled output devices.
MON09_HOUT	JMP	HOUT			;Outputs nibble in ACCA to output devices in HEX.
MON09_HEXOUT	JMP	HEXOUT			;Outputs byte in ACCA to output devices in HEX.
MON09_WRDOUT	JMP	WRDOUT			;Outputs word in ACCD to output devices in HEX.
MON09_WRLIN	JMP	WRLIN			;Outputs message string pointed to by X to enabled
						; output devices. String ends with null ($00) or with
						; Carriage-Return ($0D). If strings ends with Carriage
						; Return, then LFCR is displayed at end.
MON09_WRMSG	JMP	WRMSG			;Same as above, except message string in inline with
						; code, and immediatly follows call to WRMSG.
MON09_DLOAD	JMP	DLOAD			;Downloads one record of a motorola hex format file
						; from the selected input device. Sets 'C' if record
						; was NOT an end of file record.
MON09_LOAD	JMP	LOAD			;Selects AUX input, and downloads entire motorola hex
						; format file. Prints '.' for every record received.
MON09_DISASS	JMP	DISASS			;Disassembles opcode pointed to by Y, and placed  the
						; disasembler output text in memory pointed to by U.
						; disassembler output text ends with carriage return.
						; Y is left pointing to next opcode in memory.
MON09_STEP	JMP	STEP			;Steps one instruction, from address in saved program
						; counter. All saved registers are updated.
MON09_STEPDI	JMP	STEPDI			;Same as above, except  disassembled  instruction  is
						; Displayed.
MON09_DISREG	JMP	DISREG			;Displays all of the saved registers.
MON09_MONITOR	JMP	MONITOR			;Reenters the monitor.
MON09_RESET	JMP	RESET			;Reinitializes the monitor via RESET.
;===============================================================================
;*
;* INITIALIZATIONS.
;*
RESET
	LDS	#STACK		SET UP STACK
	LDX	#SWIADR		POINT TO START
CLRRAM				;CLEAR MON09 DATA AREA
	CLR	,X+		CLEAR IT
	CMPX	#INSRAM		AT BUFFER?
	BLO	CLRRAM		KEEP GOING

	;INIT ACIA1
	LDX	#SER1		GET SERIAL PORT 1
	STX	>UART1		SET IT UP
	LBSR	INIT		INITIALIZE IT

	;INIT ACIA2
	LDX	#SER2		GET SERIAL PORT 2
	STX	>UART2		SET IT UP
	LBSR	INIT		INITIALIZE IT

	;INIT I/O CONFIG FLAG
	LDA	#3		DEFAULT I/O CONFIGURATION
	STA	IOCON		SET IT

	;INIT SHADOW STACK
	LDD	#RAM		DEFAULT STACK AT TOP OF RAM
	STD	SAVS		SAVE IT

	;INIT SHADOW CONDITION REGISTER
	LDA	#$D0		SET CC
	STA	SAVCC		SAVE IT

;MODS BY JQ
 IFNE JQ_NMIRAM			JQ NMI ENHANCEMENTS
	LDD	#NMIHND		SET DEFAULT NMI HANDLER
	STD	NMIADR		SAVE IT
 ENDC				JQ NMI ENHANCEMENTS
;
 IFNE JQ_ILLOP			JQ ILLOP ENHANCEMENTS
	LDD	#ILOPHND	SET DEFAULT ILLOP HANDLER
	STD	ILOPADR		SAVE IT
 ENDC				JQ ILLOP ENHANCEMENTS
;
;* Emit the sign-on message
MONITOR
	; Emit the first part of the sign-on message
	LBSR	WRMSG		OUTPUT MESSAGE
	FCB	$0A,$0D
	FCC	'MON09 Version '
	FCB	VERSION/10+$30,'.',VERSION%10+$30
	FCB	$0D,$0A

;	INCLUDE A DATE OF BUILD STRING
	INCLUDE datestring.asm

	FCB	$0D,$0A
	FCC	'(C)1985-2007 Dave Dunfield'
	FCB	$0A,$0D
	FCC	'Modifications (C)2021 Johnny Quest'
	FCB	$0A,$0D
	FCC	' Modified for the HB63C09M By Z80Dad'
;	FCB	$0A,$0D,$FF
	FCB	$FF
;
;------------------------------------------------------------
 IFNE JQ_DETMCU		JQ MCU DETECTION
; Added by JQ - Determine MCU and send message string
;* Determine whether processor is 6309 or 6809
;* Returns Z clear if 6309, set if 6809
; ADD MISSING PC to PULS line from (Burke & Burke)
DET309:
	LDX	#NOT6809	POINT TO 6309 STRING
	PSHS	D		SAVE D REGISTER
	FDB	$1043		6309 COMD INSRUCTION (COMA on 6809)
	CMPB	1,S		NOT EQUAL IF 6309
	PULS	D,PC	RESTORE D REGISTER
	BNE	MONITOR1	BRANCH IF 6309 DETECTED
	LDX	#MOT6809	MODIFY POINTER TO 6809 STRING
;
MONITOR1
	JSR		MON09_WRLIN		EMIT THE STRING
;	LDMD	#$01				SET 6309 NATIVE MODE
	BRA		MONITOR2		CONTINUE SIGN-ON MESSAGE
;
MOT6809
	FCC		' MCU:     MC6809'
	FCB		$0A,$0D,0
NOT6809
	FCC		' MCU:     HD6309'
	FCB		$0A,$0D,0
 ENDC				JQ MCU DETECTION
;------------------------------------------------------------
;
MONITOR2
	; Emit the rest of the sign-on message
	LBSR	WRMSG				OUTPUT MESSAGE
;	FCC	' UART(s): 6850 ACIA'
	FCC	' UART(s): ATMEGA32A 68B50 Wrapper'
	FCB	$0A,$0D
;MODS BY JQ
 IFNE JQ_NMIRAM					JQ NMI ENHANCEMENTS
	FCC	' Enabled: NMI Trapping'
	FCB	$0A,$0D
 ENDC						JQ NMI ENHANCEMENTS
 IFNE JQ_ILLOP					JQ ILLOP ENHANCEMENTS
	FCC	' Enabled: 6309 ILLOP & DIV0 Trapping'
	FCB	$0A,$0D
 ENDC						JQ ILLOP ENHANCEMENTS
 IFNE JQ_EEPROM					JQ EEPROM ENHANCEMENTS
	FCC	' Enabled: EEPROM Write'
	FCB	$0A,$0D
 ENDC						JQ EEPROM ENHANCEMENTS
;
	FCC	'All rights & remedies reserved.'
	FCB	$0A,$FF

MAIN
	LDS	#STACK				FIX STACK IN CASE ERROR
	LBSR	WRMSG				OUTPUT MESSAGE
	FCN		'* '
	LBSR	GETECH				GET CHARACTER
	CLRB					INDICATE NO SECOND CHAR
;* LOOK FOR COMMAND IN TABLE
LOOKC
	LDX	#CMDTAB		POINT TO COMMAND TABLE
	CLR	TEMP		INDICATE NO PARTIAL MATCH
LOOK1
	CMPD	,X++		DOES IT MATCH
	BEQ	LOOK3		YES IT DOES
	CMPA	-2,X		DOES FIRST CHAR MATCH?
	BNE	LOOK2		NO, DON'T RECORD
	DEC	TEMP		SET FLAG
LOOK2
	LEAX	2,X		ADVANCE TO NEXT
	TST	,X		HAVE WE HIT THE END
	BNE	LOOK1		NO, KEEP LOOKING
	TSTB			ALREADY HAVE TWO CHARS?
	BNE	ERROR		YES, ERROR
	LDB	TEMP		ANY PARTIAL MATCHES?
	BEQ	ERROR		NO, ERROR
	TFR	A,B		SAVE CHAR IN 'A'
	LBSR	GETECH		GET NEXT CHAR
	EXG	A,B		SWAP BACK
	BRA	LOOKC		AND CONTINUE
;* COMMAND WAS FOUND, EXECUTE IT
LOOK3
	LBSR	SPACE		OUTPUT SPACE
	JSR	[,X]		EXECUTE COMMAND
	BRA	MAIN		AND RETURN
;* ERROR HAS OCCURED
ERROR
	LBSR	WRMSG		OUTPUT MESSAGE
	FCC	' ?'
	FCB	$FF
	BRA	MAIN		TRY AGAIN
;* COMMAND LOOKUP TABLE
CMDTAB
	FCB	'D','M'		DISPLAY MEMORY
	FDB	MEMORY
	FCB	'D','D'		DISASSEMBLE
	FDB	DISASM
	FCB	'D','R'		DISPLAY REGISTERS
	FDB	DISREG
	FCB	'D','B'		VIEW BREAKPOINTS
	FDB	DSPBRK
	FCB	'D','V'		DISPLAY VECTORS
	FDB	DISVEC
	FCB	'D','U'		DISPLAY UARTS
	FDB	DISURT
	FCB	'C','R'		CHANGE REGISTER
	FDB	CHGREG
	FCB	'C','V'		CHANGE VECTORS
	FDB	CHGVEC
	FCB	'C','U'		CHANGE UARTS
	FDB	CHGURT		DO IT
	FCB	'E',0		SUBSTITUTE MEMORY
	FDB	SUBMEM
 IFNE JQ_JMPMOD		JQ JUMP MODULE ENHANCEMENTS
	FCB	'J','B'		JUMP TO FP BASIC MODULE
	FDB	JUMPFPBAS
;	FCB	'J','T'		JUMP TO TINYBASIC MODULE
;	FDB	JUMPTNYBAS
;	FCB	'J','F'		JUMP TO FORTH MODULE
;	FDB	JUMPFORTH
 ENDC			JQ JUMP MODULE ENHANCEMENTS
;
	FCB	'L',0		DOWNLOAD
	FDB	LOAD
	FCB	'B',0		SET BREAKPOINT
	FDB	SETBRK
	FCB	'S',0		STEP
	FDB	GOSTEP
	FCB	'G',0		GO
	FDB	GOEXEC
	FCB	'T',0		TRANSPARENT MODE
	FDB	TMODE
	FCB	'F','M'		FILL MEMORY
	FDB	FILMEM
	FCB	'R','R'		REPEATING READ
	FDB	RDLOOP
	FCB	'R','W'		REPEATING WRITE
	FDB	WRLOOP
	FCB	'M','T'		MEMORY TEST
	FDB	RAMTEST
	FCB	'W',0		WRITE MEMORY
	FDB	WRIMEM
	FCB	'M','M'		MOVE MEMORY
	FDB	MOVMEM
	FCB	'X','R'		REPEATING 16 BIT READ
	FDB	XRLOOP
	FCB	'X','W'		REPEATING 16 BIT WRITE
	FDB	XWLOOP
	FCB	'+',0		HEX ADDITION
	FDB	HEXADD
	FCB	'-',0		HEX SUBTRACTION
	FDB	HEXSUB
	FCB	'?',0		HELP COMMAND
	FDB	HELP
	FCB	0		MARK END OF TABLE

;MODS BY JQ, MODIFIED FOR HB63C09
;******************************************************************************
;* 'J' - JUMP TO MODULE
;******************************************************************************
 IFNE JQ_JMPMOD		JQ JUMP TO MODULES
;==============================================
JUMPFPBAS
	LDX	#FPBASMSG	POINT TO MESSAGE START
	LBSR	WRLIN		OUTPUT A MESSAGE

	JMP	FPBASSTRT	JUMP TO BASIC COLD START

	LBRA	LFCR		NEW LINE AND RETURN TO MON09 PROMPT

FPBASMSG
	FCB	$0D,$0A
	FCC	'Booting MS FP BASIC...'
	FCB	$0D,$0A
	FCB	$FF			END OF TABLE
;
;==============================================
;JUMPTNYBAS
;	LDX		#TNYBASMSG	POINT TO MESSAGE START
;	LBSR	WRLIN		OUTPUT A MESSAGE

;	JMP		TNYBASSTRT	JUMP TO FORTH COLD START

;	LBRA	LFCR		NEW LINE AND RETURN TO MON09 PROMPT

;TNYBASMSG
;	FCB		$0D,$0A
;	FCC		'Booting TinyBASIC...'
;	FCB		$0D,$0A
;	FCB		$FF			END OF TABLE

;==============================================
; Load Forth into RAM.
;INTERNAL MOVMEM ROUTINE: IMAGE START IN X, IMAGE END IN D, DESTINATION
;  START ADDRESS IN Y.
;JUMPFORTH
; IFNE JQ_EFORTH			IF USING EFORTH
;	LDX		#FTHIMGSTRT	START ADDRESS OF FORTH IMAGE IN ROM
;	LDY		#FORTHCOLD	DESTINATION ADDRESS IN RAM
;	LDD		#FTHIMGEND	END ADDRESS OF FORTH IMAGE IN ROM
;	STD		TEMP		MOVE TO VARIABLE

;JMPFTH1
;	LDA		,X+			GET SOURCE BYTE
;	STA		,Y+			SAVE IN DEST
;	CMPX	TEMP		SAVE IT
;	BLS		JMPFTH1		KEEP MOVING
 ;ENDC					IF USING EFORTH

;	LDX		#FTHBTMSG	POINT TO MESSAGE START
;	LBSR	WRLIN		OUTPUT A MESSAGE

;	JSR		FORTHCOLD	EXECUTE A CALL TO FORTH COLD START

;	LBRA	LFCR		NEW LINE AND RETURN TO MON09 PROMPT

;FTHBTMSG
;	FCB		$0D,$0A
;	FCC		'Booting FORTH...'
;	FCB		$0D,$0A
;	FCB		$FF			END OF TABLE

 ENDC				JQ JUMP TO MODULES
;
;******************************************************************************
;* 'F' - FILL MEMORY
;******************************************************************************
FILMEM
	LBSR	GETRNG		GET ADDRESSES
;MODS BY JQ
	CMPD	#RAM-1		START OF MON09 DATA?
	BLE	FILL1		NO, ADDRESS OKAY
	LDD	#RAM-1		STOP AT MON09 DATA-1
;
FILL1
	STD	TEMP		SAVE IT
	LBSR	SPACE		SPACE OVER
	LBSR	GETBYT		GET DATA BYTE
	LBNE	ERROR		INVALID
FILL2
	STA	,X+			WRITE IT
	CMPX	TEMP		ARE WE THERE
	BLS	FILL2		NO, KEEP GOING
	LBRA	LFCR		NEW LINE
;
;******************************************************************************
* 'MM' - MOVE MEMORY
;******************************************************************************
MOVMEM
 IFNE 0		FOR TESTING
	JMP	$2000
 ELSE
	LBSR	GETRNG		GET A RANGE
	STD	TEMP		SAVE LAST VALUE
	LBSR	SPACE		SEPERATOR
	LBSR	GETADR		GET DEST ADDRESS
	TFR	D,Y		SET IT UP

MOVM1
	LDA	,X+		GET SOURCE BYTE
	STA	,Y+		SAVE IN DEST
	CMPX	TEMP		SAVE IT
	BLS	MOVM1		KEEP MOVEING
	LBRA	LFCR		NEW LINE

;  IFNE JQ_EEPROM		JQ EEPROM WRITE ENHANCEMENTS
;  ENDC				JQ EEPROM WRITE ENHANCEMENTS
 ENDC		FOR TESTING
;
;******************************************************************************
;* 'DM' - DISPLAY MEMORY
;   FIX FOR 'LOOP' BUG - MOVE START ADDRESS TO BEGINING OF 16 BYTE BOUNDRY
;   CHECK TO SEE IF WE'VE LOOPED PAST FFFF AT THE END. THIS MAY DISPLAY MORE 
;   BYTES THEN REQUESTED, HOWEVER IT WILL STOP AT FFFF - DC 3.31.24
;******************************************************************************
MEMORY
 IFNE 0		FOR TESTING
	JMP		$1000
 ELSE

	LBSR	GETRNG		; GET ADDRESS
	STD	TEMP		; SAVE
			
MEM1
	LBSR	LFCR		; NEW LINE
	LBSR	CHKCHR		; CHECK FOR CHAR
	LBEQ	MAIN		; ESCAPE, QUIT
	TFR	X,D		; GET ADDRESS
	ANDD	#$FFF0		; CLEAR THE LOWER 4 BITS 
	TFR	D,X		; UPDATE X TO FIX BIT READ OUT 
	PSHS	D		; SAVE FOR LATER
	LBSR	WRDOUT		; DISPLAY
	LDB	#16		; DISPLAY 16 TO A LINE
MEM2
	LBSR	SPACE		; OUTPUT A SPACE
	BITB	#3		; ON A BOUNDARY?
	BNE	MEM3		; NO, SPACE
	LBSR	SPACE		; EXTRA SPACE
MEM3
	LDA	,X+		; GET BYTE
	LBSR	HEXOUT		; DISPLAY
	DECB			; REDUCE COUNT
	BNE	MEM2		; CONTINUE
	LDB	#4		; FOUR SPACES
MEM4
	LBSR	SPACE		; DISPLAY A SPACE
	DECB			; REDUCE COUNT
	BNE	MEM4		; CONTINUE
	PULS	X		; RESTORE D TO X
	LDB	#16		; COUNT OF 16
MEM5
	LDA	,X+		; GET CHAR
	CMPA	#' '		; <SPACE
	BLO	MEM6		; CONVERT TO DOT
	CMPA	#$7F		; PRINTABLE?
	BLO	MEM7		; OK TO DISPLAY
MEM6
	LDA	#'.'		; CHANGE TO DOT
MEM7
	LBSR	PUTCHR		; OUTPUT
	DECB			; REDUCE COUNT
	BNE	MEM5		; DISPLAY THEM ALL
	CMPX	#0		; DID WE WRAP AROUND?
	BEQ	MEM8		; YES, WE NEED TO SKIP 
	CMPX	TEMP		; PAST END?
	BLS	MEM1		; NO, KEEP GOING
MEM8
	LBRA	LFCR		; NEW LINE
 ENDC				; FOR TESTING


;*
;* 'W' - WRITE TO MEMORY
;*
WRIMEM
	LBSR	GETADR		GET ADDRESS
	TFR	D,X		SET IT UP
	LBSR	SPACE		STEP OVER
	LBSR	GETBYT		GET BYTE
	STA	,X		WRITE TO MEMORY
	LBRA	LFCR		NEW LINE
;*
;* 'E' - EDIT MEMORY
;*
SUBMEM
	LBSR	GETADR		GET ADDRESS
	TFR	D,X		COPY
SUBM1
	LBSR	LFCR		NEW LINE
	TFR	X,D		GET ADDRESS
	LBSR	WRDOUT		OUTPUT
	LDB	#8		NEW COUNT
SUBM2
	LBSR	SPACE		SEPERATOR
	LDA	,X		GET BYTE
	LBSR	HEXOUT		DISPLAY
	LDA	#'-'		PROMPT
	LBSR	PUTCHR		OUTPUT
	LBSR	GETBYT		GET A BYTE
	BNE	SUBM4		INVALID
	STA	,X		RESAVE
SUBM3
	LEAX	1,X		ADVANCE
	DECB			REDUCE COUNT
	BNE	SUBM2		MORE, CONTINUE
	BRA	SUBM1		NEW LINE
SUBM4
	CMPA	#$0D		CR?
	LBEQ	LFCR		IF SO, QUIT
	CMPA	#' '		SPACE?
	BNE	SUBM5		NO
	LBSR	SPACE		FILL FOR TWO DIGITS
	BRA	SUBM3		ADVANCE
SUBM5
	CMPA	#$08		BACKSPACE?
	LBNE	ERROR		INVALID
	LEAX	-1,X		BACKUP
	BRA	SUBM1		NEW LINE
;*
;* 'DI' - DISASSEMBLE
;*
DISASM
	LBSR	GETRNG		GET ADDRESS
	STD	TEMP		SAVE
	TFR	X,Y		COPY TO Y
	LBSR	LFCR		NEW LINE
	LDU	#DSPBUF		POINT TO INPUT BUFFER
DISS1
	LBSR	DISASS		DISASSEMBLE
	TFR	U,X		COPY
	LBSR	WRLIN		OUTPUT
	LBSR	CHKCHR		END?
	BEQ	DISS2		YES, QUIT
	CMPY	TEMP		OVER?
	BLO	DISS1		TRY AGAIN
DISS2
	RTS
;*
;* 'DV' - DISPLAY VECTORS
;*
DISVEC
	LDX	#VECTXT		POINT TO VECTOR TEXT
	LDY	#SWIADR		POINT TO FIRST VECTOR
DISV1
	LBSR	WRLIN		OUTPUT A MESSAGE
	LDD	,Y++		GET A VECTOR
	LBSR	WRDOUT		OUTPUT VECTOR ADDRESS
	LDA	,X		MORE TEXT?
	BNE	DISV1		AND CONTINUE
	LBRA	LFCR		NEW LINE
VECTXT
	FCN		'SWI='
	FCN		' SWI2='
	FCN		' SWI3='
	FCN		' IRQ='
	FCN		' FIRQ='
;MODS BY JQ
 IFNE JQ_NMIRAM		JQ NMI ENHANCEMENTS
	FCN		' NMI='
 ENDC
 IFNE JQ_ILLOP		JQ ILLOP ENHANCEMENTS
	FCN		' ILLOP='
 ENDC
;
	FCB	0		END OF TABLE
;*
;* 'DU' DISPLAY UARTS
;*
DISURT
	LDX	#URTEXT		POINT TO TEXT
	LDY	#UART1		POINT TO UART
	BRA	DISV1		DISPLAY IT
URTEXT
	FCN	'UART1='
	FCN	' UART2='
	FCB	0
;*
;* 'CV' - CHANGE VECTOR
;*
CHGVEC
	LBSR	GETECH		GET CHAR & ECHO
	CMPA	#'S'		SWI?
	BNE	CHGV1		NO
	LDA	#'1'		SAME AS '1'
	BRA	CHGV5		AND CONTINUE
CHGV1
	CMPA	#'I'		IRQ?
	BNE	CHGV2		NO, ITS OK
	LDA	#'4'		CONVERT
	BRA	CHGV5		AND CONTINUE
CHGV2
	CMPA	#'F'		FIRQ?
	BNE	CHGV3		NO
	LDA	#'5'		CONVERT
	BRA	CHGV5		AND CONTINUE
CHGV3
;MODS BY JQ
 IFNE JQ_NMIRAM		USE JQ NMI ENHANCEMENTS
	CMPA	#'N'		NMI?
	BNE	CHGV4		NO
	LDA	#'6'		CONVERT
	BRA	CHGV5		AND CONTINUE
 ENDC				USE JQ NMI ENHANCEMENTS
CHGV4
 IFNE JQ_ILLOP		USE ILLOP HANDLER
	CMPA	#'L'		6309 ILLOP?
	BNE	CHGV5		NO
	LDA	#'7'		CONVERT
 ENDC				USE ILLOP HANDLER
;
CHGV5
	SUBA	#'1'		TEST IT
;---------------------
;MODS BY JQ
CHKRNG	SET	4			IRQ HANDLER MAX NUMBER
 IFNE JQ_NMIRAM		NO JQ NMI ENHANCEMENTS
CHKRNG	SET	CHKRNG+1	IRQ HANDLER MAX NUMBER
 ENDC				NO JQ NMI ENHANCEMENTS
 IFNE JQ_ILLOP		JQ ILLOP ENHANCEMENTS
CHKRNG	SET	CHKRNG+1	IRQ HANDLER MAX NUMBER
  ENDC				NO JQ ILLOP ENHANCEMENTS
;---------------------
	CMPA	#CHKRNG		CHECK RANGE
;
	LBHI	ERROR		INVALID
	LDX	#SWIADR		POINT TO IT
CHGV6
	LSLA			X2 FOR 2 BYTE ENTRIES
	LEAX	A,X		ADVANCE TO VECTOR
	LBSR	SPACE		SEPERATOR
	LBSR	GETADR		GET NEW VALUE
	STD	,X		WRITE NEW VECTOR
	LBRA	LFCR		NEW LINE & EXIT

;*
;* 'CU' - CHANGE UART ADDRESS
;*
CHGURT
	LBSR	GETECH		GET AND ECHO
	SUBA	#'1'		CONVERT
	CMPA	#1		IN RANGE?
	LBHI	ERROR		INVALID
	LDX	#UART1		POINT TO IT
	LSLA			X2 FOR 2 BYTE ENTRIES
	LEAX	A,X		ADVANCE TO IT
	LBSR	SPACE		SEPERATOR
	LBSR	GETADR		GET ADDRESS
	STD	,X		SET IT
	TFR	D,X		SET UP POINTER
	LBSR	INIT		INITIALIZE IT
	LBRA	LFCR		NEW LINE
;*
;* 'DR' - DISPLAY REGISTERS
;*
DISREG
	LDX	#REGTXT		POINT TO TEXT
	LDY	#SAVCC		POINT TO VALUE
	BSR	RSUB1		'CC='
	LBSR	WRLIN		' ['
	LDU	#CCBITS		POINT TO BIT TABLE
	LDB	-1,Y		GET BITS BACK
	PSHS	Y		SAVE POINTER
	LDY	#8		EIGHT BITS IN BYTE
REGB1
	LDA	,U+		GET BIT IDENTIFIER
	ASLB			IS IT SET?
	BCS	RBITS		YES, DISPLAY IT
	LDA	#'-'		NO, DISPLAY DASH
RBITS
	LBSR	PUTCHR		OUTPUT A CHARACTER
	LEAY	-1,Y		REDUCE COUNT
	BNE	REGB1		MORE TO GO
	PULS	Y		RESTORE Y
	BSR	RSUB1		'] A='
	BSR	RSUB1		' B='
	BSR	RSUB1		' DP='
	BSR	RSUB2		' X='
	BSR	RSUB2		' Y='
	BSR	RSUB2		' U='
	BSR	RSUB2		' PC='
	BSR	RSUB2		' S='
	LBRA	LFCR		QUIT

;* DISPLAY 8 BIT REGISTER VALUE
RSUB1
	LBSR	WRLIN		OUTPUT BYTE VALUE
	LDA	,Y+		GET REGISTER VALUE
	LBRA	HEXOUT		OUTPUT IN HEX
;* DISPLAY 16 BIT REGISTER VALUE
RSUB2
	LBSR	WRLIN		OUTPUT WORD VALUE
	LDD	,Y++		GET REGISTER VALUE
	LBRA	WRDOUT		OUTPUT IN HEX

;* TABLE OF TEXT FOR REGISTER DISPLAY
REGTXT
	FCN	'CC='
	FCN	' ['
	FCN	'] A='
	FCN	' B='
	FCN	' DP='
	FCN	' X='
	FCN	' Y='
	FCN	' U='
	FCN	' PC='
	FCN	' S='
;* TABLE OF CONDITION CODE BIT MEANINGS
CCBITS
	FCC	'EFHINZVC'
;*
;* 'CR' - CHANGE REGISTER
;*
;* TABLE OF REGISTER NAMES
CHGTAB
	FCN	'CABDXYUPS'
;
CHGREG
	LBSR	GETECH		GET OPERAND
	CMPA	#' '		A+B?
	BEQ	CHG4		YES
	LDX	#CHGTAB		POINT TO TABLE
	CLRB			ZERO INDICATOR
CHG1
	CMPA	,X		IS THIS IT?
	BEQ	CHG2		YES
	INCB			ADVANCE COUNT
	TST	,X+		END OF TABLE
	BNE	CHG1		NO, KEEP TRYING
	LBRA	ERROR		INDICATE ERROR
CHG2
	LBSR	SPACE		OUTPUT SPACE
	LDX	#SAVCC		POINT TO START OF REGISTERS

;MODS BY JQ - CORRECT INDEX TO 16-BIT REG D
;	CMPB	#4		16 BIT?
	CMPB	#3		16 BIT?
;-----------
	BHS	R16		YES
	LEAX	B,X		OFFSET TO ADDRESS
	LBSR	GETBYT		GET NEW VALUE
	LBNE	ERROR		INVALID
	STA	,X		SAVE IN REGISTER
	BRA	CHG3		AND QUIT
CHG4
	LBSR	WRMSG		OUTPUT MESSAGE
	FCN	'[AB] '
;MODS BY JQ - UNNEEDED SPACE
;	LBSR	SPACE		OUTPUT SPACE
;-----------
	LDX	#SAVA		POINT TO 'D'
	BRA	R17		MAKE LIKE 16 BIT REG
R16
;MODS BY JQ - CORRECT INDEX TO 16-BIT REG D
;	LEAX	4,X		OFFSET TO 16 BIT REGISTERS
	LEAX	3,X		OFFSET TO 16 BIT REGISTERS
;-----------
	SUBB	#4		CONVERT TO ZERO ORIGIN
	LSLB			DOUBLE FOR WORD VALUES
	LEAX	B,X		MOVE TO CORRECT OFFSET
R17
	LBSR	GETADR		GET WORD VALUE
	STD	,X		SET REGISTER VALUE
CHG3
	LBRA	LFCR		QUIT
;*
;* 'DB' - DISPLAY BREAKPOINTS
;*
DSPBRK
	LDA	#'0'		START WITH BRKPT ZERO
	LDX	#BRKTAB		POINT TO TABLE
DSPB1
	PSHS	A		SAVE NUMBER
	LDA	#'B'		PRECEDE WITH 'B'
	LBSR	PUTCHR		OUTPUT
	LDA	,S		GET NUMBER BACK
	LBSR	PUTCHR		OUTPUT
	LDA	#'='		AND FOLLOW WITH '='
	LBSR	PUTCHR		OUTPUT
	LDD	,X++		GET VALUE
	BNE	DSPB2		NON-ZERO, DISPLAY
	LBSR	WRMSG		OUTPUT MESSAGE INSTEAD
	FCN	'****'
	BRA	DSPB3		CONTINUE
DSPB2
	LBSR	WRDOUT		OUTPUT VALUE
DSPB3
	LBSR	SPACE		SEPERATE WITH SPACE
	LEAX	1,X		SKIP OPCODE SAVE
	PULS	A		RESTORE NUMBER
	INCA			ADVANCE
	CMPA	#'8'		BEYOND END?
	BLO	DSPB1		NO, CONTINUE
	LBRA	LFCR		NEW LINE AND QUIT
;*
;* 'B' - SET BREAKPOINT
;*
SETBRK
	LBSR	GETECH		GET CHARACTER
	SUBA	#'0'		CONVERT TO NUMBER
	CMPA	#8		IN RANGE?
	LBHS	ERROR		NO, QUIT
	PSHS	A		SAVE NUMBER
	LSLA			DOUBLE FOR 16 BIT VALUES
	ADDA	,S+		TRIPLE FOR OPCODE BYTE
	LDX	#BRKTAB		POINT TO BREAKPOINT TABLE
	LEAX	A,X		ADVANCE TO BREAKPOINT
	LBSR	SPACE		SEPERATE WITH SPACE
	LBSR	GETADR		GET VALUE
	STD	,X		SAVE IN TABLE
	LBRA	LFCR		NEW LINE AND QUIT
;*
;* 'S' - SINGLE STEP
;*
GOSTEP
	LBSR	GETPC		GET ADDRESS
	LBSR	LFCR		OUTPUT MESSAGE
GOSTP1
	LBSR	STEPDI		STEP AND DISPLAY INSTRUCTION
	TST	STPFLG		DISPLAY REGISTERS?
	BMI	NODSR		NO, DON'T DISPLAY
STPREG
	LBSR	DISREG		DISPLAY REGISTERS
NODSR
	LBSR	GETCHR		GET KEY FROM TERMINAL
	CMPA	#'?'		DISPLAY REGS?
	BEQ	STPREG		IF SO, DISPLAY
	CMPA	#' '		STEP TO NEXT?
	BEQ	GOSTP1		IF SO, STEP
	CMPA	#$1B		EXIT STEPPING?
	BEQ	GOSTP2		IF SO, QUIT
	CMPA	#$0D		TOGGLE REGISTER DISPLAY?
	BNE	NODSR		IF NOT, IGNORE
	COM	STPFLG		TOGGLE DISPLAY FLAG
	BRA	NODSR		GET NEXT KEY
GOSTP2
	RTS
;*
;* 'G' - GO (EXECUTE)
;*
GOEXEC
	LBSR	GETPC		GET ADDRESS
	LBSR	LFCR		NEW LINE

;*	STEP ONE INST. BEFORE INSERTING BREAKPOINTS, SO THAT BREAKPOINTS
;*	CAN BE USED WITHIN LOOPS ETC.

	LBSR	STEP		STEP ONE INSTRUCTION

;*	INSERT BREAKPOINTS
	LDX	#BRKTAB		POINT TO BREAKPOINT TABLE
	LDB	#8		EIGHT BREAKPOINTS
GOEX3
	LDY	,X++		GET BREAKPOINT ADDRESS
	BEQ	GOEX4		NO BREAKPOINT, QUIT
	LDA	,Y		GET OPCODE
	STA	,X		SAVE IN TABLE
	LDA	#$3F		GET 'SWI' BREAKPOINT OPCODE
	STA	,Y		SAVE IN CODE SPACE
GOEX4
	LEAX	1,X		ADVANCE TO NEXT IN TABLE
	DECB			REDUCE COUNT OF BRKPTS
	BNE	GOEX3		DO ALL EIGHT
	LDS	SAVS		RESTORE STACK POINTER
	LDA	SAVCC		GET SAVED CC
	LDB	SAVDP		GET SAVED DPR
	PSHS	A,B		SAVE ON STACK FOR LAST RESTORE
	LDD	SAVA		RESTORE A, B REGISTERS
	LDX	SAVX		RESTORE X REGISTER
	LDY	SAVY		RESTORE Y REGISTER
	LDU	SAVU		RESTORE U REGISTER
	PULS	CC,DP		RESTORE CC + DP
	JMP	[SAVPC]		EXECUTE USER PGM
;*
;* 'RR' - REPEATING READ
;*
RDLOOP
	LBSR	GETADR		GET ADDRESS
	TFR	D,X		SET UP 'X'
	LBSR	LFCR		NEW LINE
RDLP1
	LDA	,X		READ LOCATION
	LBSR	CHKCHR		ABORT?
	BNE	RDLP1		NO, ITS OK
	RTS
;*
;* 'RW' - REPEATING WRITE
;*
WRLOOP
	LBSR	GETADR		GET ADDRESS
	TFR	D,X		SET UP 'X'
	LBSR	SPACE		SPACE OVER
	LBSR	GETBYT		GET DATA
	LBNE	ERROR		INVALID
	PSHS	A		SAVE ACCA
	LBSR	LFCR		NEW LINE
WRLP1
	LDA	,S		GET CHAR
	STA	,X		WRITE IT OUT
	LBSR	CHKCHR		ABORT COMMAND?
	BNE	WRLP1		CONTINUE
	PULS	A,PC		GO HOME
;*
;* 'XR' - REPEATING 16 BIT READ
;*
XRLOOP
	LBSR	GETADR		GET ADDRESS
	TFR	D,X		SET UP 'X'
	LBSR	LFCR		NEW LINE
XRLP1
	LDD	,X		READ LOCATION
	LBSR	CHKCHR		ABORT?
	BNE	XRLP1		NO, ITS OK
	RTS
;*
;* 'XW' - REPEATING 16 BITWRITE
;*
XWLOOP
	LBSR	GETADR		GET ADDRESS
	TFR	D,X		SET UP 'X'
	LBSR	SPACE		SPACE OVER
	LBSR	GETADR		GET DATA
	PSHS	A,B		SAVE ACCA
	LBSR	LFCR		NEW LINE
XWLP1
	LDD	,S		GET CHAR
	STD	,X		WRITE IT OUT
	LBSR	CHKCHR		ABORT COMMAND?
	BNE	XWLP1		CONTINUE
	PULS	A,B,PC		GO HOME
;*
;* 'MT' - MEMORY TEST
;*
RAMTEST	LBSR	GETRNG		GET ADDRESS RANGE
	STD	TEMP		SAVE ENDING ADDRESS
	LDD	#-1		BEGIN WITH NEGATIVE 1
	STD	DSPBUF		SAVE PASS COUNT
	LBSR	LFCR		NEW LINE
	TFR	X,Y		COPY STARTING ADDRESS
RAM0	CLR	,X+		ZAP ONE BYTE
	CMPX	TEMP		ARE WE OVER?
	BLS	RAM0		NO, CLEAR EM ALL
RAM1	TFR	Y,X		RESET STARTING ADDRESS
	LDA	#$0D		GET CR
	LBSR	PUTCHR		BACK TO START OF LINE
	LBSR	WRMSG		OUTPUT MESSAGE
	FCN	'Pass: '
	LDD	DSPBUF		GET COUNTER
	ADDD	#1		ADVANCE PASS COUNT
	STD	DSPBUF		RESAVE
	LBSR	WRDOUT		OUTPUT
	LBSR	SPACE		SPACE OVER
RAM2	LBSR	CHKCHR		CHARACTER READY?
	BEQ	RAM5		ESCAPE, QUIT & RESTART MONITOR
	LDB	DSPBUF+1	GET EXPECTED VALUE
	CMPB	,X		DID IT KEEP ITS VALUE
	BNE	RAM7		NO, ERROR
	LDA	#%00000001	FIRST DATA VALUE
RAM3	STA	,X		RESAVE IT
	CMPA	,X		SAME ?
	BNE	RAM6		FAILED
	LSLA			SHIFT THE BIT
	BNE	RAM3		CONTINUE TILL ALL DONE
RAM4	INCB			ADVANCE TO NEXT VALUE
	STB	,X+		SAVE REGISTER
	CMPX	TEMP		ARE WE IN RANGE?
	BLS	RAM2		YES, ITS OK
	BRA	RAM1		AND RESTART
RAM5	LBSR	LFCR		NEW LINE
	LBRA	MAIN		AND RESTART MONITOR
;* VERIFY OF LOCATION FAILED
RAM6	PSHS	A		SAVE VALUE WRITTEN
	LBSR	WRMSG		OUTPUT MESSAGE
	FCN		'Addr: '
	TFR	X,D		GET ADDRESS
	LBSR	WRDOUT		OUTPUT
	LBSR	WRMSG		OUTPUT MESSAGE
	FCN		', Wrote: '
	PULS	A		RESTORE VALUE
	LBSR	HEXOUT		OUTPUT
	LBSR	WRMSG		OUTPUT MESSAGE
	FCN		', Read: '
	LDA	,X		GET VALUE READ
	BRA	RAM8		CONTINUE
;* DATA WAS CORRUPTED BY OTHER WRITES
RAM7	LBSR	WRMSG		OUTPUT MESSAGE
	FCN		'Addr: '
	TFR	X,D		GET ADDR
	LBSR	WRDOUT		OUTPUT
	LBSR	WRMSG		OUTPUT MESSAGE
	FCN		', Expected: '
	LDA	DSPBUF+1	GET VALUE
	LBSR	HEXOUT		OUTPUT
	LBSR	WRMSG		OUTPUT MESSAGE
	FCN		', Read: '
	LDA	,X		GET VALUE BACK
RAM8	LBSR	HEXOUT		OUTPUT VALUE
	LBSR	LFCR		NEW LINE
	LDB	DSPBUF+1	GET CORRECT NEXT VALUE
	LBRA	RAM4
;*
;* '+' - HEXIDECIMAL ADDITION
;*
HEXADD
	LBSR	GETADR		GET FIRST VALUE
	PSHS	A,B		SAVE IT
	LDA	#'+'		PLUS SIGN
	LBSR	PUTCHR		DISPLAY
	LBSR	GETADR		GET SECOND VALUE
	ADDD	,S		PERFORM ADDITION
	BRA	HEXSHO		DISPLAY IT
;*
;* '-' - HEXIDECIMAL SUBTRACTION
;*
HEXSUB
	LBSR	GETADR		GET FIRST
	PSHS	A,B		SAVE IT
	LDA	#'-'		MINUS SIGN
	LBSR	PUTCHR		DISPLAY
	LBSR	GETADR		GET SECOND ADDRESS
	PSHS	A,B		SAVE IT
	LDD	2,S		GET FIRST VALUE
	SUBD	,S++		PERFORM SUBTRACTION
HEXSHO
	STD	,S		SAVE RESULT
	LDA	#'='		EQUALS SIGN
	LBSR	PUTCHR		DISPLAY
	PULS	A,B		RESTORE RESULT
	LBSR	WRDOUT		OUTPUT
	LBRA	LFCR		NEW LINE & RETURN
;*
;* '?' - HELP COMMAND
;*
HELP
	LDX	#HTEXT		POINT TO HELP TEXT
HLP1
	LDB	#25		COLUMN COUNTER
HLP2
	LDA	,X+		GET CHAR FROM TEXT
	BEQ	HLP4		EXIT THIS LINE
	CMPA	#'|'		SEPERATOR?
	BEQ	HLP3		YES, EXIT
	LBSR	PUTCHR		OUTPUT
	DECB			BACKUP
	BRA	HLP2		NEXT
HLP3
	LBSR	SPACE		OUTPUT SPACE
	DECB			REDUCE COUNT
	BNE	HLP3		KEEP GOING
	LBSR	WRMSG		OUTPUT MESSAGE
	FCN	'- '		SEPERATOR
	BRA	HLP2		AND CONTINUE
HLP4
	LBSR	LFCR		NEW LINE
	LBSR	CHKCHR		TEST FOR CHARACTER ENTERED
	BEQ	HLP5		IF SO, EXIT
	LDA	,X		IS THIS THE END?
	BPL	HLP1		NO, KEEP GOING
HLP5
	RTS

;******************************************************************************
;* 'T' - TRANSPARENT MODE
;******************************************************************************
TMODE	EQU	*		TERMINAL ROUTINE
TM1
	LDX	>UART1		POINT TO MAIN UART
TM2
	LBSR	READ		TEST FOR CHAR FROM TERMINAL
	BNE	TM3		NONE, IGNORE
	CMPA	#$1B		ESCAPE?
	LBEQ	LFCR		NEW LINE, AND RETURN
	LDX	>UART2		POINT TO UART 2
	LBSR	WRITE		OUTPUT TO AUX PORT
TM3
	LDX	>UART2		POINT TO UART 2
	LBSR	READ		TEST FOR CHAR FROM AUX
	BNE	TM1		NONE, IGNORE
	LDX	>UART1		POINT TO UART 1
	LBSR	WRITE		OUTPUT TO TERMINAL
	BRA	TM2		GET NEXT CHAR

;******************************************************************************
;* 'L' - LOAD
;* FIXED LEAD OUT BEING ECHOED (MOSTLY)  4/4/23 DC
;******************************************************************************
LOAD
	LDA	IOCON			; GET I/O CONFIG
	PSHS	A			; SAVE
	LBSR	LFCR			; NEW LINE
DLO1
	CLR	IOCON			: INDICATE NO OUTPUT, READ UART
	BSR	DLOAD			; DOWNLOAD RECORD
	BCC	DLO2			; END
	LDA	,S			; GET OLD I/O CONFIG
	STA	IOCON			; RESET
	LDA	#'.'  			; GET DOT
	LBSR	PUTCHR			; OUTPUT
	BRA	DLO1			; CONTINUE
DLO2
	PULS	A			; RESTORE A
	STA	IOCON			; SAVE
	LBRA	LFCR			; New line & return
;
;* Download a record in either MOTOROLA or INTEL hex format
DLOAD
	LBSR	GETCHR			; Get a character
	CMPA	#':'			; Start of INTEL record?
	LBEQ	DLINT			; Yes, download INTEL
	CMPA	#'S'			; Start of MOTOROLA record?
	BNE	DLOAD			; No, keep looking
;
;* Download a record in MOTOROLA hex format
DLMOT
	LBSR	GETCHR			; GET NEXT CHAR
	CMPA	#'0'			; HEADER RECORD?
	BEQ	DLOAD			; SKIP IT
	CMPA	#'5'			; COUNT RECORD?
	BEQ	DLOAD			; SKIP IT	
	CMPA	#'9'			; END OF FILE?
	BEQ	DLMEOF			; END OF FILE
	CMPA	#'1'			; DATA RECORD?
	BNE	LODERR			; LOAD ERROR
	LBSR	GETBYT			; GET LENGTH
	BNE	LODERR			; Report error
	STA	TEMP			; START CHECKSUM
	SUBA	#3			; CONVERT
	STA	TEMP+1			; Set length
	LBSR	GETBYT			; Get first byte of address
	BNE	LODERR			; Report error
	TFR	A,B			; Save for later
	ADDA	TEMP			; Include in checksum
	STA	TEMP			; Resave
	LBSR	GETBYT			; Get next byte of address
	BNE	LODERR			; Report error
	EXG	A,B			; Swap
	TFR	D,X			; Set pointer
	ADDB	TEMP			; Include in checksum
	STB	TEMP			; Resave checksum
DLMOT1
	LBSR	GETBYT			; Get a data byte
	STA	,X+			; Save in RAM
	ADDA	TEMP			; Include checksum
	STA	TEMP			; Resave
	DEC	TEMP+1			; Reduce length
	BNE	DLMOT1 			; Do them all
	LBSR	GETBYT			; Get a byte
	ADDA	TEMP			; Add computed checksum
	INCA				; Test for success
	BEQ	DLRTS			; Download OK
;
;* Error occured on loading
LODERR
	LDA	#3			; GET DEFAULT I/O
	STA	IOCON			; SET I/O
	LBSR	WRMSG			; OUTPUT
	FCC	' ?Load error'		
	FCB	$FF
	LBRA	MAIN			; BACK FOR COMMAND

;* Read out the end of the file (simply reads until buffer is empty)
DLMEOF
	LBSR 	GETCHR			; load a character
	CMPA  	#$0A			; LF?
	BEQ	DLEOF			; WE ARE DONE
	CMPA	#$0D			; CR? (JUST INCASE?)
	BEQ	DLEOF			; WE ARE DONE
	BRA	DLMEOF			; WE ARE NOT DONE

;
;* Return indicating another record
DLRTS
	ORCC	#$01			; SET 'C' FLAG
DLEOF
	RTS				; RETURN TO CALLER

;
;* Download record in INTEL format
DLINT
	LBSR	GETBYT			; Get count
	BNE	LODERR			; Report error
	STA	TEMP			; Start checksum
	STA	TEMP+1			; Record length
	CMPA	#0			; Test & clear C
	BEQ	DLMEOF			; End of file
;* Get address
	LBSR	GETBYT			; Get first byte of address
	BNE	LODERR			; Report error
	TFR	A,B			; Save for later
	ADDA	TEMP			; Include in checksum
	STA	TEMP			; Resave
	LBSR	GETBYT			; Get next byte of address
	BNE	LODERR			; Report error
	EXG	A,B			; Swap
	TFR	D,X			; Set pointer
	ADDB	TEMP			; Include in checksum
	STB	TEMP			; Resave checksum
;* Get record type
	LBSR	GETBYT			; Get type value
	BNE	LODERR			; Report error
	ADDA	TEMP			; Include checksum
	STA	TEMP			; Resave checksum
;* Get data bytes
DLINT1
	LBSR	GETBYT			; Get data byte
	BNE	LODERR			; Report error
	STA	,X+			; Write to memory
	ADDA	TEMP			; Include checksum
	STA	TEMP			; Resave checksum
	DEC	TEMP+1			; Reduce length
	BNE	DLINT1			; Do them all
;* Get checksum
	JSR	GETBYT			; Read a byte
	LBNE	LODERR			; Report error
	ADDA	TEMP			; Include checksum
	BEQ	DLRTS			; Report success
	LBRA	LODERR			; Report failure

;*
;* GETS AN ADDRESS, DEFAULTS TO (PC)
;*
GETPC
	BSR	GETAD1		Get address
	BEQ	GETPC1		Normal data
	CMPA	#' '		Space?
	BNE	GETERR		Report error
	LBSR	WRMSG		Output message
	FCN	'->'		Display address
	LDD	SAVPC		Get PC value
	LBRA	WRDOUT		Display
GETPC1
	STD	SAVPC		Set new PC
	RTS
;*
;* GETS A RANGE OF ADDRESS, RETURNS WITH START IN X, END IN D
;*
GETRNG
	BSR	GETADR		Get first address
	TFR	D,X		Save in X
	LDA	#','		Separator
	LBSR	PUTCHR		Display
	BSR	GETAD1		Get second address
	BEQ	DLEOF		Normal data
	CMPA	#' '		Space?
	BNE	GETERR		No, report error
	LBSR	WRMSG		Output message
	FCN	'FFFF'
	LDD	#$FFFF		Assume top of RAM
	RTS
;*
;* GETS AN ADDRESS (IN D) FROM THE INPUT DEVICE
;*
GETADR
	BSR	GETAD1		Get word value
	BEQ	GETAD2		Its OK
GETERR
	LBRA	ERROR		Report error
;* Get word value without error checking
GETAD1
	BSR	GETBYT		Get HIGH byte
	BNE	GETAD3		Test for special register
	TFR	A,B		Copy for later
	BSR	GETBYT		Get LOW byte
	BNE	GETERR		Report error
	EXG	A,B		Correct order
GETAD2
	RTS
;* Handle special register names
GETAD3
	PSHS	X		Save X
	LDX	SAVX		Assume X
	CMPA	#'X'		Is it X?
	BEQ	GETAD4		Yes
	LDX	SAVY		Assume Y
	CMPA	#'Y'		Is it Y?
	BEQ	GETAD4		Yes
	LDX	SAVU		Assume U
	CMPA	#'U'		Is it U?
	BEQ	GETAD4		Yes
	LDX	SAVX		Assume S
	CMPA	#'S'		Is it S?
	BEQ	GETAD4		Yes
	LDX	SAVPC		Assume PC?
	CMPA	#'P'		Is it PC?
	BNE	GETAD5		No, error
GETAD4
	LDA	#'='		Separator
	LBSR	PUTCHR		Echo it
	TFR	X,D		D = value
	BSR	WRDOUT		Display it
	CLRA			Set 'Z'
	TFR	X,D		Get value back
GETAD5
	PULS	X,PC		Restore & return

;*
;* GETS A SINGLE BYTE (IN HEX) FROM THE INPUT DEVICE
;*
GETBYT
	BSR	GETNIB		Get FIRST nibble
	BNE	GETB3		Invalid, test for quote
	LSLA			Rotate
	LSLA			into
	LSLA			high
	LSLA			nibble
	PSHS	A		Save for later
	BSR	GETNIB		Get SECOND nibble
	BNE	GETB2		Report error
	ORA	,S		Include high
GETB4
	ORCC	#$04		Indicate success (SET 'Z')
GETB2
	LEAS	1,S		Skip saved value
GETB1
	RTS
GETB3
	CMPA	#$27		Single quote?
	BNE	GETB1		No, abort
	LBSR	GETCHR		Get ASCII character
	LBSR	PUTCHR		Echo on terminal
	ORCC	#$04		Indicate success (SET 'Z')
	RTS


;*
;* GETS A SINGLE HEX NIBBLE FROM THE INPUT DEVICE
;*
GETNIB
	LBSR	GETECH		Get character
	SUBA	#'0'		Convert numbers
	CMPA	#9		Numeric?
	BLS	GETN1		Yes, OK
	SUBA	#7		Convert alphas
	CMPA	#$A		Under?
	BLO	GETN2		Yer, error
	CMPA	#$F		Over?
	BHI	GETN2		Yes, error
GETN1
	ORCC	#$04		SET 'Z' FLAG, INDICATE OK
	RTS
GETN2
	ADDA	#$37		Normalize character + clear Z
	RTS
;*
;* OUTPUT A WORD (IN HEX) FROM REGISTER D
;*
WRDOUT
	BSR	HEXOUT		Output first byte
	TFR	B,A		Get second byte
;*
;* OUTPUT A BYTE (IN HEX) FROM REGISTER A
;*
HEXOUT
	PSHS	A		Save low nibble
	LSRA			Rotate
	LSRA			upper nibble
	LSRA			into
	LSRA			lower nibble
	BSR	HOUT		Output high nibble
	PULS	A		Restore low nibble
;*
;* OUTPUT A NIBBLE (IN HEX) FROM REGISTER A
;*
HOUT
	ANDA	#$0F		Remove upper half
	ADDA	#'0'		Convert to printable
	CMPA	#'9'		In range?
	BLS	HOUT1		Yes, display
	ADDA	#7		Convert to alpha
HOUT1
	BRA	PUTCHR		Output character

;******************************************************************************
;* WRITE ERROR MESSAGE FOLLOWING TEXT
;******************************************************************************
WRMSG	PSHS	X		SAVE X
	LDX	2,S		GET OLD PC
	BSR	WRLIN		OUTPUT LINE
	STX	2,S		UPDATE OLD PC
	PULS	X,PC		RESTORE X, RETURN

;******************************************************************************
;* DISPLAY MESSAGE(X)
;******************************************************************************
WRLIN
	LDA	,X+		GET CHAR FROM MESSAGE
	BEQ	WRLND		END, QUIT
	CMPA	#$FF		NEWLINE END, LFCR & EXIT
	BEQ	LFCR		IF SO, NEW LINE, RETURN
	BSR	PUTCHR		OUTPUT TO TERM
	BRA	WRLIN		KEEP GOING
WRLND
	RTS

;******************************************************************************
;* GET CHAR. FROM TERMINAL, AND ECHO
;******************************************************************************
GETECH
	BSR	GETCHR		GET CHARACTER
	CMPA	#' '		SPACE?
	BLS	WRLND		IF < DON'T DISPLAY
	CMPA	#$61		LOWER CASE?
	BLO	PUTCHR		OK
	ANDA	#$5F		CONVERT TO UPPER
	BRA	PUTCHR		ECHO

;******************************************************************************
;* DISPLAY A SPACE ON THE TERMINAL
;******************************************************************************
SPACE
	PSHS	A		SAVE A
	LDA	#' '		GET SPACE
	BRA	LFC1		DISLAY AND GO HOME

;******************************************************************************
;* DISPLAY LINE-FEED, CARRIAGE RETURN ON TERMINAL
;******************************************************************************
LFCR
	PSHS	A			SAVE
	LDA	#$0A			GET LF
	BSR	PUTCHR			OUTPUT
	LDA	#$0D			GET CR
LFC1
	BSR	PUTCHR			OUTPUT
	PULS	A,PC			RESTORE AND GO HOME

;******************************************************************************
;* READ A CHARACTER FROM SELECTED INPUT DEVICE
;******************************************************************************
GETCHR
	PSHS	X			SAVE 'X'
	LDX	>UART1			POINT TO CONSOLE
	LDA	IOCON			GET I/O CONFIG
	LSRA				SHIFT TO CARRY
	BCS	GETC1			READ FROM UART
	LDX	>UART2			POINT TO AUX UART
GETC1
	LBSR	READ			READ TERMINAL
	BNE	GETC1			KEEP TRYING
	PULS	X,PC

;******************************************************************************
;* WRITE A CHARACTER TO ALL ENABLED OUTPUT DEVICES
;******************************************************************************
PUTCHR
	PSHS	A,B,X			SAVE REGS
	LDB	IOCON			GET I/O CONFIG
	BITB	#2			WRITE TO TERM?
	BEQ	PUT1			NO, TRY UART
	LDX	>UART1			POINT TO UART1
	LBSR	WRITE			OUTPUT TO TERMINAL
PUT1
	LDB	IOCON			INCASE CORRUPTED
	BITB	#4			WRITE TO UART?
	BEQ	PUT2			NO, SKIP IT
	LDX	>UART2			POINT TO UART2
	LBSR	WRITE			OUTPUT TO UART
PUT2
	PULS	A,B,X,PC		RESTORE AND GO HOME

;******************************************************************************
;* CHECK FOR <ESC> FROM TERMINAL. ALSO PERFORM <SPACE>, <CR>
;* SCREEN OUTPUT FLOW CONTROL.
;******************************************************************************
CHKCHR
	PSHS	X			SAVE PTR
	LDX	>UART1			POINT TO CONSOLE UART
	LDB	IOCON			GET I/O CONFIG
	BMI	CHKC1			ALREADY HELD
	LBSR	READ			READ TERMINAL
	CMPA	#' '			SPACE?
	BNE	CHKC3			NO, IGNORE IT
CHKC1
	ORB	#%10000000		SET HELD BIT
	LBSR	READ			GET KEY FROM CONSOLE
	CMPA	#' '			SPACE?
	BEQ	CHKC2			YES, ALLOW
	ANDB	#%01111111		DISABLE HELD BIT
	CMPA	#$0D			CARRIAGE RETURN?
	BEQ	CHKC2			ALLOW
	CMPA	#$1B			ESCAPE?
	BNE	CHKC1			NO, IGNORE
CHKC2
	STB	IOCON			RESAVE I/O CONFIG BYTE
CHKC3
	CMPA	#$1B			TEST FOR ESCAPE CHARACTER
	PULS	X,PC

;******************************************************************************
;* STEP ONE INSTRUCTION
;******************************************************************************
STEPDI
	LDY	SAVPC			GET PC
	LDU	#DSPBUF			GET INPUT BUFFER
	LBSR	DISASS			DISPLAY
	TFR	U,X			POINT TO IT
	LBSR	WRLIN			DISPLAY
	BRA	STEPCE			AND PERFORM STEP

;******************************************************************************
;* STEP WITHOUT DISPLAYING INSTRUCTION
;******************************************************************************
STEP	LDY	SAVPC		GET PROGRAM COUNTER
	LDU	#DSPBUF		POINT TO FREE RAM FOR DISASEMBLY OUTPUT
	LBSR	DISASS		PERFORM DISASSEMBLY
STEPCE	STY	SAVPC		SAVE NEW PC
	LDU	PTRSAV		GET POINTER BACK
	LDD	,U+		GET OPCODE
;* TEST FOR LONG CONDITIONAL BRANCHES
LCBRAN	CMPA	#$10		PREFIX?
	BNE	LOBRAN		NO, GOT FOR IT
	LDB	,U		GET OPCODE
	CMPB	#$22		IN RANGE?
	BLO	LOBRAN		NO
	CMPB	#$2F		IN RANGE?
	BHI	LOBRAN		NO
	LDA	,U+		GET OPCOIDE BYTE
	LBSR	TSTCON		TEST CONDITIONAL
	BEQ	LBRAN1		YES, DO IT
	RTS
;* TEST FOR LONG BRANCHES
LOBRAN	CMPA	#$16		IS IT LBRA?
	BNE	LBRANS		NO, TRY LBSR
LBRAN1	LDD	,U++		GET OFFSET
	LEAX	D,U		PERFORM BRANCH
	BRA	SAVNPC		SAVE NEW PC
;* TEST FOR LONG BRANCH TO SUB
LBRANS	CMPA	#$17		'LBSR'?
	BNE	SCOBRA		NO, TRY SHORT CONDITIONALS
	LDD	,U++		GET OFFSET
	LEAX	D,U		SET UP ADDRESS
	BRA	SAVSTK
;* TEST FOR SHORT CONDITIONAL BRANCHES
SCOBRA	CMPA	#$22		< 'BHI'?
	BLO	SHBRAN		NO, TRY SHORT BRANCHES
	CMPA	#$2F		> 'BLE'?
	BHI	SHBRAN		NO, TRY SHORT BRANCHES
	LBSR	TSTCON		SEE OF CONDITIONAL IS OK
	BEQ	SBRAN1		YES, DO IT
	RTS
;* TEST FOR SHORT BRANCHES
SHBRAN	CMPA	#$20		SHORT BRANCH?
	BNE	SBRANS		NO, TRY SHORT BRANCH TO SUB
SBRAN1	LDB	,U+		GET OFFSET
	LEAX	B,U		EMULATE JUMP
	BRA	SAVNPC		SAVE NEW PC
;* TEST FOR SHORT BRANCH TO SUBROUTINE
SBRANS	CMPA	#$8D		'BSR'?
	BNE	TSTTFR		NO, TRY TRANSFER
	LDB	,U+		GET OFFSET
	LEAX	B,U		PERFORM BRANCH
SAVSTK	LDY	SAVS		GET STACK POINTER
	STU	,--Y		PUSH ADDRESS
	STY	SAVS		RESAVE
SAVNPC	STX	SAVPC		SAVE IT
	RTS
;* TEST FOR TRANSFER
TSTTFR	CMPA	#$1F		TRANSFER?
	BNE	TSTEXG		NO, TRY EXCHANGE
	BSR	LOKREG		LOOKUP REGISTER
	RTS
;* LOOKUP REGISTER, AND SIMULATE IF PC XFER OR EXCHANGE
LOKREG	LDA	,U		GET POSTBYTE
	ANDA	#$0F		REMOVE HIGH REGISTER
	CMPA	#5		IS IT PC?
	BNE	LOK1		NO, IT'S OK TO EXECUTE
	LDA	,U		GET REG POSTBYTE BACK
	LSRA			SHIFT
	LSRA			HIGH REGISTER
	LSRA			TO LOW (LEAVE X 2)
LOK2	LDX	#TFREGT		POINT TO TABLE
	ANDA	#$0F		INSURE WE GET VALID REG
	LDX	A,X		GET ADDRESS OF VARIABLE
	LDD	,X		GET REGISTER VALUE
	BRA	STDPC		SAVE IT
LOK1	LEAS	2,S		SKIP LAST CALL
	LBRA	NOREXE		EXECUTE NORMAL INSTRUCTION
;* TEST FOR EXCHANGE
TSTEXG	CMPA	#$1E		IS IT EXCHANGE
	BNE	TSTRTS		NO, TRY RTS
	LDY	SAVPC		GET OLD PC VALUE
	LDA	,U		GET REGISTER
	ANDA	#$F0		USE HIGH ONLY
	CMPA	#$50		IS PC FIRST?
	BNE	TSTE1		NO, SKIP
	LDA	,U		GET REG BACK
	LSLA			DOUBLE
	BSR	LOK2		GET ADDRESS OF REG TO SWAP WITH
	BRA	TSTE2		PERFORM MOVE TO PC
TSTE1	BSR	LOKREG		GET REGISTER SEE IF PC IS LOW REGISTER
TSTE2	STY	,X		SAVE PC IN REGISTER
	RTS
;* TEST FOR 'RTS' INSTRUCTIONS
TSTRTS	CMPA	#$39		IS IT 'RTS'
	BNE	TPULS		NO, TRY PULS
	LDU	SAVS		POINT TO STACK
	PULU	A,B		GET DATA
	STU	SAVS		RESAVE SP
STDPC	STD	SAVPC
	RTS
;* TEST FOR 'PULS' INSTRUCTION
TPULS	CMPA	#$35		PULLING FROM S?
	BNE	TPULU		NO, TRY PULU
	LDX	SAVS		GET SAVED 'S' REG
	LDY	#PULSTAB	POINT TO TABLE
	BSR	DOPUL		PERFORM PULL
	STX	SAVS		RESAVE NEW 'S' REGISTER
	RTS
;* TEST FOR A 'PULU' INSTRUCTION
TPULU	CMPA	#$37		IS IT 'PULU'?
	BNE	JSREXT		NO, TRY JSR EXTENDED
	LDX	SAVU		GET SAVED 'U'
	LDY	#PULUTAB	POINT TO TABLE
	BSR	DOPUL		PERFORM PULL
	STX	SAVU		RESAVE 'S'
	RTS
;* PERFORM PUL OPERATIONS
DOPUL	LDA	,U		GET POSTBYTE
	LDB	#4		TEST FOR FIRST FOUR BITS (8 BIT REG)
DOPUL1	DECB			DECREMENT COUNT
	LSRA			SHIFT
	BCC	DOPUL2		NOTHING, GO AGAIN
	PSHS	A,B		SAVE REGS
	TSTB			ARE WE INTO 16 BITS?
	BMI	PUL16		YES, PERFORM 16 BITS
	LDA	,X+		PULL A BYTE
	STA	[,Y++]		SAVE IN REGISTER
	BRA	DOPUL3		GO AGAIN
PUL16	LDD	,X++		GET 16 BIT VALUE
	STD	[,Y++]		SAVE IN REGISTER
DOPUL3	PULS	A,B		RESTORE
	BRA	DOPUL1		CONTINUE
DOPUL2	LEAY	2,Y		ADVANCE
	TSTA			ARE WE CONE
	BNE	DOPUL1		CONTINUE
	RTS
;* TEST FOR 'JSR' EXTENDED
JSREXT	CMPA	#$BD		IS IT EXTENDED JSR
	BNE	JMPEXT		NO, TRY JUMP EXTENDED
	BSR	DJMPEX		FAKE JUMP
	BRA	PSHPC		SAVE PC
;* TEST FOR 'JMP' EXTENDED
JMPEXT	CMPA	#$7E		IS IT JMP EXTENDED?
	BNE	JSRDIR		NO, TRY JMP DIRECT
DJMPEX	LDD	,U++		GET ADDRESS
	BRA	STDPC		SAVE IT
;* TEST FOR 'JSR' DIRECT
JSRDIR	CMPA	#$9D		'JSR' DIRECT PAGE?
	BNE	JMPDIR		NO, TRY JUMP
	BSR	DJMPDI		DO IT
	BRA	PSHPC		SAVE PC
;* TEST FOR 'JMP' DIRECT PAGE
JMPDIR	CMPA	#$0E		IS IT JUMP DIRECT PAGE?
	BNE	JSRIND		NO, TRY JUMP INDEXED
DJMPDI	LDB	,U+		GET LOW ADDRESS
	LDA	SAVDP		GET DIRECT PAGE
	BRA	STDPC		SAVE IT
;* TEST FOR 'JSR' INDEXED
JSRIND	CMPA	#$AD		IS IT 'JSR' INDEXED?
	BNE	JMPIND		NO, TRY NEXT
	BSR	DJMPIN		DO IT
PSHPC	LDX	SAVS		GET ADDRESS
	STU	,--X		SAVE
	STX	SAVS		RESAVE
	RTS
;* TEST FOR 'JMP' INDEXED
JMPIND	CMPA	#$6E		IS IT JUMP INDEXED?
	LBNE	NOREXE		NO, NON-TRANSFER INSTRUCTION
;* FIRST POINT Y AT REGISTER INVOLVED
DJMPIN	LDA	,U+		GET POSTBYTE
	PSHS	A		SAVE IT
	ANDA	#%01100000	SAVE ONLY REGISTER
	LSRA			CONVERT
	LSRA			REGISTER
	LSRA			INTO INDEX VALUE
	LSRA			SHIFT IT OVER
	LDX	#INDTAB		POINT TO TABLE
	LDY	A,X		GET REGISTER ADDRESS
	STY	TEMP		SAVE FOR INC/DEC
	LDY	,Y		GET REGISTER CONTENTS
	LDA	,S		GET POSTBYTE BACK
	BMI	NOT5BO		NOT A FIVE BIT OFFSET
;* FIVE BIT REGISTER OFFSET
	ANDA	#%00011111	SAVE ONLY OFFSET
	CMPA	#%00010000	NEGATIVE?
	BLO	SINOK		NO, IT'S OK
	ORA	#%11100000	CONVERT TO NEGATIVE
SINOK	LEAX	A,Y		GET ADDRESS
	BRA	XSAVPC		SAVE IT
;* TEST FOR NO OFFSET
NOT5BO	ANDA	#%10001111	REMOVE REGISTER & INDIRECT BIT
	CMPA	#$84		NO OFFSET?
	BNE	TOFF8		NO, TRY OFFSET OF 8
	TFR	Y,X		COPY
	BRA	XSAVPC		SAVE IT
;* TEST FOR EIGHT BIT OFFSET
TOFF8	CMPA	#$88		8 BIT OFSET?
	BNE	TOFF16		NO, TRY 16 BIT OFFSET
	LDB	,U+		GET OFFSET
	BRA	BSAVOF		GO FOR IT
;* TEST FOR 16 BIT OFFSET
TOFF16	CMPA	#$89		16 BIT OFFSET?
	BNE	TOFFA		TRY A ACCUMULATOR OFFSET
	LDD	,U+		GET OFFSET
	LEAX	D,Y		DO IT
	BRA	XSAVPC		SAVE IT
;* TEST FOR ACCA OFFSET
TOFFA	CMPA	#$86		OFFSET BY ACCA
	BNE	TOFFB		NO, TRY B
	LDB	SAVA		GET ACCA
	BRA	BSAVOF		SAVE IT
;* TEST FOR ACCB OFFSET
TOFFB	CMPA	#$85		B OFFSET
	BNE	TOFFD		NO, TRY D OFFSET
	LDB	SAVB		GET B
BSAVOF	LEAX	B,Y		DO OFFSET
	BRA	XSAVPC		SAVE IT
;* TEST FOR ACCD OFFSET
TOFFD	CMPA	#$8B		IS IT D OFFSET?
	BNE	TAINC1		NO, TRY AUTO INC
	LDD	SAVA		GET D ACCUMULATOR
	LEAX	D,Y		DO IT
	BRA	XSAVPC		SAVE IT
;* TEST FOR AUTO INCREMENT
TAINC1	CMPA	#$80		AUTO INC BY 1?
	BNE	TAINC2		NO, TRY AUTO INC BY 2
	LEAX	,Y+		GET ADDRESS
	BRA	RSVREG		RESAVE REGISTER
;* TEST FOR DOUBLE AUTO INCREMENT
TAINC2	CMPA	#$81		AUTO INC BY 1?
	BNE	TADEC1		NO, TRY AUTO DEC
	LEAX	,Y++		GET ADDRESS
	BRA	RSVREG		RESAVE REGISTER
;* TEST FOR AUTO DECREMENT
TADEC1	CMPA	#$82		AUTO DEC?
	BNE	TADEC2		NO, TRY AUTO DEC BY TWO
	LEAX	,-Y		GET ADDRESS
	BRA	RSVREG		RESAVE REGISTER
;* TEST FOR DOUBLE AUTO DECREMENT
TADEC2	CMPA	#$83		DOUBLE AUTO DEC.
	BNE	TPCO8		NO, TRY PC OFFSET
	LEAX	,--Y		GET OFFSET
RSVREG	STY	[TEMP]		RESAVE REGISTER CONTENTS
XSAVPC	BRA	SAVXPC		SAVE NEW PC
;* TEST FOR EIGHT BIT OFFSET FROM PCR
TPCO8	CMPA	#$8C		8 BIT PC RELATIVE?
	BNE	TPCO16		NO, TRY 16 BIT PC RELATIVE
	LDB	,U+		GET BYTE
	LEAX	B,U		OFFSET IT
	BRA	SAVXPC		RESAVE PC
;* TEST FOR 16 BIT OFFSET FROM PCR
TPCO16	CMPA	#$8D		16 BIT OFFSET
	BNE	TEIND		NO, TRY EXTENDED INDIRECT
	LDD	,U++		GET VALUE
	LEAX	D,U		POINT TO NEW LOCATION
	BRA	SAVXPC		RESAVE
;* EXTENDED ADDRESSING VIA INDEXED POSTBYTE
TEIND	LDX	,U++		GET ADDRESS
;* SET SAVED PC TO CALCULATED ADDRESS (IN 'X').
;* CHECK FOR & PERFORM INDIRECTION IF REQUIRED
SAVXPC	PULS	A		RESTORE POSTBYTE
	BITA	#%00010000	INDIRECT ADDRESSING?
	BEQ	NINXIN		NOT INDIRECT
	LDX	,X		PERFORM A LEVEL OF INDIRECTION
NINXIN	STX	SAVPC		SAVE IT
	RTS
;* NORMAL EXECUTABLE INSTRUCTION, COPY IT INTO OUR RAM, THEN EXECUTE IT
NOREXE	LEAU	-1,U		BACKUP TO INSTRUCTION
	LDX	#INSRAM		POINT TO RAM FOR INSTRUCTION
;* COPY INSTRUCTION INTO RAM
NORE1	CMPU	SAVPC		ARE WE THERE
	BHS	NORE2		END OF INSTRUCTION
	LDA	,U+		GET DATA
	STA	,X+		SAVE IN RAM
	BRA	NORE1		CONTINUE
;* INSERT A JUMP AFTER IT
NORE2	LDA	#$7E		GET 'JMP' EXTENDED INSTRUCTION
	STA	,X+		SAVE IT
	LDD	#NORE3		POINT AT ADDRESS TO JUMP TO
	STD	,X		SAVE IT
	STS	TEMP		SAVE SP
	LDS	SAVS		RESTORE STACK POINTER
	LDA	SAVCC		GET CC
	LDB	SAVDP		GET DP
	PSHS	A,B		SAVE CC AND DP
	LDD	SAVA		RESTORE A, B
	LDX	SAVX		RESTORE X
	LDY	SAVY		RESTORE Y
	LDU	SAVU		RESTORE U
	PULS	CC,DP		RESTORE CC AND DP
	JMP	INSRAM		EXECUTE INSTRUCTION
;* INSTRUCTION SHOULD RETURN TO HERE
NORE3	PSHS	CC,DP		SAVE REGS
	STD	SAVA		SAVE REGS
	STX	SAVX		SAVE X
	STY	SAVY		SAVE Y
	STU	SAVU		SAVE U
	PULS	A,B		GET REGS BACK
	STA	SAVCC		SAVE CC
	STB	SAVDP		SAVE DP
	STS	SAVS		SAVE STACK POINTER
	LDS	TEMP		RESTORE OUR STACK
	RTS
;*
;* SUBROUTINE TO EVALUATE CONDITIONAL BRANCH OPCODES, AND DETERMINE
;* IF THEY ARE TO BE EXECUTED
;*
TSTCON	LDB	#3		TEST FOR THREE CONDITIONALS
	CMPA	#$2F		IS IT 'BLE'?
	BNE	TSTC0		NO, ITS NORMAL
	LDB	#6		HANDLE WRETCHED 'BLE' CASE
TSTC0	SUBA	#$22		CONVERT OPCODE TO SIMPLE INDEX
	LSLA			ROTATE..
	LSLA			TWICE FOR FOUR BYTE ENTRIES
	LDX	#CONTAB		POINT TO TABLE
	LEAX	A,X		ADVANCE TO TABLE ENTRY
	LDA	SAVCC		GET CONDITION CODES
	ANDA	,X+		MASK OUT NON-APPLICABLE ONES
TSTC1	CMPA	,X+		DOES IT MATCH?
	BEQ	TSTC2		IT'S OK
	DECB			REDUCE COUNT
	BNE	TSTC1		CONTINUE
	LDA	#255		INDICATE CONDITIONAL NOT MET
	RTS
TSTC2	CLRA			INDICATE CONDITIONAL MET
	RTS
;*
;* DISASSEMBLE OPCODE POINTED TO BY Y. PLACE IN OUTPUT BUFFER POINTED TO BY U
;*
DISASS	STY	PTRSAV		SAVE INSTRUCTION POINTER
	PSHS	U		SAVE INST POINTER
	LDD	#$2000+26	GET SPACE+NUMBER OF BYTES TO CLEAR
DISA1	STA	,U+		SET A SPACE
	DECB			REDUCE COUNT
	BNE	DISA1		CONTINUE
	LDX	#OPTAB1		POINT TO GENERAL OPCODE TABLE
	LDA	,Y		GET DATA BYTE
	CMPA	#$10		PREFIX BYTE?
	BEQ	SETOP2		NEW TABLE
	CMPA	#$11		OTHER PREFIX BYTE
	BNE	OPFIND		NO, IT'S OK
	LDX	#OPTAB3		POINT TO THIRD TABLE
	BRA	OPFNXT		OK
SETOP2	LDX	#OPTAB2		POINT TO SECOND OPERAND TABLE
OPFNXT	LEAY	1,Y		SKIP PREFIX BYTE
;* LOOK FOR OPCODE IN TABLE
OPFIND	LDA	,X+		GET BYTE FROM TABLE
	CMPA	,Y		IS THIS IT?
	BEQ	FNDOPC		FOUND IT
	CMPA	#$CF		END OF TABLE?
	BEQ	BADOPC		IF SO, FAKE AN OPCODE
	LEAX	2,X		ADVANCE
	BRA	OPFIND		KEEP LOOKING
BADOPC	LDY	PTRSAV		INSURE WE ARE AT BEGINNING
;* LOCATED OPCODE, GENERATE STRING
FNDOPC	LEAY	1,Y		SKIP TO POSTBYTE
	LDA	,X+		GET DATA
	STA	INSTYP		SAVE FOR LATER
	LDB	,X		GET INSTRUCTION NUMBER
	LDA	#4		FOUR BYTES/ENTRY
	MUL			CALCULATE ENTRY OFFSET
	LDX	#ITABLE		POINT TO INSTRUCTION TABLE
	LEAX	D,X		ADVANCE TO IT
	LDB	#4		SIZE OF INSTRIUCTION FIELD
FNDO1	LDA	,X+		GET CHAR
	STA	,U+		SAVE IN OUTPUT
	DECB			MOVE FOUR CHARACTERS
	BNE	FNDO1		CONTINUE
FNDO2	LDA	INSTYP		GET TYPE BITS BACK
	ANDA	#$0F		REMOVE CRAP
	LBEQ	ENDIS		NO OPERANDS
;* INSERT SPACES FOR OPERAND
	LDB	#' '		GET A SPACE
	STB	,U+		SAVE IN OUTPUT
	STB	,U+		SAVE IN OUTPUT
	DECA			IS 8 BIT IT IMMEDIATE?
	BNE	IMM16		NO, TRY 16 BIT IMMEDIATE
;* EIGHT BIT IMMEDIATE ADDRESSING OPERAND
IMM8	LDA	#'#'		INDICATE IMMEDIATE
	STA	,U+		SAVE IT
	BRA	OP8		QUIT
;* SIXTEEN BIT IMMEDIATE ADDRESSING
IMM16	DECA			IS THIS IT?
	BNE	DIRECT		NO, TRY DIRECT
	LDA	#'#'		INDICATE IMMEDIATE
	STA	,U+		SAVE IT
	BRA	OP16		16 BIT OPERAND
;* DIRECT PAGE ADDRESSING
DIRECT	DECA			IS THIS IT?
	BNE	EXTEND		NO, TRY EXTENDED
	LDA	#'<'		INDICATE DIRECT
	STA	,U+		SAVE IT
OP8	LDA	,Y+		GET OPERAND BYTE
	LBSR	WRHEXB		OUTPUT
	BRA	ENDIS1		END GO HOME
;* EXTENDED ADDRESSING
EXTEND	DECA			IS THIS IT?
	BNE	INDEX		NO, TRY INDEXED
OP16	LDD	,Y++		GET OPCODES
	LBSR	WRHEXW		OUTPUT WORD
ENDIS1	LBRA	ENDIS		GO HOME
;* INDEXED ADDRESSING MODES
INDEX	DECA			IS IT INDEXED?
	LBNE	PSHPUL		NO, TRY PUSH OR PUL
	LDA	,Y+		GET POST BYTE
	STA	POSBYT		SAVE FOR LATER
;* TEST FOR FIVE BIT OFFSET
	BMI	NO5BO		NOT A FIVE BIT OFFSET
	ANDA	#$1F		CONVERT TO POSTBYTE
	BRA	EVLX1		INSERT REGISTER AND CONTINUE
;* TEST FOR INDIRECT MODE
NO5BO	BITA	#$10		TEST FOR INDIRECT
	BEQ	NOIND		NOT INDIRECT
	LDB	#'['		GET OPENING
	STB	,U+		SAVE IN OUTPUT
;* TEST FOR NO OFFSET
NOIND	ANDA	#$8F		REMOVE REGS AND INDIRECT BIT
	CMPA	#$84		NO OFFSET?
	BEQ	INSR1		INSERT REGISTER AND EXIT
;* TEST FOR EIGHT BIT OFFSET
	CMPA	#$88		EIGHT BIT OFFSET
	BNE	EVL1		NO, TRY NEXT
	LDA	,Y+		GET BYTE OFFSET
EVLX1	LBSR	WRHEXB		OUTPUT
	BRA	INSR1		CONTINUE
;* TEST FOR 16 BIT OFFSET
EVL1	CMPA	#$89		16 BIT OFSET?
	BNE	EVL2		NO, TRY NEXT
	LDD	,Y++		GET OPERAND
	LBSR	WRHEXW		OUTPUT
	BRA	INSR1		INSERT REGISTER
;* TEST FOR A ACCUMULATOR OFFSET
EVL2	CMPA	#$86		IS IT 'A' OFFSET?
	BNE	EVL3		NO, TRY NEXT
	LDA	#'A'		GET ACCA
	BRA	SAIREG		GO HOME
;* TEST FOR B ACCUMULATOR OFFSET
EVL3	CMPA	#$85		IS IT 'B' OFFSET?
	BNE	EVL4		NO, TRY NEXT
	LDA	#'B'		GET B
	BRA	SAIREG		GO HOME
;* TEST FRO 'D' ACCUMULATOR OFFSET
EVL4	CMPA	#$8B		D OFFSET?
	BNE	EVL5		NO, TRY NEXT
	LDA	#'D'		GET D REGISTER
SAIREG	STA	,U+		SAVE IT
INSR1	BRA	INSREG
;* TEST FOR EXTENDED INDIRECT
EVL5	CMPA	#$8F		EXTENDED INDIRECT?
	BNE	EVL6		NO, TRY NEXT
	LDD	,Y++		GET OFFSET
	LBSR	WRHEXW		OUTPUT
	BRA	EVLFIN		AND CONTINUE
;* TEST FOR PC OFFSET, 8 BIT
EVL6	CMPA	#$8C		EIGHT BIT PC OFFSET?
	BNE	EVL7		NO, TRY NEXT
	LDA	,Y+		GET OFFSET
	LBSR	WRHEXB		OUTPUT
	BRA	WRPCRG		OUTPUT PC REGISTER
;* TEST FOR PC OFFSET, 16 BIT
EVL7	CMPA	#$8D		PC OFFSET?
	BNE	INSREG		NO, INSERT REGISTER
	LDD	,Y++		GET OFFSET
	LBSR	WRHEXW		OUTPUT
WRPCRG	LDX	#PCRG		POINT TO STRING
WRPR1	LDA	,X+		GET CHAR
	STA	,U+		SAVE
	CMPA	#'R'		END?
	BNE	WRPR1		NO, CONTINUE
	BRA	EVLFIN		END IT NOW
;* INSERT REGISTER BITS
INSREG	LDA	#','		GET COMMA
	STA	,U+		SAVE IT
	LDA	POSBYT		GET POSTBYTE
	LDB	#'-'		GET MINUS
	ANDA	#$8F		REMOVE CRAP
	CMPA	#$82		DECREMENT BY ONE?
	BEQ	DEC1		DECREMENT BY ONE
	CMPA	#$83		DECREMENT BY TWO?
	BNE	NODEC		NO, DON'T DEC
	STB	,U+		SAVE
DEC1	STB	,U+		AGAIN
NODEC	LDA	POSBYT		GET POSTBYTE
	LSRA			SHIFT
	LSRA			REGISTER
	LSRA			BITS
	LSRA			INTO
	LSRA			BOTTOM
	LDB	#'X'		GET 'X'
	ANDA	#$03		REMOVE CRAP
	BEQ	EVLEND		ITS 'X'
	LDB	#'Y'		GET 'Y'
	DECA			TEST FOR 'Y'
	BEQ	EVLEND		YES
	LDB	#'U'		GET 'U'
	DECA			TEST
	BEQ	EVLEND		ITS 'U'
	LDB	#'S'		MUST BE 'S'
EVLEND	STB	,U+		SAVE IN OUTPUT
EVLFIN	LDA	POSBYT		GET POSTBYTE
	LDB	#'+'		GET PLUS
	ANDA	#$8F		GET TYPE
	CMPA	#$80		IS IT INC BY ONE
	BEQ	INC1		IF SO, WE HAVE IT
	CMPA	#$81		INC BY TWO?
	BNE	NOINC		NO INCREMENT
	STB	,U+		SAVE ONE
INC1	STB	,U+		SAVE TWO
NOINC	LDA	POSBYT		GET POSTBYTE
	BPL	NOIND1		FIVE BIT OFFSET
	BITA	#$10		INDIRECT?
	BEQ	NOIND1		NO INDIRECT
	LDA	#']'		CLOSING BRACE
	STA	,U+		SAVE IT
NOIND1	LBRA	ENDIS		END IT
;* PULS OR PULL OPCODES
PSHPUL	DECA			IS IT PUSH OR PULL?
	BNE	TFREXG		NO, TRY TRANSFER OR EXCHANGE
	LDA	,Y+		GET POSTBYTE
	LDX	#PSHTAB		GET 'CC'
PSH1	LSRA			SHIFT OUT BITS
	BCC	PSHNXT		SKIP THIS ONE
	PSHS	A,B		SAVE REGS
	LDD	,X++		GET DATA
	CMPA	#'U'		SAVEING U REGISTER
	BNE	PSH4		NO, IT'S OK
	TST	INSTYP		SPECIAL CASE
	BPL	PSH4		OK
	LDA	#'S'		CONVERT
PSH4	STA	,U+		SAVE IT
	TSTB			MORE?
	BEQ	PSH2		NO, SKIP IT
	STB	,U+		SAVE
PSH2	PULS	A,B		RESTORE REGS
	TSTA			MORE BITS?
	BEQ	PSH3		NO, QUIT
	PSHS	A		RESAVE
	LDA	#','		GET COMMA
	STA	,U+		SAVE
	PULS	A		GET IT BACK
	BRA	PSH1		CONTINUE
PSHNXT	LEAX	2,X		ADVANCE
	TSTA			ARE WE OK
	BNE	PSH1		KEEP TRYING
PSH3	LBRA	ENDIS		DONE
;* TRANSFER AND EXCHANGE POSTBYTE OPCODES
TFREXG	DECA			TRANSFER OR EXCHANGE?
	BNE	SBRAN		TRY SHORT BRANCH
	LDA	,Y		GET POSTBYTE
	LSRA			SHIFT
	LSRA			INTO
	LSRA			LOW
	LSRA			NIBBLE
	BSR	TFRREG		GET REGISTER
	LDA	#','		SEPERATOR
	STA	,U+		SAVE
	LDA	,Y+		GET POSTBYTE AGAIN
	BSR	TFRREG		PLACE IT
	LBRA	ENDIS		GO HOME
;* CALCULATE TRANSFER REGISTER
TFRREG	ANDA	#$0F		REMOVE HIGH CRAP
	LSLA			MULTIPLY BY TWO
	LDX	#REGTAB		POINT TO TABLE
	LDD	A,X		GET REGISTER VALUE
	STA	,U+		SAVE IT
	TSTB			SECOND BYTE?
	BEQ	TFRET		NO, SKIP IT
	STB	,U+		SAVE IT
TFRET	RTS
;* SHORT BRANCH
SBRAN	DECA			SHORT BRANCH
	BNE	LBRAN		NO, TRY LONG BRANCH
	LDB	,Y+		GET OPERATOR
	LEAX	B,Y		GET NEW ADDRESS
	TFR	X,D		COPY
	BRA	SAVADR		FINISH
;* LONG BRANCH
LBRAN
	LDD	,Y++		GET OPERAND
	PSHS	Y		SAVE Y
	ADDD	,S++		ADD OFFSET TO REG
SAVADR
	LBSR	WRHEXW		OUTPUT WORD.
ENDIS
	LDA	#$FF		LINE TERMINATOR
	STA	,U		SAVE IT
;* INSERT ADDRESS/BYTE DATA
	LDU	,S		RESTORE U REGISTER
	PSHS	Y		SAVE POINTER TO END
	LDX	PTRSAV		POINT TO STARTING ADDRESS
	TFR	X,D		COPY
	LBSR	WRHEX		OUTPUT
	TFR	B,A		COPY
	LBSR	WRHEX		OUTPUT
	CLRB			START WITH ZERO
END1
	CMPX	,S		ARE WE AT END?
	BHS	END2		IF SO, QUIT
	INCB			ADVANCE
	LEAU	1,U		ADVANCE
	LDA	,X+		GET BYTE
	LBSR	WRHEX		OUTPUT
	BRA	END1		CONTINUE
END2
	LEAS	2,S		RESTORE STACK
	LDU	,S		RESTORE U REGISTER
	LEAU	20,U		ADVANCE TO TEXT FIELD
	LDX	PTRSAV		GET POINTER BACK
END3
	DECB			REDUCE COUNT
	BMI	END4		CONTINUE
	LDA	,X+		GO IT AGAIN
	CMPA	#' '		< SPACE?
	BLO	END5		YES
	CMPA	#$7F		> 7F?
	BLO	END6		OK
END5
	LDA	#'.'		CONVERT TO DOT
END6
	STA	,U+		SAVE
	BRA	END3
END4
	PULS	U,PC		GO HOME

;*
;* SUBROUTINES
;*
WRHEXB
	PSHS	A		SAVE IT
	LDA	#'$'		INDICATE HEX
	STA	,U+		SAVE
	BRA	WRHEX1		CONTINUE
WRHEXW
	PSHS	B		SAVE B
	LDB	#'$'		INDICATE HEX
	STB	,U+		SAVE IT
	BSR	WRHEX		OUTPUT
WRHEX1
	PULS	A		RESTORE
WRHEX
	PSHS	A		SAVE IT
	LSRA			SHIFT
	LSRA			HIGH BYTE
	LSRA			INTO
	LSRA			LOW FOR OUTPUT
	BSR	WRHEXN		OUTPUT NIBBLE
	PULS	A		RETORE
WRHEXN
	ANDA	#$0F		REMOVE CRAP
	ADDA	#$30		CONVERT
	CMPA	#$39		OK?
	BLS	WRNOK		OK
	ADDA	#7		CONVERT
WRNOK
	STA		,U+		SAVE IT
	RTS

;MODS BY JQ
;*
;* 6309 ILLOP/DIV0 HANDLER
;*
 IFNE JQ_ILLOP	USE JQ ILLOP ENHANCEMENTS
MD_DIV0		EQU	$80			MD.7 = DIV0 FLAG
MD_ILOP		EQU	$40			MD.6 = ILLOP FLAG

ILOPHND
	LDX		#SAVCC			POINT TO START OF SAVED REGS
	LDB		#12				MOVE 12 BYTES
ILOPH1
	LDA		,S+				GET BYTE
	STA		,X+				SAVE
	DECB					DECREMENT COUNT
	BNE		ILOPH1			DO THEM ALL
	STS		SAVS			SAVE STACK POINTER

;	DETERMINE TRAP SOURCE
	LDX		#MSG_DIV0		DIV0 MESSAGE POINTER
	BITMD	#MD_DIV0		Trap entry - see if Division by 0 TRAP
	BNE		ILOPH3			DIV0 TRAP

ILOPH2
	LDX		#MSG_ILLOP		ILLOP MESSAGE POINTER
	BITMD	#MD_ILOP		Trap entry - see if ILLOP TRAP
	BNE		ILOPH3			illegal instruction TRAP
	LDX		#MSG_TRAPERR	UNKNOWN TRAP SOURCE

ILOPH3
	JSR		MON09_WRLIN		EMIT THE STRING
	LBSR	DISREG			DISPLAY REGISTERS
	LBRA	MAIN			AND DO PROMPT

MSG_TRAPERR
	FCC	'*** UKNOWN Trap ***'
	FCB	$0D,$0A,0		NEW LINE

MSG_ILLOP
	FCC	'*** ILLOP Trap ***'
	FCB	$0D,$0A,0		NEW LINE

MSG_DIV0
	FCC	'*** DIV0 Trap ***'
	FCB	$0D,$0A,0		NEW LINE
 ENDC		USE JQ ILLOP ENHANCEMENTS
;
;*
;* NMI HANDLER
;*
NMIHND
	LDX	#SAVCC		POINT TO START OF SAVED REGS
	LDB	#12		MOVE 12 BYTES
NMIH1
	LDA	,S+		GET BYTE
	STA	,X+		SAVE
	DECB			DECREMENT COUNT
	BNE	NMIH1		DO THEM ALL
	STS	SAVS		SAVE STACK POINTER
	LBSR	WRMSG		DISPLAY MESSAGE
	FCC	'*** NMI Interrupt ***'
	FCB	$FF		NEW LINE
	BRA	BRKREG		DISPLAY REGISTERS

;*
;* SWI HANDLER
;*
SWIHND
	LDY	#BRKTAB		POINT TO BREAKPOINT TABLE
	LDX	10,S		GET STORED PC
	LEAX	-1,X		BACKUP TO BREAKPOINT ADDRESS
	LDB	#8		CHECK EIGHT BREAKPOINTS
SWIHN1
	CMPX	,Y		IS THIS IT?
	BEQ	SWIHN2		YES
	LEAY	3,Y		SKIP OPCODE
	DECB			REDUCE COUNT
	BNE	SWIHN1		CONTINUE
	LDB	2,S			RESTORE B.
	LDX	4,S			RESTORE X.
	LDY	6,S			RESTORE Y.
	JMP	[SWIADR]	NOT A BREAKPOINT, EXECUTE SWI HANDLER
SWIHN2
	STB	INSTYP		SAVE BREAKPOINT NUMBER
	LDX	#SAVCC		POINT TO START OF SAVED REGS
	LDB	#10			MOVE 10
SWIHN25
	LDA	,S+			GET BYTE
	STA	,X+			SAVE
	DECB				DECREMENT COUNT
	BNE	SWIHN25		DO THEM ALL
	PULS	X			GET PC
	LEAX	-1,X		SET BACK TO REAL PC
	STX	SAVPC		SAVED PC
	STS	SAVS		SAVE STACK POINTER
	LBSR	WRMSG		DISPLAY MESSAGE
	FCN	'*** Breakpoint #'
	LDA	#$38		GET NUMBER, PLUS ASCII CONVERT
	SUBA	INSTYP		CONVERT TO PROPER DIGIT
	LBSR	PUTCHR		DISPLAY
	LBSR	WRMSG		OUTPUT MESSAGE
	FCC	' ***'		TRAILING MESSAGE
	FCB	$FF			NEW LINE
BRKREG
	LBSR	DISREG		DISPLAY
BRKRES
	LDX	#BRKTAB		POINT TO BREAKPOINT TABLE
	LDB	#8			DO IT EIGHT TIMES
SWIHN3
	LDY	,X++		GET REG
	BEQ	SWIHN4		NO BRK, NEXT
	LDA	,X		GET OPCODE
	STA	,Y		REPLACE IN RAM
SWIHN4
	LEAX	1,X		SKIP OPCODE
	DECB			REDUCE COUNT
	BNE	SWIHN3		GO AGAIN
	LBRA	MAIN		DO PROMPT

;*
;* CONSTANTS
PCRG
	FCC	',PCR'

;*
;* TRANSFER/EXCHANGE REGISTER TABLE
;*
REGTAB
	FCN	'D'		0
	FCN	'X'		1
	FCN	'Y'		2
	FCN	'U'		3
	FCN	'S'		4
	FCC	'PC'		5
	FCN	'?'		6
	FCN	'?'		7
	FCN	'A'		8
	FCN	'B'		9
	FCC	'CC'		A
	FCC	'DP'		B
	FCN	'?'		C
	FCN	'?'		D
	FCN	'?'		E
	FCN	'?'		F

;*
;* PUSH/PULL REGISTER TABLE
;*
PSHTAB
	FCC	'CC'
	FCN	'A'
	FCN	'B'
	FCC	'DP'
	FCN	'X'
	FCN	'Y'
	FCN	'U'
	FCN	'PC'

;*
;* OPCODE TABLE, OPCODE BYTE, TYPE BYTE, TEXT BYTE
;*
OPTAB1
	FCB	$86,1,1		'LDA' INSTRUCTIONS
	FCB	$96,3,1
	FCB	$A6,5,1
	FCB	$B6,4,1
	FCB	$C6,1,2		'LDB' INSTRUCTIONS
	FCB	$D6,3,2
	FCB	$E6,5,2
	FCB	$F6,4,2
	FCB	$CC,2,3		'LDD' INSTRUCTIONS
	FCB	$DC,3,3
	FCB	$EC,5,3
	FCB	$FC,4,3
	FCB	$CE,2,4		'LDU' INSTRUCTIONS
	FCB	$DE,3,4
	FCB	$EE,5,4
	FCB	$FE,4,4
	FCB	$8E,2,5		'LDX' INSTRUCTIONS
	FCB	$9E,3,5
	FCB	$AE,5,5
	FCB	$BE,4,5
	FCB	$97,3,6		'STA' INSTRUCTINOS
	FCB	$A7,5,6
	FCB	$B7,4,6
	FCB	$D7,3,7		'STB' INSTRUCTIONS
	FCB	$E7,5,7
	FCB	$F7,4,7
	FCB	$DD,3,8		'STD' INSTRUCTIONS
	FCB	$ED,5,8
	FCB	$FD,4,8
	FCB	$DF,3,9		'STU' INSTRUCTIONS
	FCB	$EF,5,9
	FCB	$FF,4,9
	FCB	$9F,3,10	'STX' INSTRUCTIONS
	FCB	$AF,5,10
	FCB	$BF,4,10
	FCB	$3A,0,11	'ABX'
	FCB	$89,1,12	'ADCA'
	FCB	$99,3,12
	FCB	$A9,5,12
	FCB	$B9,4,12
	FCB	$C9,1,13	'ADCB'
	FCB	$D9,3,13
	FCB	$E9,5,13
	FCB	$F9,4,13
	FCB	$8B,1,14	'ADDA'
	FCB	$9B,3,14
	FCB	$AB,5,14
	FCB	$BB,4,14
	FCB	$CB,1,15	'ADDB'
	FCB	$DB,3,15
	FCB	$EB,5,15
	FCB	$FB,4,15
	FCB	$C3,2,16	'ADDD'
	FCB	$D3,3,16
	FCB	$E3,5,16
	FCB	$F3,4,16
	FCB	$48,0,17	'ASLA'
	FCB	$58,0,18	'ASLB'
	FCB	$08,3,19	'ASL'
	FCB	$68,5,19
	FCB	$78,4,19
	FCB	$47,0,20	'ASRA'
	FCB	$57,0,21	'ASRB'
	FCB	$07,3,22	'ASR'
	FCB	$67,5,22
	FCB	$77,4,22
	FCB	$85,1,23	'BITA'
	FCB	$95,3,23
	FCB	$A5,5,23
	FCB	$B5,4,23
	FCB	$C5,1,24	'BITB'
	FCB	$D5,3,24
	FCB	$E5,5,24
	FCB	$F5,4,24
	FCB	$4F,0,25	'CLRA'
	FCB	$5F,0,26	'CLRB'
	FCB	$0F,3,27	'CLR'
	FCB	$6F,5,27
	FCB	$7F,4,27
	FCB	$81,1,28	'CMPA'
	FCB	$91,3,28
	FCB	$A1,5,28
	FCB	$B1,4,28
	FCB	$C1,1,29	'CMPB'
	FCB	$D1,3,29
	FCB	$E1,5,29
	FCB	$F1,4,29
	FCB	$8C,2,30	'CMPX'
	FCB	$9C,3,30
	FCB	$AC,5,30
	FCB	$BC,4,30
	FCB	$43,0,31	'COMA'
	FCB	$53,0,32	'COMB'
	FCB	$03,3,33	'COM'
	FCB	$63,5,33
	FCB	$73,4,33
	FCB	$3C,1,34	'CWAI'
	FCB	$19,0,35	'DAA'
	FCB	$4A,0,36	'DECA'
	FCB	$5A,0,37	'DECB'
	FCB	$0A,3,38	'DEC'
	FCB	$6A,5,38
	FCB	$7A,4,38
	FCB	$88,1,39	'EORA'
	FCB	$98,3,39
	FCB	$A8,5,39
	FCB	$B8,4,39
	FCB	$C8,1,40	'EORB'
	FCB	$D8,3,40
	FCB	$E8,5,40
	FCB	$F8,4,40
	FCB	$1E,7,41	'EXG'
	FCB	$1F,7,42	'TFR'
	FCB	$34,6,43	'PSHS'
	FCB	$36,$86,44	'PSHU'
	FCB	$35,6,45	'PULS'
	FCB	$37,$86,46	'PULU'
	FCB	$4C,0,47	'INCA'
	FCB	$5C,0,48	'INCB'
	FCB	$0C,3,49	'INC'
	FCB	$6C,5,49
	FCB	$7C,4,49
	FCB	$0E,3,50	'JMP'
	FCB	$6E,5,50
	FCB	$7E,4,50
	FCB	$9D,3,51	'JSR'
	FCB	$AD,5,51
	FCB	$BD,4,51
	FCB	$32,5,52	'LEAS'
	FCB	$33,5,53	'LEAU'
	FCB	$30,5,54	'LEAX'
	FCB	$31,5,55	'LEAY'
	FCB	$44,0,56	'LSRA'
	FCB	$54,0,57	'LSRB'
	FCB	$04,3,58	'LSR'
	FCB	$64,5,58
	FCB	$74,4,58
	FCB	$3D,0,59	'MUL'
	FCB	$40,0,60	'NEGA'
	FCB	$50,0,61	'NEGB'
	FCB	$00,3,62	'NEG'
	FCB	$60,5,62
	FCB	$70,4,62
	FCB	$12,0,63	'NOP'
	FCB	$8A,1,64	'ORA'
	FCB	$9A,3,64
	FCB	$AA,5,64
	FCB	$BA,4,64
	FCB	$CA,1,65	'ORB'
	FCB	$DA,3,65
	FCB	$EA,5,65
	FCB	$FA,4,65
	FCB	$1A,1,66	'ORCC'
	FCB	$84,1,67	'ANDA'
	FCB	$94,3,67
	FCB	$A4,5,67
	FCB	$B4,4,67
	FCB	$C4,1,68	'ANDB'
	FCB	$D4,3,68
	FCB	$E4,5,68
	FCB	$F4,4,68
	FCB	$1C,1,69	'ANDCC'
	FCB	$49,0,70	'ROLA'
	FCB	$59,0,71	'ROLB'
	FCB	$09,3,72	'ROL'
	FCB	$69,5,72
	FCB	$79,4,72
	FCB	$46,0,73	'RORA'
	FCB	$56,0,74	'RORB'
	FCB	$06,3,75	'ROR'
	FCB	$66,5,75
	FCB	$76,4,75
	FCB	$3B,0,76	'RTI'
	FCB	$39,0,77	'RTS'
	FCB	$82,1,78	'SBCA'
	FCB	$92,3,78
	FCB	$A2,5,78
	FCB	$B2,4,78
	FCB	$C2,1,79	'SBCB'
	FCB	$D2,3,79
	FCB	$E2,5,79
	FCB	$F2,4,79
	FCB	$1D,0,80
	FCB	$80,1,81	'SUBA'
	FCB	$90,3,81
	FCB	$A0,5,81
	FCB	$B0,4,81
	FCB	$C0,1,82	'SUBB'
	FCB	$D0,3,82
	FCB	$E0,5,82
	FCB	$F0,4,82
	FCB	$83,2,83	'SUBD'
	FCB	$93,3,83
	FCB	$A3,5,83
	FCB	$B3,4,83
	FCB	$3F,0,84	'SWI'
	FCB	$13,0,85	'SYNC'
	FCB	$4D,0,86	'TSTA'
	FCB	$5D,0,87	'TSTB'
	FCB	$0D,3,88	'TST'
	FCB	$6D,5,88
	FCB	$7D,4,88
	FCB	$16,9,99	'LBRA'
	FCB	$17,9,100	'LBSR'
	FCB	$20,8,101	'BRA'
	FCB	$21,8,102	'BRN'
	FCB	$22,8,103	'BHI'
	FCB	$23,8,104	'BLS'
	FCB	$24,8,105	'BCC'
	FCB	$25,8,106	'BCS'
	FCB	$26,8,107	'BNE'
	FCB	$27,8,108	'BEQ'
	FCB	$28,8,109	'BVC'
	FCB	$29,8,110	'BVS'
	FCB	$2A,8,111	'BPL'
	FCB	$2B,8,112	'BMI'
	FCB	$2C,8,113	'BGE'
	FCB	$2D,8,114	'BLT'
	FCB	$2E,8,115	'BGT'
	FCB	$2F,8,116	'BLE'
	FCB	$8D,8,132	'BSR'
	FCB	$CF,0,0		'FCB', UNKNOWN OPCODE

;*
;* OPERAND TABLE NUMBER TWO, $10 PREFIX INSTRUCTIONS
;*
OPTAB2
	FCB	$83,2,89	'CMPD'
	FCB	$8C,2,90	'CMPY'
	FCB	$8E,2,92	'LDY'
	FCB	$93,3,89
	FCB	$9C,3,90
	FCB	$9E,3,92
	FCB	$9F,3,94	'STY'
	FCB	$A3,5,89
	FCB	$AC,5,90
	FCB	$AE,5,92
	FCB	$AF,5,94
	FCB	$B3,4,89
	FCB	$BC,4,90
	FCB	$BE,4,92
	FCB	$BF,4,94
	FCB	$CE,2,91	'LDS'
	FCB	$DE,3,91
	FCB	$DF,3,93	'STS'
	FCB	$EE,5,91
	FCB	$EF,5,93
	FCB	$FE,4,91
	FCB	$FF,4,93
	FCB	$3F,0,95	'SWI2'
	FCB	$21,9,117	'LBRN'
	FCB	$22,9,118	'LBHI'
	FCB	$23,9,119	'LBLS'
	FCB	$24,9,120	'LBCC'
	FCB	$25,9,121	'LBCS'
	FCB	$26,9,122	'LBNE'
	FCB	$27,9,123	'LBEQ'
	FCB	$28,9,124	'LBVC'
	FCB	$29,9,125	'LBVS'
	FCB	$2A,9,126	'LBPL'
	FCB	$2B,9,127	'LBMI'
	FCB	$2C,9,128	'LBGE'
	FCB	$2D,9,129	'LBLT'
	FCB	$2E,9,130	'LBGT'
	FCB	$2F,9,131	'LBLE'
	FCB	$CF,1,0

;*
;* OPERAND TABLE #3, $11 PREFIXES
;*
OPTAB3
	FCB	$8C,2,96	'CMPS'
	FCB	$9C,3,96
	FCB	$AC,5,96
	FCB	$BC,4,96
	FCB	$83,2,97	'CMPU'
	FCB	$93,3,97
	FCB	$A3,5,97
	FCB	$B3,4,97
	FCB	$3F,0,98	'SWI3'

;*
;* INSTRUCTION TEXT TABLE
;*
ITABLE
	FCC	'FCB '		0
	FCC	'LDA '		1
	FCC	'LDB '		2
	FCC	'LDD '		3
	FCC	'LDU '		4
	FCC	'LDX '		5
	FCC	'STA '		6
	FCC	'STB '		7
	FCC	'STD '		8
	FCC	'STU '		9
	FCC	'STX '		10
	FCC	'ABX '		11
	FCC	'ADCA'		12
	FCC	'ADCB'		13
	FCC	'ADDA'		14
	FCC	'ADDB'		15
	FCC	'ADDD'		16
	FCC	'ASLA'		17
	FCC	'ASLB'		18
	FCC	'ASL '		19
	FCC	'ASRA'		20
	FCC	'ASRB'		21
	FCC	'ASR '		22
	FCC	'BITA'		23
	FCC	'BITB'		24
	FCC	'CLRA'		25
	FCC	'CLRB'		26
	FCC	'CLR '		27
	FCC	'CMPA'		28
	FCC	'CMPB'		29
	FCC	'CMPX'		30
	FCC	'COMA'		31
	FCC	'COMB'		32
	FCC	'COM '		33
	FCC	'CWAI'		34
	FCC	'DAA '		35
	FCC	'DECA'		36
	FCC	'DECB'		37
	FCC	'DEC '		38
	FCC	'EORA'		39
	FCC	'EORB'		40
	FCC	'EXG '		41
	FCC	'TFR '		42
	FCC	'PSHS'		43
	FCC	'PSHU'		44
	FCC	'PULS'		45
	FCC	'PULU'		46
	FCC	'INCA'		47
	FCC	'INCB'		48
	FCC	'INC '		49
	FCC	'JMP '		50
	FCC	'JSR '		51
	FCC	'LEAS'		52
	FCC	'LEAU'		53
	FCC	'LEAX'		54
	FCC	'LEAY'		55
	FCC	'LSRA'		56
	FCC	'LSRB'		57
	FCC	'LSR '		58
	FCC	'MUL '		59
	FCC	'NEGA'		60
	FCC	'NEGB'		61
	FCC	'NEG '		62
	FCC	'NOP '		63
	FCC	'ORA '		64
	FCC	'ORB '		65
	FCC	'ORCC'		66
	FCC	'ANDA'		67
	FCC	'ANDB'		68
	FCC	'ANDC'		69
	FCC	'ROLA'		70
	FCC	'ROLB'		71
	FCC	'ROL '		72
	FCC	'RORA'		73
	FCC	'RORB'		74
	FCC	'ROR '		75
	FCC	'RTI '		76
	FCC	'RTS '		77
	FCC	'SBCA'		78
	FCC	'SBCB'		79
	FCC	'SEX '		80
	FCC	'SUBA'		81
	FCC	'SUBB'		82
	FCC	'SUBD'		83
	FCC	'SWI '		84
	FCC	'SYNC'		85
	FCC	'TSTA'		86
	FCC	'TSTB'		87
	FCC	'TST '		88
	FCC	'CMPD'		89
	FCC	'CMPY'		90
	FCC	'LDS '		91
	FCC	'LDY '		92
	FCC	'STS '		93
	FCC	'STY '		94
	FCC	'SWI2'		95
	FCC	'CMPS'		96
	FCC	'CMPU'		97
	FCC	'SWI3'		98
	FCC	'LBRA'		99
	FCC	'LBSR'		100
	FCC	'BRA '		101
	FCC	'BRN '		102
	FCC	'BHI '		103
	FCC	'BLS '		104
	FCC	'BCC '		105
	FCC	'BCS '		106
	FCC	'BNE '		107
	FCC	'BEQ '		108
	FCC	'BVC '		109
	FCC	'BVS '		110
	FCC	'BPL '		111
	FCC	'BMI '		112
	FCC	'BGE '		113
	FCC	'BLT '		114
	FCC	'BGT '		115
	FCC	'BLE '		116
	FCC	'LBRN'		117
	FCC	'LBHI'		118
	FCC	'LBLS'		119
	FCC	'LBCC'		120
	FCC	'LBCS'		121
	FCC	'LBNE'		122
	FCC	'LBEQ'		123
	FCC	'LBVC'		124
	FCC	'LBVS'		125
	FCC	'LBPL'		126
	FCC	'LBMI'		127
	FCC	'LBGE'		128
	FCC	'LBLT'		129
	FCC	'LBGT'		130
	FCC	'LBLE'		131
	FCC	'BSR '		132

;*
;* CONDITIONAL TABLE, FIRST BYTE IS MASK, NEXT THREE BYTES ARE POSSIBLE
;* BIT SETTINGS
;*
CONTAB
	FCB	$05,$00,$00,$00	'BHI', NO C OR Z
	FCB	$05,$01,$04,$05	'BLS', EITHER C OR Z
	FCB	$01,$00,$00,$00	'BCC', NO C
	FCB	$01,$01,$01,$01	'BCS', C SET
	FCB	$04,$00,$00,$00	'BNE', NO Z
	FCB	$04,$04,$04,$04	'BEQ', Z SET
	FCB	$02,$00,$00,$00	'BVC', V CLEAR
	FCB	$02,$02,$02,$02	'BVS', V SET
	FCB	$08,$00,$00,$00	'BPL', N CLEAR
	FCB	$08,$08,$08,$08	'BMI', N SET
	FCB	$0A,$00,$0A,$0A	'BGE', N=V
	FCB	$0A,$08,$02,$02	'BLT', N -= V
	FCB	$0E,$0A,$00,$00	'BGT', N=V, Z=0
	FCB	$0E,$08,$02,$04	'BLE', V-=N OR Z=1
	FCB	$0C,$06,$0E

;* TRANSFER AND EXCHANGE REGISTER TABLE
TFREGT	FDB	SAVA
INDTAB	FDB	SAVX
	FDB	SAVY
	FDB	SAVU
	FDB	SAVS
	FDB	SAVPC

;* PULL TABLE FOR PULS
PULSTAB	FDB	SAVCC
	FDB	SAVA
	FDB	SAVB
	FDB	SAVDP
	FDB	SAVX
	FDB	SAVY
	FDB	SAVU
	FDB	SAVPC

;* PULL TABLE FOR PULU
PULUTAB	FDB	SAVCC
	FDB	SAVA
	FDB	SAVB
	FDB	SAVDP
	FDB	SAVX
	FDB	SAVY
	FDB	SAVS
	FDB	SAVPC

;* VECTOR HANDLERS
SWI3	JMP	[SWI3ADR]
SWI2	JMP	[SWI2ADR]
IRQ	JMP	[IRQADR]
FIRQ	JMP	[FIRQADR]
;MODS BY JQ
 IFNE JQ_NMIRAM		USE JQ NMI ENHANCEMENTS
NMI	JMP	[NMIADR]
 ENDC
 IFNE JQ_ILLOP		USE JQ ILLOP ENHANCEMENTS
ILOP	JMP	[ILOPADR]
 ENDC
;
;* HELP TEXT
HTEXT	FCB	0		NEW LINE TO START
	FCN		'B 0-7 <addr>|Set breakpoint (0000=remove)'
	FCN		'CR <reg> <data>|Change register'
	FCN		'CU <uart> <addr>|Change UART address'

 IFNE JQ_ILLOP	JQ ILLOP ENHANCEMENTS
	FCN		'CV <vec> <addr>|Change interrupt vector (vec=1-7)'
 ELSE
	FCN		'CV <vec> <addr>|Change interrupt vector (vec=1-6)'
 ENDC			JQ ILLOP ENHANCEMENTS

	FCN		'DB|Display breakpoints'
	FCN		'DD <addr>,<addr>|Display dissasembled memory'
	FCN		'DM <addr>,<addr>|Display memory in hex dump format'
	FCN		'DR|Display processor registers'
	FCN		'DU|Display UART addresses'
	FCN		'DV|Display interrupt vectors'
	FCN		'E <addr>|Edit memory'
	FCN		'FM <addr>,<addr> <data>|Fill memory'
	FCN		'G [<addr>]|Go (execute program)'
;MODS BY JQ
 IFNE JQ_JMPMOD		JQ JUMP ENHANCEMENTS
;	FCN		'J <B><T><F>|Jump to <B>ASIC, <T>inyBASIC or <F>ORTH'
;	FCN		'J <B><F>|Jump to <B>ASIC or <F>ORTH'
	FCN		'J <B>|Jump to Extended <B>asic'
 ENDC				JQ JUMP ENHANCEMENTS
;
	FCN		'L|Load iHEX or S19 image from UART2'
	FCN		'MM <addr>,<addr> <addr>|Move memory (Source,End Destination)'
	FCN		'MT <addr>,<addr>|Memory test'
	FCN		'RR <addr>|Repeating READ access'
	FCN		'RW <addr> <data>|Repeating WRITE access'
	FCN		'S [<addr>]|Single step execution'
;	FCN		'T|Terminal passthrough to UART2'
	FCN		'W <addr> <data>|Write to memory'
	FCN		'XR <addr>|Repeating 16 bit read'
	FCN		'XW <addr> <word>|Repeating 16 bit write'
	FCN		'+ <value>+<value>|Hexadecimal addition'
	FCN		'- <value>-<value>|Hexadecimal subtraction'
	FCB	-1		END OF TABLE
;*
;
;===============================================================================
;*
;* MACHINE DEPENDANT I/O ROUTINES FOR 68(3)B50 UARTS
;*	X REGISTER HOLDS PORT ADDRESS.
;===============================================================================
;* INITIALIZE UART(X)
INIT
	LDA	#CTRL1		MASTER RESET
	STA	,X		WRITE COMMAND REG
	LDA	#CTRL2		ENABLE 115200, 8NO1
	STA	,X		WRITE COMMAND REG
	RTS
;
;===============================================================================
;* READ UART(X)
READ
	LDA	,X		GET STATUS
	BITA	#RDRF		RECEIVER READY?
	BEQ	NOCHR		NO CHARACTER
	LDA	1,X		READ CHARACTER
	ORCC	#%00000100	SET 'Z'
	RTS
NOCHR
	LDA	#$FF		NO CHAR
	RTS
;
;===============================================================================
;* WRITE UART(X)
WRITE
	LDB	,X		GET STATUS
	BITB	#TDRE		XMITTER READY?
	BEQ	WRITE		NO, TRY AGAIN
	STA	1,X		OUTPUT
	RTS
;
;===============================================================================
; LOOKUP TABLE CONTAINING MON09 RAM INTERRUPT RE-VECTORING ADDRESSES
;===============================================================================
MON09_SWIADR	JMP	[SWIADR]	;SWI Interrupt vector
MON09_SWI2ADR	JMP	[SWI2ADR]	;SWI2 Interrupt vector
MON09_SWI3ADR	JMP	[SWI3ADR]	;SWI3 Interrupt vector
MON09_FIRQADR	JMP	[FIRQADR]	;FIRQ Interrupt vector
MON09_IRQADR	JMP	[IRQADR]	;IRQ Interrupt vector

  IFNE JQ_NMIRAM	;JQ NMI ENHANCEMENTS
MON09_NMIADR	JMP	[NMIADR]	;NMI Interrupt vector
  ENDC				;		JQ NMI ENHANCEMENTS
  IFNE JQ_ILLOP		;USE JQ ILLOP ENHANCEMENTS
MON09_ILOPADR	JMP	[ILOPADR]	;ILLOP Interrupt vector
  ENDC				;USE JQ ILLOP ENHANCEMENTS
;
 IFLT LOC	;IF NOT IN RAM
	FILL $FF,VECTTBL-*
;*
;* MACHINE VECTORS
;*
;MODS BY JQ
  IFNE JQ_ILLOP		USE JQ ILLOP ENHANCEMENTS
	ORG	VECTTBL
	FDB	ILOP		HD6309 ONLY
  ELSE
	ORG	VECTTBL
  ENDC				USE JQ ILLOP ENHANCEMENTS
;
	FDB	SWI3
	FDB	SWI2
	FDB	FIRQ
	FDB	IRQ
	FDB	SWIHND
;MODS BY JQ
  IFNE JQ_NMIRAM	USE JQ NMI ENHANCEMENTS
	FDB	NMI			USE LOCAL NMI HANDLER
  ELSE
	FDB	NMIHND		USE MON09 NMI HANDLER
  ENDC
;
	FDB	RESET
 ENDC		;IF NOT IN RAM
